#!/bin/sh
#
# use "$1" or something in a real script, this 
# just hard-codes it.
#
merge_repo=$1

echo "Getting object database"
rsync -avz --ignore-existing $merge_repo/ .git/

echo "Getting remote head"
rsync -avz $merge_repo/HEAD .git/MERGE_HEAD

head=$(cat .git/HEAD)
merge_head=$(cat .git/MERGE_HEAD)
common=$(merge-base $head $merge_head)
if [ -z "$common" ]; then
	echo "Unable to find common commit between" $merge_head $head
	exit 1
fi

# Get the trees associated with those commits
common_tree=$(cat-file commit $common | sed 's/tree //;q')
head_tree=$(cat-file commit $head | sed 's/tree //;q')
merge_tree=$(cat-file commit $merge_head | sed 's/tree //;q')

if [ "$common" == "$merge_head" ]; then
	echo "Already up-to-date. Yeeah!"
	exit 0
fi
if [ "$common" == "$head" ]; then
	echo "Updating from $head to $merge_head."
	echo "Destroying all noncommitted data!"
	echo "Kill me within 3 seconds.."
	sleep 3
	read-tree $merge_tree && checkout-cache -f -a
	echo $merge_head > .git/HEAD
	exit 0
fi
echo "Trying to merge $merge_head into $head"
read-tree -m $common_tree $head_tree $merge_tree
result_tree=$(write-tree) || exit 1
result_commit=$(echo "Merge $merge_repo" | commit-tree $result_tree -p $head -p $merge_head)
echo "Committed merge $result_commit"
echo $result_commit > .git/HEAD
read-tree $result_tree && checkout-cache -f -a
