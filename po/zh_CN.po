# Chinese translations for Git package
# Git 软件包的简体中文翻译.
# Copyright (C) 2012,2013 Jiang Xin <worldhello.net AT gmail.com>
# This file is distributed under the same license as the Git package.
# Contributors:
#   - Fangyi Zhou <me AT fangyi.io>
#   - Jiang Xin <worldhello.net AT gmail.com>
#   - Lian Cheng <rhythm.mail AT gmail.com>
#   - Ray Chen <oldsharp AT gmail.com>
#   - Riku <lu.riku AT gmail.com>
#   - Thynson <lanxingcan AT gmail.com>
#   - ws3389 <willsmith3389 AT gmail.com>
#   - Wang Sheng <wangsheng2008love AT 163.com>
#   - 依云 <lilydjwg AT gmail.com>
#   - Yichao Yu <yyc1992 AT gmail.com>
#   - Zhuang Ya <zhuangya AT me.com>
#   - Teng Long <dyroneteng AT gmail.com>
#
#  Git glossary for Chinese translators
#
#   English                          |  Chinese
#   ---------------------------------+--------------------------------------
#   3-way merge                      |  三方合并
#   abbreviate                       |  简写（的 SHA-1 值）
#   alternate object database        |  备用对象库
#   attribute source                 |  属性来源
#   amend                            |  修补
#   ancestor                         |  祖先，祖先提交
#   annotated tag                    |  附注标签
#   bare repository                  |  纯仓库
#   bisect                           |  二分查找
#   bitmap                           |  位图
#   blob object                      |  数据对象
#   bloom filter                     |  布隆过滤器
#   branch                           |  分支
#   bundle                           |  归档包
#   bypass                           |  绕过
#   cache                            |  索引（的别称）
#   chain                            |  （提交）链
#   changeset                        |  变更集
#   checkout                         |  检出
#   checksum                         |  校验，校验和
#   cherry-picking                   |  拣选
#   clean                            |  干净（的工作区）
#   clone                            |  克隆
#   commit                           |  提交
#   commit message                   |  提交说明
#   commit object                    |  提交对象
#   commit-graph                     |  提交图
#   commit-ish (also committish)     |  提交号
#   cone                             |  锥形（稀疏检出模型）；锥（稀疏检出）
#   conflict                         |  冲突
#   core Git                         |  核心 Git 工具
#   cover letter                     |  附函
#   DAG                              |  有向无环图
#   dangling object                  |  悬空对象
#   detached HEAD                    |  分离头指针
#   directory                        |  目录
#   dirty                            |  脏（的工作区）
#   dumb HTTP protocol               |  哑 HTTP 协议
#   enlistment                       |  登记（在 scalar 中使用）
#   evil merge                       |  坏合并（合并引入了父提交没有的修改）
#   fast-forward                     |  快进
#   fetch                            |  获取
#   file system                      |  文件系统
#   fork                             |  派生
#   Git archive                      |  仓库（对于 arch 用户）
#   gitfile                          |  gitfile（仓库链接文件）
#   grafts                           |  （提交）移植
#   hash                             |  哈希值
#   HEAD                             |  HEAD（头指针，亦即当前分支）
#   head                             |  头、分支
#   head ref                         |  分支
#   header                           |  头信息
#   hook                             |  钩子
#   hunk                             |  补丁片段
#   index                            |  索引
#   index entry                      |  索引条目
#   loose object                     |  松散对象
#   loose refs                       |  松散引用
#   magic                            |  神奇前缀（路径规格支持的一种前缀表达式）
#   master                           |  master（默认分支名）
#   merge                            |  合并
#   object                           |  对象
#   object database                  |  对象库
#   object identifier                |  对象标识符
#   object name                      |  对象名称
#   object type                      |  对象类型
#   octopus                          |  章鱼式合并（两分支以上的合并）
#   origin                           |  origin（默认的远程名称）
#   orphan                           |  孤立（一般指孤立分支，即没有任何提交的分支）
#   pack                             |  包
#   pack index                       |  包索引
#   packfile                         |  包文件
#   parent                           |  父提交
#   partial clone                    |  部分克隆
#   patch                            |  补丁
#   pathspec                         |  路径规格
#   pattern                          |  模式
#   pickaxe                          |  挖掘
#   plumbing                         |  管件（Git 底层核心命令的别称）
#   porcelain                        |  瓷件（Git 上层封装命令的别称）
#   precious-objects repo            |  珍品仓库
#   preferred pack                   |  首选包（多包索引中引入的首选包概念）
#   promisor                         |  承诺者
#   prune                            |  清除
#   pseudorefs                       |  伪引用
#   pull                             |  拉，拉取
#   push                             |  推，推送
#   reachable                        |  可达
#   rebase                           |  变基
#   ref                              |  引用
#   reflog                           |  引用日志
#   refmap                           |  引用映射
#   refspec                          |  引用规格
#   remote                           |  远程，远程仓库
#   remote-tracking branch           |  远程跟踪分支
#   replay                           |  重放
#   repo                             |  仓库
#   repository                       |  仓库
#   resolve                          |  （冲突）解决
#   revert                           |  还原
#   revision                         |  版本
#   rewind                           |  回退
#   SCM                              |  源代码管理（工具）
#   SHA-1                            |  SHA-1（安全哈希算法1）
#   shallow repository               |  浅（克隆）仓库
#   signed tag                       |  签名标签
#   smart HTTP protocol              |  智能 HTTP 协议
#   squash                           |  挤压
#   stage                            |  n. 暂存区（即索引）; v. 暂存
#   stale                            |  过期的
#   stash                            |  n. 贮藏区; v. 贮藏
#   submodule                        |  子模组
#   symref                           |  符号引用
#   tag                              |  n. 标签; v. 打标签
#   tag object                       |  标签对象
#   tagger                           |  打标签者
#   topic branch                     |  主题分支
#   track                            |  跟踪
#   trailer                          |  尾注
#   tree                             |  树（工作区或树对象）
#   tree object                      |  树对象
#   tree-ish (also treeish)          |  树对象（或可以解析为一树对象）
#   unmerged index                   |  未合并索引
#   unpack                           |  解包
#   unreachable object               |  不可达对象
#   unstage                          |  取消暂存
#   upstream                         |  上游
#   upstream branch                  |  上游分支
#   working tree                     |  工作区
# Fangyi Zhou <me@fangyi.io>, 2021-2023.
#
msgid ""
msgstr ""
"Project-Id-Version: Git\n"
"Report-Msgid-Bugs-To: Git Mailing List <git@vger.kernel.org>\n"
"POT-Creation-Date: 2025-03-09 20:34+0800\n"
"PO-Revision-Date: 2025-03-12 14:47+0800\n"
"Last-Translator: Teng Long <dyroneteng@gmail.com>\n"
"Language-Team: GitHub <https://github.com/dyrone/git/>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Gtranslator 42.0\n"

#: add-interactive.c
#, c-format
msgid "Huh (%s)?"
msgstr "嗯（%s）？"

#: add-interactive.c builtin/merge.c builtin/rebase.c reset.c sequencer.c
msgid "could not read index"
msgstr "不能读取索引"

#: add-interactive.c
msgid "binary"
msgstr "二进制"

#: add-interactive.c
msgid "nothing"
msgstr "无"

#: add-interactive.c
msgid "unchanged"
msgstr "没有修改"

#: add-interactive.c
msgid "Update"
msgstr "更新"

#: add-interactive.c
#, c-format
msgid "could not stage '%s'"
msgstr "不能暂存 '%s'"

#: add-interactive.c builtin/stash.c reset.c sequencer.c
msgid "could not write index"
msgstr "不能写入索引"

#: add-interactive.c
#, c-format
msgid "updated %d path\n"
msgid_plural "updated %d paths\n"
msgstr[0] "更新了 %d 个路径\n"
msgstr[1] "更新了 %d 个路径\n"

#: add-interactive.c
#, c-format
msgid "note: %s is untracked now.\n"
msgstr "说明：%s 现已成为未跟踪的。\n"

#: add-interactive.c apply.c builtin/checkout.c builtin/reset.c
#, c-format
msgid "make_cache_entry failed for path '%s'"
msgstr "对路径 '%s' 的 make_cache_entry 操作失败"

#: add-interactive.c
msgid "Revert"
msgstr "还原"

#: add-interactive.c
msgid "Could not parse HEAD^{tree}"
msgstr "不能解析 HEAD^{tree}"

#: add-interactive.c
#, c-format
msgid "reverted %d path\n"
msgid_plural "reverted %d paths\n"
msgstr[0] "还原了 %d 个路径\n"
msgstr[1] "还原了 %d 个路径\n"

#: add-interactive.c
#, c-format
msgid "No untracked files.\n"
msgstr "没有未跟踪的文件。\n"

#: add-interactive.c
msgid "Add untracked"
msgstr "添加未跟踪的"

#: add-interactive.c
#, c-format
msgid "added %d path\n"
msgid_plural "added %d paths\n"
msgstr[0] "增加了 %d 个路径\n"
msgstr[1] "增加了 %d 个路径\n"

#: add-interactive.c
#, c-format
msgid "ignoring unmerged: %s"
msgstr "忽略未合入的：%s"

#: add-interactive.c
#, c-format
msgid "Only binary files changed.\n"
msgstr "只有二进制文件被修改。\n"

#: add-interactive.c
#, c-format
msgid "No changes.\n"
msgstr "没有修改。\n"

#: add-interactive.c
msgid "Patch update"
msgstr "补丁更新"

#: add-interactive.c
msgid "Review diff"
msgstr "检视 diff"

#: add-interactive.c
msgid "show paths with changes"
msgstr "显示含变更的路径"

#: add-interactive.c
msgid "add working tree state to the staged set of changes"
msgstr "将工作区状态添加到暂存区修改集中"

#: add-interactive.c
msgid "revert staged set of changes back to the HEAD version"
msgstr "将暂存的修改集恢复为 HEAD 版本"

#: add-interactive.c
msgid "pick hunks and update selectively"
msgstr "挑选数据块并有选择地更新"

#: add-interactive.c
msgid "view diff between HEAD and index"
msgstr "显示 HEAD 和索引的差异"

#: add-interactive.c
msgid "add contents of untracked files to the staged set of changes"
msgstr "将未跟踪文件的内容添加到暂存区修改集中"

#: add-interactive.c
msgid "Prompt help:"
msgstr "帮助："

#: add-interactive.c
msgid "select a single item"
msgstr "选择一个条目"

#: add-interactive.c
msgid "select a range of items"
msgstr "选择一系列条目"

#: add-interactive.c
msgid "select multiple ranges"
msgstr "选择多个范围"

#: add-interactive.c
msgid "select item based on unique prefix"
msgstr "基于唯一前缀选择条目"

#: add-interactive.c
msgid "unselect specified items"
msgstr "反选指定的条目"

#: add-interactive.c
msgid "choose all items"
msgstr "选择所有条目"

#: add-interactive.c
msgid "(empty) finish selecting"
msgstr "（空）结束选择"

#: add-interactive.c
msgid "select a numbered item"
msgstr "选择一个编号条目"

#: add-interactive.c
msgid "(empty) select nothing"
msgstr "（空）不选择任何内容"

#: add-interactive.c builtin/clean.c
msgid "*** Commands ***"
msgstr "*** 命令 ***"

#: add-interactive.c builtin/clean.c
msgid "What now"
msgstr "请选择"

#: add-interactive.c
msgid "staged"
msgstr "缓存"

#: add-interactive.c
msgid "unstaged"
msgstr "未缓存"

#: add-interactive.c apply.c builtin/am.c builtin/bugreport.c builtin/clone.c
#: builtin/diagnose.c builtin/fetch.c builtin/hook.c builtin/merge.c
#: builtin/pull.c builtin/submodule--helper.c
msgid "path"
msgstr "路径"

#: add-interactive.c
msgid "could not refresh index"
msgstr "不能刷新索引"

#: add-interactive.c builtin/clean.c
#, c-format
msgid "Bye.\n"
msgstr "再见。\n"

#: add-patch.c
#, c-format
msgid "Stage mode change [y,n,q,a,d%s,?]? "
msgstr "暂存模式变更 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Stage deletion [y,n,q,a,d%s,?]? "
msgstr "暂存删除动作 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Stage addition [y,n,q,a,d%s,?]? "
msgstr "暂存添加动作 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Stage this hunk [y,n,q,a,d%s,?]? "
msgstr "暂存该块 [y,n,q,a,d%s,?]? "

#: add-patch.c
msgid ""
"If the patch applies cleanly, the edited hunk will immediately be marked for "
"staging."
msgstr "如果补丁能正确地应用，编辑块将立即标记为暂存。"

#: add-patch.c
msgid ""
"y - stage this hunk\n"
"n - do not stage this hunk\n"
"q - quit; do not stage this hunk or any of the remaining ones\n"
"a - stage this hunk and all later hunks in the file\n"
"d - do not stage this hunk or any of the later hunks in the file\n"
msgstr ""
"y - 暂存该块\n"
"n - 不要暂存该块\n"
"q - 退出。不暂存该块及后面的全部块\n"
"a - 暂存该块和本文件中后面的全部块\n"
"d - 不暂存该块和本文件中后面的全部块\n"

#: add-patch.c
#, c-format
msgid "Stash mode change [y,n,q,a,d%s,?]? "
msgstr "贮藏模式变更 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Stash deletion [y,n,q,a,d%s,?]? "
msgstr "贮藏删除动作 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Stash addition [y,n,q,a,d%s,?]? "
msgstr "贮藏添加动作 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Stash this hunk [y,n,q,a,d%s,?]? "
msgstr "贮藏该块 [y,n,q,a,d%s,?]? "

#: add-patch.c
msgid ""
"If the patch applies cleanly, the edited hunk will immediately be marked for "
"stashing."
msgstr "如果补丁能正确地应用，编辑块将立即标记为贮藏。"

#: add-patch.c
msgid ""
"y - stash this hunk\n"
"n - do not stash this hunk\n"
"q - quit; do not stash this hunk or any of the remaining ones\n"
"a - stash this hunk and all later hunks in the file\n"
"d - do not stash this hunk or any of the later hunks in the file\n"
msgstr ""
"y - 贮藏该块\n"
"n - 不要贮藏该块\n"
"q - 退出。不贮藏该块及后面的全部块\n"
"a - 贮藏该块和本文件中后面的全部块\n"
"d - 不贮藏该块和本文件中后面的全部块\n"

#: add-patch.c
#, c-format
msgid "Unstage mode change [y,n,q,a,d%s,?]? "
msgstr "取消暂存模式变更 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Unstage deletion [y,n,q,a,d%s,?]? "
msgstr "取消暂存删除动作 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Unstage addition [y,n,q,a,d%s,?]? "
msgstr "取消暂存添加动作 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Unstage this hunk [y,n,q,a,d%s,?]? "
msgstr "取消暂存该块 [y,n,q,a,d%s,?]? "

#: add-patch.c
msgid ""
"If the patch applies cleanly, the edited hunk will immediately be marked for "
"unstaging."
msgstr "如果补丁能正确地应用，编辑块将立即标记为未暂存。"

#: add-patch.c
msgid ""
"y - unstage this hunk\n"
"n - do not unstage this hunk\n"
"q - quit; do not unstage this hunk or any of the remaining ones\n"
"a - unstage this hunk and all later hunks in the file\n"
"d - do not unstage this hunk or any of the later hunks in the file\n"
msgstr ""
"y - 取消暂存该块\n"
"n - 不要取消暂存该块\n"
"q - 退出。不要取消暂存该块及后面的全部块\n"
"a - 取消暂存该块和本文件中后面的全部块\n"
"d - 不要取消暂存该块和本文件中后面的全部块\n"

#: add-patch.c
#, c-format
msgid "Apply mode change to index [y,n,q,a,d%s,?]? "
msgstr "将模式变更应用到索引 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Apply deletion to index [y,n,q,a,d%s,?]? "
msgstr "将删除操作应用到索引 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Apply addition to index [y,n,q,a,d%s,?]? "
msgstr "将添加操作应用到索引 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Apply this hunk to index [y,n,q,a,d%s,?]? "
msgstr "将该块应用到索引 [y,n,q,a,d%s,?]? "

#: add-patch.c
msgid ""
"If the patch applies cleanly, the edited hunk will immediately be marked for "
"applying."
msgstr "如果补丁能正确地应用，编辑块将立即标记为应用。"

#: add-patch.c
msgid ""
"y - apply this hunk to index\n"
"n - do not apply this hunk to index\n"
"q - quit; do not apply this hunk or any of the remaining ones\n"
"a - apply this hunk and all later hunks in the file\n"
"d - do not apply this hunk or any of the later hunks in the file\n"
msgstr ""
"y - 在索引中应用该块\n"
"n - 不要在索引中应用该块\n"
"q - 退出。不要应用该块及后面的全部块\n"
"a - 应用该块和本文件中后面的全部块\n"
"d - 不要应用该块和本文件中后面的全部块\n"

#: add-patch.c
#, c-format
msgid "Discard mode change from worktree [y,n,q,a,d%s,?]? "
msgstr "从工作区中丢弃模式变更 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Discard deletion from worktree [y,n,q,a,d%s,?]? "
msgstr "从工作区中丢弃删除动作 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Discard addition from worktree [y,n,q,a,d%s,?]? "
msgstr "从工作区中丢弃添加动作 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Discard this hunk from worktree [y,n,q,a,d%s,?]? "
msgstr "从工作区中丢弃该块 [y,n,q,a,d%s,?]? "

#: add-patch.c
msgid ""
"If the patch applies cleanly, the edited hunk will immediately be marked for "
"discarding."
msgstr "如果补丁能正确地应用，编辑块将立即标记为丢弃。"

#: add-patch.c
msgid ""
"y - discard this hunk from worktree\n"
"n - do not discard this hunk from worktree\n"
"q - quit; do not discard this hunk or any of the remaining ones\n"
"a - discard this hunk and all later hunks in the file\n"
"d - do not discard this hunk or any of the later hunks in the file\n"
msgstr ""
"y - 在工作区中丢弃该块\n"
"n - 不要在工作区中丢弃该块\n"
"q - 退出。不要丢弃该块及后面的全部块\n"
"a - 丢弃该块和本文件中后面的全部块\n"
"d - 不要丢弃该块和本文件中后面的全部块\n"

#: add-patch.c
#, c-format
msgid "Discard mode change from index and worktree [y,n,q,a,d%s,?]? "
msgstr "从索引和工作区中丢弃模式变更 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Discard deletion from index and worktree [y,n,q,a,d%s,?]? "
msgstr "从索引和工作区中丢弃删除动作 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Discard addition from index and worktree [y,n,q,a,d%s,?]? "
msgstr "从索引和工作区中丢弃添加动作 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Discard this hunk from index and worktree [y,n,q,a,d%s,?]? "
msgstr "从索引和工作区中丢弃该块 [y,n,q,a,d%s,?]? "

#: add-patch.c
msgid ""
"y - discard this hunk from index and worktree\n"
"n - do not discard this hunk from index and worktree\n"
"q - quit; do not discard this hunk or any of the remaining ones\n"
"a - discard this hunk and all later hunks in the file\n"
"d - do not discard this hunk or any of the later hunks in the file\n"
msgstr ""
"y - 在索引和工作区中丢弃该块\n"
"n - 不要在索引和工作区中丢弃该块\n"
"q - 退出。不要丢弃该块及后面的全部块\n"
"a - 丢弃该块和本文件中后面的全部块\n"
"d - 不要丢弃该块和本文件中后面的全部块\n"

#: add-patch.c
#, c-format
msgid "Apply mode change to index and worktree [y,n,q,a,d%s,?]? "
msgstr "将模式变更应用到索引和工作区 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Apply deletion to index and worktree [y,n,q,a,d%s,?]? "
msgstr "将删除操作应用到索引和工作区 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Apply addition to index and worktree [y,n,q,a,d%s,?]? "
msgstr "将添加操作应用到索引和工作区 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Apply this hunk to index and worktree [y,n,q,a,d%s,?]? "
msgstr "将该块应用到索引和工作区 [y,n,q,a,d%s,?]? "

#: add-patch.c
msgid ""
"y - apply this hunk to index and worktree\n"
"n - do not apply this hunk to index and worktree\n"
"q - quit; do not apply this hunk or any of the remaining ones\n"
"a - apply this hunk and all later hunks in the file\n"
"d - do not apply this hunk or any of the later hunks in the file\n"
msgstr ""
"y - 在索引和工作区中应用该块\n"
"n - 不要在索引和工作区中应用该块\n"
"q - 退出。不要应用该块及后面的全部块\n"
"a - 应用该块和本文件中后面的全部块\n"
"d - 不要应用该块和本文件中后面的全部块\n"

#: add-patch.c
#, c-format
msgid "Apply mode change to worktree [y,n,q,a,d%s,?]? "
msgstr "将模式变更应用到工作区 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Apply deletion to worktree [y,n,q,a,d%s,?]? "
msgstr "将删除操作应用到工作区 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Apply addition to worktree [y,n,q,a,d%s,?]? "
msgstr "将添加操作应用到工作区 [y,n,q,a,d%s,?]? "

#: add-patch.c
#, c-format
msgid "Apply this hunk to worktree [y,n,q,a,d%s,?]? "
msgstr "将该块应用到工作区 [y,n,q,a,d%s,?]? "

#: add-patch.c
msgid ""
"y - apply this hunk to worktree\n"
"n - do not apply this hunk to worktree\n"
"q - quit; do not apply this hunk or any of the remaining ones\n"
"a - apply this hunk and all later hunks in the file\n"
"d - do not apply this hunk or any of the later hunks in the file\n"
msgstr ""
"y - 在工作区中应用该块\n"
"n - 不要在工作区中应用该块\n"
"q - 退出。不要应用该块及后面的全部块\n"
"a - 应用该块和本文件中后面的全部块\n"
"d - 不要应用该块和本文件中后面的全部块\n"

#: add-patch.c
#, c-format
msgid "could not parse hunk header '%.*s'"
msgstr "无法解析数据块头信息 '%.*s'"

#: add-patch.c
msgid "could not parse diff"
msgstr "不能解析差异信息"

#: add-patch.c
msgid "could not parse colored diff"
msgstr "不能解析彩色差异信息"

#: add-patch.c
#, c-format
msgid "failed to run '%s'"
msgstr "无法运行 '%s'"

#: add-patch.c
msgid "mismatched output from interactive.diffFilter"
msgstr "interactive.diffFilter 的输出不匹配"

#: add-patch.c
msgid ""
"Your filter must maintain a one-to-one correspondence\n"
"between its input and output lines."
msgstr "您的过滤器必须在其输入和输出的行之间保持一一对应的关系。"

#: add-patch.c
#, c-format
msgid ""
"expected context line #%d in\n"
"%.*s"
msgstr ""
"预期上下文行 #%d 于\n"
"%.*s"

#: add-patch.c
#, c-format
msgid ""
"hunks do not overlap:\n"
"%.*s\n"
"\tdoes not end with:\n"
"%.*s"
msgstr ""
"块不重叠：\n"
"%.*s\n"
"\t不是结尾于：\n"
"%.*s"

#: add-patch.c
msgid "Manual hunk edit mode -- see bottom for a quick guide.\n"
msgstr "手动块编辑模式 -- 查看底部的快速指南。\n"

#: add-patch.c
#, c-format
msgid ""
"---\n"
"To remove '%c' lines, make them ' ' lines (context).\n"
"To remove '%c' lines, delete them.\n"
"Lines starting with %s will be removed.\n"
msgstr ""
"---\n"
"要删除 '%c' 开始的行，使其成为 ' ' 开始的行（上下文）。\n"
"要删除 '%c' 开始的行，删除它们。\n"
"以 %s 开始的行将被删除。\n"

#: add-patch.c
msgid ""
"If it does not apply cleanly, you will be given an opportunity to\n"
"edit again.  If all lines of the hunk are removed, then the edit is\n"
"aborted and the hunk is left unchanged.\n"
msgstr ""
"如果不能干净地应用，您将有机会重新编辑。如果该块的全部内容删除，则\n"
"此次编辑被终止，该块不会被修改。\n"

#: add-patch.c
msgid "could not parse hunk header"
msgstr "无法解析数据块头信息"

#: add-patch.c
msgid "'git apply --cached' failed"
msgstr "'git apply --cached' 失败"

#. TRANSLATORS: do not translate [y/n]
#. The program will only accept that input at this point.
#. Consider translating (saying "no" discards!) as
#. (saying "n" for "no" discards!) if the translation
#. of the word "no" does not start with n.
#.
#: add-patch.c
msgid ""
"Your edited hunk does not apply. Edit again (saying \"no\" discards!) [y/n]? "
msgstr "您的编辑块不能被应用。重新编辑（选择 \"no\" 丢弃！） [y/n]? "

#: add-patch.c
msgid "The selected hunks do not apply to the index!"
msgstr "选中的块不能应用到索引！"

#: add-patch.c
msgid "Apply them to the worktree anyway? "
msgstr "无论如何都要应用到工作区么？"

#: add-patch.c
msgid "Nothing was applied.\n"
msgstr "未应用。\n"

#: add-patch.c
msgid ""
"j - leave this hunk undecided, see next undecided hunk\n"
"J - leave this hunk undecided, see next hunk\n"
"k - leave this hunk undecided, see previous undecided hunk\n"
"K - leave this hunk undecided, see previous hunk\n"
"g - select a hunk to go to\n"
"/ - search for a hunk matching the given regex\n"
"s - split the current hunk into smaller hunks\n"
"e - manually edit the current hunk\n"
"p - print the current hunk, 'P' to use the pager\n"
"? - print help\n"
msgstr ""
"j - 维持该块未决状态，查看下一个未决块\n"
"J - 维持该块未决状态，查看下一个块\n"
"k - 维持该块未决状态，查看上一个未决块\n"
"K - 维持该块未决状态，查看上一个块\n"
"g - 选择跳转到一个块\n"
"/ - 查找和给定正则表达式匹配的块\n"
"s - 拆分当前块为更小的块\n"
"e - 手动编辑当前块\n"
"p - 显示当前块, 'P' 使用分页器\n"
"? - 显示帮助\n"

#: add-patch.c
#, c-format
msgid "Only one letter is expected, got '%s'"
msgstr "预期只有一个字母，得到 '%s'"

#: add-patch.c
msgid "No previous hunk"
msgstr "没有前一个块"

#: add-patch.c
msgid "No next hunk"
msgstr "没有下一个块"

#: add-patch.c
msgid "No other hunks to goto"
msgstr "没有其它可供跳转的块"

#: add-patch.c
msgid "go to which hunk (<ret> to see more)? "
msgstr "跳转到哪个块（<回车> 查看更多）？ "

#: add-patch.c
msgid "go to which hunk? "
msgstr "跳转到哪个块？"

#: add-patch.c
#, c-format
msgid "Invalid number: '%s'"
msgstr "无效数字：'%s'"

#: add-patch.c
#, c-format
msgid "Sorry, only %d hunk available."
msgid_plural "Sorry, only %d hunks available."
msgstr[0] "对不起，只有 %d 个可用块。"
msgstr[1] "对不起，只有 %d 个可用块。"

#: add-patch.c
msgid "No other hunks to search"
msgstr "没有其它可供查找的块"

#: add-patch.c
msgid "search for regex? "
msgstr "使用正则表达式搜索？"

#: add-patch.c
#, c-format
msgid "Malformed search regexp %s: %s"
msgstr "错误的正则表达式 %s：%s"

#: add-patch.c
msgid "No hunk matches the given pattern"
msgstr "没有和给定模式相匹配的块"

#: add-patch.c
msgid "Sorry, cannot split this hunk"
msgstr "对不起，不能拆分这个块"

#: add-patch.c
#, c-format
msgid "Split into %d hunks."
msgstr "拆分为 %d 块。"

#: add-patch.c
msgid "Sorry, cannot edit this hunk"
msgstr "对不起，不能编辑这个块"

#: add-patch.c
#, c-format
msgid "Unknown command '%s' (use '?' for help)"
msgstr "未知命令 '%s'（使用 '?' 寻求帮助）"

#: add-patch.c
msgid "'git apply' failed"
msgstr "'git apply' 失败"

#: add-patch.c
msgid "No changes."
msgstr "没有修改。"

#: add-patch.c
msgid "Only binary files changed."
msgstr "只有二进制文件被修改。"

#: advice.c
#, c-format
msgid ""
"\n"
"Disable this message with \"git config set advice.%s false\""
msgstr ""
"\n"
"使用 \"git config set advice.%s false\" 来关闭此消息"

#: advice.c
#, c-format
msgid "%shint:%s%.*s%s\n"
msgstr "%s提示：%s%.*s%s\n"

#: advice.c
msgid "Cherry-picking is not possible because you have unmerged files."
msgstr "无法拣选，因为您有未合并的文件。"

#: advice.c
msgid "Committing is not possible because you have unmerged files."
msgstr "无法提交，因为您有未合并的文件。"

#: advice.c
msgid "Merging is not possible because you have unmerged files."
msgstr "无法合并，因为您有未合并的文件。"

#: advice.c
msgid "Pulling is not possible because you have unmerged files."
msgstr "无法拉取，因为您有未合并的文件。"

#: advice.c
msgid "Reverting is not possible because you have unmerged files."
msgstr "无法回退，因为您有未合并的文件。"

#: advice.c
msgid "Rebasing is not possible because you have unmerged files."
msgstr "无法变基，因为您有未合并的文件。"

#: advice.c
msgid ""
"Fix them up in the work tree, and then use 'git add/rm <file>'\n"
"as appropriate to mark resolution and make a commit."
msgstr ""
"请在工作区改正文件，然后酌情使用 'git add/rm <文件>' 命令标记\n"
"解决方案并提交。"

#: advice.c
msgid "Exiting because of an unresolved conflict."
msgstr "因为存在未解决的冲突而退出。"

#: advice.c builtin/merge.c
msgid "You have not concluded your merge (MERGE_HEAD exists)."
msgstr "您尚未结束您的合并（存在 MERGE_HEAD）。"

#: advice.c
msgid "Please, commit your changes before merging."
msgstr "请在合并前先提交您的修改。"

#: advice.c
msgid "Exiting because of unfinished merge."
msgstr "因为存在未完成的合并而退出。"

#: advice.c
msgid ""
"Diverging branches can't be fast-forwarded, you need to either:\n"
"\n"
"\tgit merge --no-ff\n"
"\n"
"or:\n"
"\n"
"\tgit rebase\n"
msgstr ""
"无法在偏离的分支上进行快进操作，您需要:\n"
"\n"
"\tgit merge --no-ff\n"
"\n"
"或者：\n"
"\n"
"\tgit rebase\n"

#: advice.c
msgid "Not possible to fast-forward, aborting."
msgstr "无法快进，终止。"

#: advice.c
#, c-format
msgid ""
"The following paths and/or pathspecs matched paths that exist\n"
"outside of your sparse-checkout definition, so will not be\n"
"updated in the index:\n"
msgstr ""
"下面的路径和/或者路径规格匹配了您定义的稀疏检出以外的路径，\n"
"所以不会在索引中更新：\n"

#: advice.c
msgid ""
"If you intend to update such entries, try one of the following:\n"
"* Use the --sparse option.\n"
"* Disable or modify the sparsity rules."
msgstr ""
"如果您意图更新这些条目，请尝试下列其中之一：\n"
"* 使用 --sparse 选项。\n"
"* 禁用或者修改稀疏规则。"

#: advice.c
#, c-format
msgid ""
"Note: switching to '%s'.\n"
"\n"
"You are in 'detached HEAD' state. You can look around, make experimental\n"
"changes and commit them, and you can discard any commits you make in this\n"
"state without impacting any branches by switching back to a branch.\n"
"\n"
"If you want to create a new branch to retain commits you create, you may\n"
"do so (now or later) by using -c with the switch command. Example:\n"
"\n"
"  git switch -c <new-branch-name>\n"
"\n"
"Or undo this operation with:\n"
"\n"
"  git switch -\n"
"\n"
"Turn off this advice by setting config variable advice.detachedHead to "
"false\n"
"\n"
msgstr ""
"注意：正在切换到 '%s'。\n"
"\n"
"您正处于分离头指针状态。您可以查看、做试验性的修改及提交，并且您可以在切换\n"
"回一个分支时，丢弃在此状态下所做的提交而不对分支造成影响。\n"
"\n"
"如果您想要通过创建分支来保留在此状态下所做的提交，您可以通过在 switch 命令\n"
"中添加参数 -c 来实现（现在或稍后）。例如：\n"
"\n"
"  git switch -c <新分支名>\n"
"\n"
"或者撤销此操作：\n"
"\n"
"  git switch -\n"
"\n"
"通过将配置变量 advice.detachedHead 设置为 false 来关闭此建议\n"
"\n"

#: advice.c
#, c-format
msgid ""
"The following paths have been moved outside the\n"
"sparse-checkout definition but are not sparse due to local\n"
"modifications.\n"
msgstr ""
"下列的路径已经被移动至稀疏检出的定义之外，\n"
"但是由于本地的修改而并非稀疏。\n"

#: advice.c
msgid ""
"To correct the sparsity of these paths, do the following:\n"
"* Use \"git add --sparse <paths>\" to update the index\n"
"* Use \"git sparse-checkout reapply\" to apply the sparsity rules"
msgstr ""
"为了修正这些的路径的稀疏性，请运行下列命令：\n"
"* 使用 \"git add --sparse <路径>\" 来更新索引\n"
"* 使用 \"git sparse-checkout reapply\" 来应用稀疏规则"

#: alias.c
msgid "cmdline ends with \\"
msgstr "命令行以 \\ 结尾"

#: alias.c
msgid "unclosed quote"
msgstr "未关闭的引号"

#: alias.c builtin/cat-file.c builtin/notes.c builtin/prune-packed.c
#: builtin/receive-pack.c builtin/refs.c builtin/tag.c t/helper/test-pkt-line.c
msgid "too many arguments"
msgstr "太多参数"

#: apply.c
#, c-format
msgid "unrecognized whitespace option '%s'"
msgstr "未能识别的空白字符选项 '%s'"

#: apply.c
#, c-format
msgid "unrecognized whitespace ignore option '%s'"
msgstr "未能识别的空白字符忽略选项 '%s'"

#: apply.c archive.c builtin/add.c builtin/branch.c builtin/checkout-index.c
#: builtin/checkout.c builtin/clean.c builtin/clone.c builtin/commit.c
#: builtin/describe.c builtin/diff-tree.c builtin/difftool.c
#: builtin/fast-export.c builtin/fetch.c builtin/help.c builtin/index-pack.c
#: builtin/init-db.c builtin/log.c builtin/ls-files.c builtin/merge-base.c
#: builtin/merge-tree.c builtin/merge.c builtin/pack-objects.c builtin/rebase.c
#: builtin/repack.c builtin/replay.c builtin/reset.c builtin/rev-list.c
#: builtin/rev-parse.c builtin/show-branch.c builtin/stash.c
#: builtin/submodule--helper.c builtin/tag.c builtin/worktree.c parse-options.c
#: range-diff.c revision.c
#, c-format
msgid "options '%s' and '%s' cannot be used together"
msgstr "选项 '%s' 和 '%s' 不能同时使用"

#: apply.c
#, c-format
msgid "'%s' outside a repository"
msgstr "'%s' 在仓库之外"

#: apply.c
msgid "failed to read patch"
msgstr "无法读取补丁"

#: apply.c
msgid "patch too large"
msgstr "补丁过大"

#: apply.c
#, c-format
msgid "Cannot prepare timestamp regexp %s"
msgstr "无法准备时间戳正则表达式 %s"

#: apply.c
#, c-format
msgid "regexec returned %d for input: %s"
msgstr "regexec 返回 %d，输入为：%s"

#: apply.c
#, c-format
msgid "unable to find filename in patch at line %d"
msgstr "不能在补丁的第 %d 行找到文件名"

#: apply.c
#, c-format
msgid "git apply: bad git-diff - expected /dev/null, got %s on line %d"
msgstr "git apply：错误的 git-diff - 应为 /dev/null，但在第 %2$d 行得到 %1$s"

#: apply.c
#, c-format
msgid "git apply: bad git-diff - inconsistent new filename on line %d"
msgstr "git apply：错误的 git-diff - 第 %d 行上新文件名不一致"

#: apply.c
#, c-format
msgid "git apply: bad git-diff - inconsistent old filename on line %d"
msgstr "git apply：错误的 git-diff - 第 %d 行上旧文件名不一致"

#: apply.c
#, c-format
msgid "git apply: bad git-diff - expected /dev/null on line %d"
msgstr "git apply：错误的 git-diff - 第 %d 行处应为 /dev/null"

#: apply.c
#, c-format
msgid "invalid mode on line %d: %s"
msgstr "第 %d 行包含无效文件模式：%s"

#: apply.c
#, c-format
msgid "inconsistent header lines %d and %d"
msgstr "不一致的文件头，%d 行和 %d 行"

#: apply.c
#, c-format
msgid ""
"git diff header lacks filename information when removing %d leading pathname "
"component (line %d)"
msgid_plural ""
"git diff header lacks filename information when removing %d leading pathname "
"components (line %d)"
msgstr[0] "当移除 %d 个前导路径后 git diff 头缺乏文件名信息（第 %d 行）"
msgstr[1] "当移除 %d 个前导路径后 git diff 头缺乏文件名信息（第 %d 行）"

#: apply.c
#, c-format
msgid "git diff header lacks filename information (line %d)"
msgstr "git diff 的头信息中缺乏文件名信息（第 %d 行）"

#: apply.c
#, c-format
msgid "recount: unexpected line: %.*s"
msgstr "recount：意外的行：%.*s"

#: apply.c
#, c-format
msgid "patch fragment without header at line %d: %.*s"
msgstr "第 %d 行的补丁片段没有头信息：%.*s"

#: apply.c
msgid "new file depends on old contents"
msgstr "新文件依赖旧内容"

#: apply.c
msgid "deleted file still has contents"
msgstr "删除的文件仍有内容"

#: apply.c
#, c-format
msgid "corrupt patch at line %d"
msgstr "补丁在第 %d 行损坏"

#: apply.c
#, c-format
msgid "new file %s depends on old contents"
msgstr "新文件 %s 依赖旧内容"

#: apply.c
#, c-format
msgid "deleted file %s still has contents"
msgstr "删除的文件 %s 仍有内容"

#: apply.c
#, c-format
msgid "** warning: file %s becomes empty but is not deleted"
msgstr "** 警告：文件 %s 成为空文件但并未删除"

#: apply.c
#, c-format
msgid "corrupt binary patch at line %d: %.*s"
msgstr "二进制补丁在第 %d 行损坏：%.*s"

#: apply.c
#, c-format
msgid "unrecognized binary patch at line %d"
msgstr "未能识别的二进制补丁位于第 %d 行"

#: apply.c
#, c-format
msgid "patch with only garbage at line %d"
msgstr "补丁文件的第 %d 行只有垃圾数据"

#: apply.c
#, c-format
msgid "unable to read symlink %s"
msgstr "无法读取符号链接 %s"

#: apply.c
#, c-format
msgid "unable to open or read %s"
msgstr "不能打开或读取 %s"

#: apply.c
#, c-format
msgid "invalid start of line: '%c'"
msgstr "无效的行首字符：'%c'"

#: apply.c
#, c-format
msgid "Hunk #%d succeeded at %d (offset %d line)."
msgid_plural "Hunk #%d succeeded at %d (offset %d lines)."
msgstr[0] "块 #%d 成功应用于 %d（偏移 %d 行）"
msgstr[1] "块 #%d 成功应用于 %d（偏移 %d 行）"

#: apply.c
#, c-format
msgid "Context reduced to (%ld/%ld) to apply fragment at %d"
msgstr "上下文减少到（%ld/%ld）以在第 %d 行应用补丁片段"

#: apply.c
#, c-format
msgid ""
"while searching for:\n"
"%.*s"
msgstr ""
"当查询：\n"
"%.*s"

#: apply.c
#, c-format
msgid "missing binary patch data for '%s'"
msgstr "缺失 '%s' 的二进制补丁数据"

#: apply.c
#, c-format
msgid "cannot reverse-apply a binary patch without the reverse hunk to '%s'"
msgstr "不能反向应用一个缺少到 '%s' 的反向数据块的二进制补丁"

#: apply.c
#, c-format
msgid "cannot apply binary patch to '%s' without full index line"
msgstr "不能在 '%s' 上应用没有完整索引行的二进制补丁"

#: apply.c
#, c-format
msgid ""
"the patch applies to '%s' (%s), which does not match the current contents."
msgstr "补丁应用到 '%s'（%s），但是和当前内容不匹配。"

#: apply.c
#, c-format
msgid "the patch applies to an empty '%s' but it is not empty"
msgstr "补丁应用到空文件 '%s'，但其并非空文件"

#: apply.c
#, c-format
msgid "the necessary postimage %s for '%s' cannot be read"
msgstr "无法读取 '%2$s' 必需的目标文件 %1$s"

#: apply.c
#, c-format
msgid "binary patch does not apply to '%s'"
msgstr "二进制补丁未应用到 '%s'"

#: apply.c
#, c-format
msgid "binary patch to '%s' creates incorrect result (expecting %s, got %s)"
msgstr "到 '%s' 的二进制补丁产生了不正确的结果（应为 %s，却为 %s）"

#: apply.c
#, c-format
msgid "patch failed: %s:%ld"
msgstr "打补丁失败：%s:%ld"

#: apply.c builtin/mv.c
#, c-format
msgid "cannot checkout %s"
msgstr "不能检出 %s"

#: apply.c midx.c pack-mtimes.c pack-revindex.c setup.c
#, c-format
msgid "failed to read %s"
msgstr "无法读取 %s"

#: apply.c
#, c-format
msgid "reading from '%s' beyond a symbolic link"
msgstr "读取位于符号链接中的 '%s'"

#: apply.c
#, c-format
msgid "path %s has been renamed/deleted"
msgstr "路径 %s 已经被重命名/删除"

#: apply.c
#, c-format
msgid "%s: does not exist in index"
msgstr "%s：不存在于索引中"

#: apply.c
#, c-format
msgid "%s: does not match index"
msgstr "%s：和索引不匹配"

#: apply.c
msgid "repository lacks the necessary blob to perform 3-way merge."
msgstr "仓库缺乏执行三方合并所必需的数据对象。"

#: apply.c
#, c-format
msgid "Performing three-way merge...\n"
msgstr "执行三方合并...\n"

#: apply.c
#, c-format
msgid "cannot read the current contents of '%s'"
msgstr "无法读取 '%s' 的当前内容"

#: apply.c
#, c-format
msgid "Failed to perform three-way merge...\n"
msgstr "无法执行三方合并...\n"

#: apply.c
#, c-format
msgid "Applied patch to '%s' with conflicts.\n"
msgstr "应用补丁到 '%s' 存在冲突。\n"

#: apply.c
#, c-format
msgid "Applied patch to '%s' cleanly.\n"
msgstr "成功应用补丁到 '%s'。\n"

#: apply.c
#, c-format
msgid "Falling back to direct application...\n"
msgstr "回落到直接应用...\n"

#: apply.c
msgid "removal patch leaves file contents"
msgstr "移除补丁仍留下了文件内容"

#: apply.c
#, c-format
msgid "%s: wrong type"
msgstr "%s：错误类型"

#: apply.c
#, c-format
msgid "%s has type %o, expected %o"
msgstr "%s 的类型是 %o，应为 %o"

#: apply.c read-cache.c
#, c-format
msgid "invalid path '%s'"
msgstr "无效路径 '%s'"

#: apply.c
#, c-format
msgid "%s: already exists in index"
msgstr "%s：已经存在于索引中"

#: apply.c
#, c-format
msgid "%s: already exists in working directory"
msgstr "%s：已经存在于工作区中"

#: apply.c
#, c-format
msgid "new mode (%o) of %s does not match old mode (%o)"
msgstr "%2$s 的新模式（%1$o）和旧模式（%3$o）不匹配"

#: apply.c
#, c-format
msgid "new mode (%o) of %s does not match old mode (%o) of %s"
msgstr "%2$s 的新模式（%1$o）和 %4$s 的旧模式（%3$o）不匹配"

#: apply.c
#, c-format
msgid "affected file '%s' is beyond a symbolic link"
msgstr "受影响的文件 '%s' 位于符号链接中"

#: apply.c
#, c-format
msgid "%s: patch does not apply"
msgstr "%s：补丁未应用"

#: apply.c
#, c-format
msgid "Checking patch %s..."
msgstr "正在检查补丁 %s..."

#: apply.c
#, c-format
msgid "sha1 information is lacking or useless for submodule %s"
msgstr "子模组 %s 的 sha1 信息缺失或无效"

#: apply.c
#, c-format
msgid "mode change for %s, which is not in current HEAD"
msgstr "%s 的模式变更，但它不在当前 HEAD 中"

#: apply.c
#, c-format
msgid "sha1 information is lacking or useless (%s)."
msgstr "sha1 信息缺失或无效（%s）。"

#: apply.c
#, c-format
msgid "could not add %s to temporary index"
msgstr "不能在临时索引中添加 %s"

#: apply.c
#, c-format
msgid "could not write temporary index to %s"
msgstr "不能把临时索引写入到 %s"

#: apply.c
#, c-format
msgid "unable to remove %s from index"
msgstr "不能从索引中移除 %s"

#: apply.c
#, c-format
msgid "corrupt patch for submodule %s"
msgstr "子模组 %s 损坏的补丁"

#: apply.c
#, c-format
msgid "unable to stat newly created file '%s'"
msgstr "不能对新建文件 '%s' 调用 stat"

#: apply.c
#, c-format
msgid "unable to create backing store for newly created file %s"
msgstr "不能为新建文件 %s 创建后端存储"

#: apply.c
#, c-format
msgid "unable to add cache entry for %s"
msgstr "无法为 %s 添加缓存条目"

#: apply.c builtin/bisect.c builtin/gc.c
#, c-format
msgid "failed to write to '%s'"
msgstr "无法写入 '%s'"

#: apply.c
#, c-format
msgid "closing file '%s'"
msgstr "关闭文件 '%s'"

#: apply.c
#, c-format
msgid "unable to write file '%s' mode %o"
msgstr "不能写文件 '%s' 权限 %o"

#: apply.c
#, c-format
msgid "Applied patch %s cleanly."
msgstr "成功应用补丁 %s。"

#: apply.c
msgid "internal error"
msgstr "内部错误"

#: apply.c
#, c-format
msgid "Applying patch %%s with %d reject..."
msgid_plural "Applying patch %%s with %d rejects..."
msgstr[0] "应用 %%s 个补丁，其中 %d 个被拒绝..."
msgstr[1] "应用 %%s 个补丁，其中 %d 个被拒绝..."

#: apply.c
#, c-format
msgid "cannot open %s"
msgstr "不能打开 %s"

#: apply.c rerere.c
#, c-format
msgid "cannot unlink '%s'"
msgstr "不能删除 '%s'"

#: apply.c
#, c-format
msgid "Hunk #%d applied cleanly."
msgstr "第 #%d 个片段成功应用。"

#: apply.c
#, c-format
msgid "Rejected hunk #%d."
msgstr "拒绝第 #%d 个片段。"

#: apply.c
#, c-format
msgid "Skipped patch '%s'."
msgstr "略过补丁 '%s'。"

#: apply.c
msgid "No valid patches in input (allow with \"--allow-empty\")"
msgstr "输入中没有合法的补丁 （使用 \"--allow-empty\" 来允许）"

#: apply.c t/helper/test-cache-tree.c
msgid "unable to read index file"
msgstr "无法读取索引文件"

#: apply.c
#, c-format
msgid "can't open patch '%s': %s"
msgstr "不能打开补丁 '%s'：%s"

#: apply.c
#, c-format
msgid "squelched %d whitespace error"
msgid_plural "squelched %d whitespace errors"
msgstr[0] "抑制下仍有 %d 个空白字符误用"
msgstr[1] "抑制下仍有 %d 个空白字符误用"

#: apply.c
#, c-format
msgid "%d line adds whitespace errors."
msgid_plural "%d lines add whitespace errors."
msgstr[0] "%d 行新增了空白字符误用。"
msgstr[1] "%d 行新增了空白字符误用。"

#: apply.c
#, c-format
msgid "%d line applied after fixing whitespace errors."
msgid_plural "%d lines applied after fixing whitespace errors."
msgstr[0] "修复空白错误后，应用了 %d 行。"
msgstr[1] "修复空白错误后，应用了 %d 行。"

#: apply.c builtin/mv.c builtin/rm.c
msgid "Unable to write new index file"
msgstr "无法写入新索引文件"

#: apply.c
msgid "don't apply changes matching the given path"
msgstr "不要应用与给出路径向匹配的变更"

#: apply.c
msgid "apply changes matching the given path"
msgstr "应用与给出路径向匹配的变更"

#: apply.c builtin/am.c
msgid "num"
msgstr "数字"

#: apply.c
msgid "remove <num> leading slashes from traditional diff paths"
msgstr "从传统的 diff 路径中移除指定数量的前导斜线"

#: apply.c
msgid "ignore additions made by the patch"
msgstr "忽略补丁中的添加的文件"

#: apply.c
msgid "instead of applying the patch, output diffstat for the input"
msgstr "不应用补丁，而是显示输入的差异统计（diffstat）"

#: apply.c
msgid "show number of added and deleted lines in decimal notation"
msgstr "以十进制数显示添加和删除的行数"

#: apply.c
msgid "instead of applying the patch, output a summary for the input"
msgstr "不应用补丁，而是显示输入的概要"

#: apply.c
msgid "instead of applying the patch, see if the patch is applicable"
msgstr "不应用补丁，而是查看补丁是否可应用"

#: apply.c
msgid "make sure the patch is applicable to the current index"
msgstr "确认补丁可以应用到当前索引"

#: apply.c
msgid "mark new files with `git add --intent-to-add`"
msgstr "使用命令 `git add --intent-to-add` 标记新增文件"

#: apply.c
msgid "apply a patch without touching the working tree"
msgstr "应用补丁而不修改工作区"

#: apply.c
msgid "accept a patch that touches outside the working area"
msgstr "接受修改工作区之外文件的补丁"

#: apply.c
msgid "also apply the patch (use with --stat/--summary/--check)"
msgstr "还应用此补丁（与 --stat/--summary/--check 选项同时使用）"

#: apply.c
msgid "attempt three-way merge, fall back on normal patch if that fails"
msgstr "尝试三路合并，如果失败则回落至正常补丁模式"

#: apply.c builtin/merge-file.c
msgid "for conflicts, use our version"
msgstr "如果冲突，使用我们的版本"

#: apply.c builtin/merge-file.c
msgid "for conflicts, use their version"
msgstr "如果冲突，使用他们的版本"

#: apply.c builtin/merge-file.c
msgid "for conflicts, use a union version"
msgstr "如果冲突，使用联合版本"

#: apply.c
msgid "build a temporary index based on embedded index information"
msgstr "创建一个临时索引基于嵌入的索引信息"

#: apply.c builtin/checkout-index.c
msgid "paths are separated with NUL character"
msgstr "路径以 NUL 字符分隔"

#: apply.c
msgid "ensure at least <n> lines of context match"
msgstr "确保至少匹配 <n> 行上下文"

#: apply.c builtin/am.c builtin/interpret-trailers.c builtin/pack-objects.c
#: builtin/rebase.c
msgid "action"
msgstr "动作"

#: apply.c
msgid "detect new or modified lines that have whitespace errors"
msgstr "检查新增和修改的行中间的空白字符滥用"

#: apply.c
msgid "ignore changes in whitespace when finding context"
msgstr "查找上下文时忽略空白字符的变更"

#: apply.c
msgid "apply the patch in reverse"
msgstr "反向应用补丁"

#: apply.c
msgid "don't expect at least one line of context"
msgstr "无需至少一行上下文"

#: apply.c
msgid "leave the rejected hunks in corresponding *.rej files"
msgstr "将拒绝的补丁片段保存在对应的 *.rej 文件中"

#: apply.c
msgid "allow overlapping hunks"
msgstr "允许重叠的补丁片段"

#: apply.c
msgid "tolerate incorrectly detected missing new-line at the end of file"
msgstr "允许不正确的文件末尾换行符"

#: apply.c
msgid "do not trust the line counts in the hunk headers"
msgstr "不信任补丁片段的头信息中的行号"

#: apply.c builtin/am.c
msgid "root"
msgstr "根目录"

#: apply.c
msgid "prepend <root> to all filenames"
msgstr "为所有文件名前添加 <根目录>"

#: apply.c
msgid "don't return error for empty patches"
msgstr "对空的补丁不返回错误"

#: apply.c
msgid "--ours, --theirs, and --union require --3way"
msgstr "--ours、--theirs 和 --union 需要 --3way"

#: archive-tar.c archive-zip.c
#, c-format
msgid "cannot stream blob %s"
msgstr "不能打开数据对象 %s"

#: archive-tar.c archive-zip.c
#, c-format
msgid "unsupported file mode: 0%o (SHA1: %s)"
msgstr "不支持的文件模式：0%o (SHA1: %s)"

#: archive-tar.c archive-zip.c builtin/pack-objects.c
#, c-format
msgid "deflate error (%d)"
msgstr "压缩错误 (%d)"

#: archive-tar.c
#, c-format
msgid "unable to start '%s' filter"
msgstr "无法启动 '%s' 过滤器"

#: archive-tar.c
msgid "unable to redirect descriptor"
msgstr "无法重定向描述符"

#: archive-tar.c
#, c-format
msgid "'%s' filter reported error"
msgstr "'%s' 过滤器报告了错误"

#: archive-zip.c
#, c-format
msgid "path is not valid UTF-8: %s"
msgstr "路径不是有效的 UTF-8：%s"

#: archive-zip.c
#, c-format
msgid "path too long (%d chars, SHA1: %s): %s"
msgstr "路径太长（%d 字符，SHA1：%s）：%s"

#: archive-zip.c
#, c-format
msgid "timestamp too large for this system: %<PRIuMAX>"
msgstr "对于本系统时间戳太大：%<PRIuMAX>"

#: archive.c
msgid "git archive [<options>] <tree-ish> [<path>...]"
msgstr "git archive [<选项>] <树对象> [<路径>...]"

#: archive.c
msgid ""
"git archive --remote <repo> [--exec <cmd>] [<options>] <tree-ish> [<path>...]"
msgstr ""
"git archive --remote <仓库> [--exec <命令>] [<选项>] <树对象> [<路径>...]"

#: archive.c
msgid "git archive --remote <repo> [--exec <cmd>] --list"
msgstr "git archive --remote <仓库> [--exec <命令>] --list"

#: archive.c builtin/gc.c builtin/notes.c builtin/tag.c
#, c-format
msgid "cannot read '%s'"
msgstr "不能读取 '%s'"

#: archive.c
#, c-format
msgid "pathspec '%s' matches files outside the current directory"
msgstr "路径规格 '%s' 匹配了当前目录外的文件'"

#: archive.c builtin/add.c builtin/rm.c
#, c-format
msgid "pathspec '%s' did not match any files"
msgstr "路径规格 '%s' 未匹配任何文件"

#: archive.c
#, c-format
msgid "no such ref: %.*s"
msgstr "无此引用：%.*s"

#: archive.c
#, c-format
msgid "not a valid object name: %s"
msgstr "不是一个有效的对象名：%s"

#: archive.c t/helper/test-cache-tree.c
#, c-format
msgid "not a tree object: %s"
msgstr "不是一个树对象：%s"

#: archive.c
#, c-format
msgid "failed to unpack tree object %s"
msgstr "无法解包树对象 %s"

#: archive.c
#, c-format
msgid "File not found: %s"
msgstr "文件未找到：%s"

#: archive.c
#, c-format
msgid "Not a regular file: %s"
msgstr "不是一个常规文件：%s"

#: archive.c
#, c-format
msgid "unclosed quote: '%s'"
msgstr "未关闭的引号：'%s'"

#: archive.c
#, c-format
msgid "missing colon: '%s'"
msgstr "缺失冒号：'%s'"

#: archive.c
#, c-format
msgid "empty file name: '%s'"
msgstr "空的文件名：'%s'"

#: archive.c
msgid "fmt"
msgstr "格式"

#: archive.c
msgid "archive format"
msgstr "归档格式"

#: archive.c builtin/log.c parse-options.h
msgid "prefix"
msgstr "前缀"

#: archive.c
msgid "prepend prefix to each pathname in the archive"
msgstr "为归档中每个路径名加上前缀"

#: archive.c builtin/blame.c builtin/commit-tree.c builtin/config.c
#: builtin/fast-export.c builtin/gc.c builtin/grep.c builtin/hash-object.c
#: builtin/ls-files.c builtin/notes.c builtin/read-tree.c parse-options.h
msgid "file"
msgstr "文件"

#: archive.c
msgid "add untracked file to archive"
msgstr "将未跟踪文件添加到归档"

#: archive.c
msgid "path:content"
msgstr "路径:内容"

#: archive.c builtin/archive.c
msgid "write the archive to this file"
msgstr "归档写入此文件"

#: archive.c
msgid "read .gitattributes in working directory"
msgstr "读取工作区中的 .gitattributes"

#: archive.c
msgid "report archived files on stderr"
msgstr "在标准错误上报告归档文件"

#: archive.c builtin/clone.c builtin/fetch.c builtin/pack-objects.c
#: builtin/pull.c
msgid "time"
msgstr "时间"

#: archive.c
msgid "set modification time of archive entries"
msgstr "设置归档条目的修改时间"

#: archive.c
msgid "set compression level"
msgstr "设置压缩级别"

#: archive.c
msgid "list supported archive formats"
msgstr "列出支持的归档格式"

#: archive.c builtin/archive.c builtin/clone.c builtin/submodule--helper.c
msgid "repo"
msgstr "仓库"

#: archive.c builtin/archive.c
msgid "retrieve the archive from remote repository <repo>"
msgstr "从远程仓库（<仓库>）提取归档文件"

#: archive.c builtin/archive.c builtin/difftool.c builtin/notes.c
msgid "command"
msgstr "命令"

#: archive.c builtin/archive.c
msgid "path to the remote git-upload-archive command"
msgstr "远程 git-upload-archive 命令的路径"

#: archive.c
msgid "Unexpected option --remote"
msgstr "未知参数 --remote"

#: archive.c builtin/add.c builtin/checkout.c builtin/clone.c builtin/commit.c
#: builtin/fast-export.c builtin/index-pack.c builtin/log.c builtin/reset.c
#: builtin/rm.c builtin/stash.c builtin/worktree.c fetch-pack.c http-fetch.c
#: revision.c
#, c-format
msgid "the option '%s' requires '%s'"
msgstr "选项 '%s' 需要 '%s'"

#: archive.c
msgid "Unexpected option --output"
msgstr "未知参数 --output"

#: archive.c t/unit-tests/unit-test.c
#, c-format
msgid "extra command line parameter '%s'"
msgstr "额外的命令行参数：'%s'"

#: archive.c
#, c-format
msgid "Unknown archive format '%s'"
msgstr "未知归档格式 '%s'"

#: archive.c
#, c-format
msgid "Argument not supported for format '%s': -%d"
msgstr "参数不支持此格式 '%s'：-%d"

#: attr.c
#, c-format
msgid "%.*s is not a valid attribute name"
msgstr "%.*s 不是一个有效的属性名"

#: attr.c
msgid "unable to add additional attribute"
msgstr "不能添加额外属性"

#: attr.c
#, c-format
msgid "ignoring overly long attributes line %d"
msgstr "忽略过长的属性行 %d"

#: attr.c
#, c-format
msgid "%s not allowed: %s:%d"
msgstr "不允许 %s：%s:%d"

#: attr.c
msgid ""
"Negative patterns are ignored in git attributes\n"
"Use '\\!' for literal leading exclamation."
msgstr ""
"负值模版在 git attributes 中被忽略\n"
"当字符串确实要以感叹号开始时，使用 '\\!'。"

#: attr.c
#, c-format
msgid "cannot fstat gitattributes file '%s'"
msgstr "无法 fstat gitattributes 文件 '%s'"

#: attr.c
#, c-format
msgid "ignoring overly large gitattributes file '%s'"
msgstr "忽略过大的 gitattributes 文件 '%s'"

#: attr.c
#, c-format
msgid "ignoring overly large gitattributes blob '%s'"
msgstr "忽略过大的 gitattributes 数据对象 '%s'"

#: attr.c
msgid "cannot use --attr-source or GIT_ATTR_SOURCE without repo"
msgstr "无法在没有仓库的情况下使用 --attr-source 或 GIT_ATTR_SOURCE"

#: attr.c
msgid "bad --attr-source or GIT_ATTR_SOURCE"
msgstr "错误的 --attr-source 或 GIT_ATTR_SOURCE"

#: attr.c read-cache.c
#, c-format
msgid "unable to stat '%s'"
msgstr "无法对 %s 执行 stat"

#: bisect.c builtin/cat-file.c builtin/index-pack.c builtin/notes.c
#: builtin/pack-objects.c combine-diff.c object-file.c rerere.c
#, c-format
msgid "unable to read %s"
msgstr "不能读 %s"

#: bisect.c
#, c-format
msgid "Badly quoted content in file '%s': %s"
msgstr "文件 '%s' 包含错误的引用格式：%s"

#: bisect.c
#, c-format
msgid "We cannot bisect more!\n"
msgstr "我们无法进行更多的二分查找！\n"

#: bisect.c
#, c-format
msgid "Not a valid commit name %s"
msgstr "不是一个有效的提交名 %s"

#: bisect.c
#, c-format
msgid ""
"The merge base %s is bad.\n"
"This means the bug has been fixed between %s and [%s].\n"
msgstr ""
"合并基线 %s 是坏的。\n"
"这意味着介于 %s 和 [%s] 之间的 bug 已经被修复。\n"

#: bisect.c
#, c-format
msgid ""
"The merge base %s is new.\n"
"The property has changed between %s and [%s].\n"
msgstr ""
"合并基线 %s 是新的。\n"
"介于 %s 和 [%s] 之间的属性已经被修改。\n"

#: bisect.c
#, c-format
msgid ""
"The merge base %s is %s.\n"
"This means the first '%s' commit is between %s and [%s].\n"
msgstr ""
"合并基线 %s 是 %s。\n"
"这意味着第一个 '%s' 提交位于 %s 和 [%s] 之间。\n"

#: bisect.c
#, c-format
msgid ""
"Some %s revs are not ancestors of the %s rev.\n"
"git bisect cannot work properly in this case.\n"
"Maybe you mistook %s and %s revs?\n"
msgstr ""
"一些 %s 版本不是 %s 版本的祖先。\n"
"这种情况下 git 二分查找无法正常工作。\n"
"您可能弄错了 %s 和 %s 版本？\n"

#: bisect.c
#, c-format
msgid ""
"the merge base between %s and [%s] must be skipped.\n"
"So we cannot be sure the first %s commit is between %s and %s.\n"
"We continue anyway."
msgstr ""
"介于 %s 和 [%s] 的合并基线一定被忽略了。\n"
"所以我们无法确认第一个 %s 提交是否介于 %s 和 %s 之间。\n"
"我们仍旧继续。"

#: bisect.c
#, c-format
msgid "Bisecting: a merge base must be tested\n"
msgstr "二分查找中：合并基线必须是经过测试的\n"

#: bisect.c
#, c-format
msgid "a %s revision is needed"
msgstr "需要一个 %s 版本"

#: bisect.c
#, c-format
msgid "could not create file '%s'"
msgstr "不能创建文件 '%s'"

#: bisect.c builtin/notes.c
#, c-format
msgid "unable to start 'show' for object '%s'"
msgstr "不能为对象 '%s' 开始 'show'"

#: bisect.c builtin/merge.c
#, c-format
msgid "could not read file '%s'"
msgstr "不能读取文件 '%s'"

#: bisect.c
msgid "reading bisect refs failed"
msgstr "读取二分查找引用失败"

#: bisect.c
#, c-format
msgid "%s was both %s and %s\n"
msgstr "%s 同时为 %s 和 %s\n"

#: bisect.c
#, c-format
msgid ""
"No testable commit found.\n"
"Maybe you started with bad path arguments?\n"
msgstr ""
"没有发现可测试的提交。\n"
"可能您在运行时使用了错误的路径参数？\n"

#: bisect.c
#, c-format
msgid "(roughly %d step)"
msgid_plural "(roughly %d steps)"
msgstr[0] "（大概 %d 步）"
msgstr[1] "（大概 %d 步）"

#. TRANSLATORS: the last %s will be replaced with "(roughly %d
#. steps)" translation.
#.
#: bisect.c
#, c-format
msgid "Bisecting: %d revision left to test after this %s\n"
msgid_plural "Bisecting: %d revisions left to test after this %s\n"
msgstr[0] "二分查找中：在此之后，还剩 %d 个版本待测试 %s\n"
msgstr[1] "二分查找中：在此之后，还剩 %d 个版本待测试 %s\n"

#: blame.c
msgid "--contents and --reverse do not blend well."
msgstr "--contents 和 --reverse 不能混用。"

#: blame.c
msgid "--reverse and --first-parent together require specified latest commit"
msgstr "--reverse 和 --first-parent 共用，需要指定最新的提交"

#: blame.c builtin/bisect.c builtin/commit.c builtin/log.c builtin/merge.c
#: builtin/pack-objects.c builtin/shortlog.c midx-write.c pack-bitmap.c
#: remote.c sequencer.c submodule.c
msgid "revision walk setup failed"
msgstr "版本遍历初始化失败"

#: blame.c
msgid ""
"--reverse --first-parent together require range along first-parent chain"
msgstr "--reverse 和 --first-parent 共用，需要第一祖先链上的提交范围"

#: blame.c
#, c-format
msgid "no such path %s in %s"
msgstr "在 %2$s 中无此路径 %1$s"

#: blame.c
#, c-format
msgid "cannot read blob %s for path %s"
msgstr "不能为路径 %2$s 读取数据对象 %1$s"

#: branch.c
msgid ""
"cannot inherit upstream tracking configuration of multiple refs when "
"rebasing is requested"
msgstr "在请求变基时无法继承上游多个引用的跟踪设置"

#: branch.c
#, c-format
msgid "not setting branch '%s' as its own upstream"
msgstr "没有将分支 '%s' 设置为它自己的上游"

#: branch.c
#, c-format
msgid "branch '%s' set up to track '%s' by rebasing."
msgstr "分支 '%s' 设置为使用变基来跟踪 '%s'。"

#: branch.c
#, c-format
msgid "branch '%s' set up to track '%s'."
msgstr "分支 '%s' 设置为跟踪 '%s'。"

#: branch.c
#, c-format
msgid "branch '%s' set up to track:"
msgstr "分支 '%s' 设置为跟踪："

#: branch.c
msgid "unable to write upstream branch configuration"
msgstr "无法写入上游分支配置"

#: branch.c
msgid ""
"\n"
"After fixing the error cause you may try to fix up\n"
"the remote tracking information by invoking:"
msgstr ""
"\n"
"在修复错误后，您可以通过执行以下命令来尝试修改远程跟踪分支："

#: branch.c
#, c-format
msgid "asked to inherit tracking from '%s', but no remote is set"
msgstr "要求从 '%s' 继承跟踪信息，但是没有设置远程"

#: branch.c
#, c-format
msgid "asked to inherit tracking from '%s', but no merge configuration is set"
msgstr "要求从 '%s' 继承跟踪信息，但是没有设置合并配置"

#: branch.c
#, c-format
msgid "not tracking: ambiguous information for ref '%s'"
msgstr "不在跟踪中：引用 '%s' 有歧义的信息"

#  译者：为保证在输出中对齐，注意调整句中空格！
#. #-#-#-#-#  branch.c.po  #-#-#-#-#
#. TRANSLATORS: This is a line listing a remote with duplicate
#. refspecs in the advice message below. For RTL languages you'll
#. probably want to swap the "%s" and leading "  " space around.
#.
#. #-#-#-#-#  object-name.c.po  #-#-#-#-#
#. TRANSLATORS: This is line item of ambiguous object output
#. from describe_ambiguous_object() above. For RTL languages
#. you'll probably want to swap the "%s" and leading " " space
#. around.
#.
#: branch.c object-name.c
#, c-format
msgid "  %s\n"
msgstr "  %s\n"

#. TRANSLATORS: The second argument is a \n-delimited list of
#. duplicate refspecs, composed above.
#.
#: branch.c
#, c-format
msgid ""
"There are multiple remotes whose fetch refspecs map to the remote\n"
"tracking ref '%s':\n"
"%s\n"
"This is typically a configuration error.\n"
"\n"
"To support setting up tracking branches, ensure that\n"
"different remotes' fetch refspecs map into different\n"
"tracking namespaces."
msgstr ""
"有多个远程的获取引用规格映射到了追踪引用 '%s'：\n"
"%s\n"
"这一般是个配置错误。\n"
"\n"
"如果要支持设置追踪分支，请保证不同远程的获取引用规格映射至不同的追踪命名空"
"间。"

#: branch.c
#, c-format
msgid "'%s' is not a valid branch name"
msgstr "'%s' 不是一个有效的分支名称"

#: branch.c builtin/branch.c
msgid "See `man git check-ref-format`"
msgstr "查阅 `man git check-ref-format`"

#: branch.c
#, c-format
msgid "a branch named '%s' already exists"
msgstr "一个名为 '%s' 的分支已经存在"

#: branch.c
#, c-format
msgid "cannot force update the branch '%s' used by worktree at '%s'"
msgstr "无法强制更新被工作区 '%2$s' 所使用的分支 '%1$s'"

#: branch.c
#, c-format
msgid "cannot set up tracking information; starting point '%s' is not a branch"
msgstr "无法设置跟踪信息；起始点 '%s' 不是一个分支"

#: branch.c
#, c-format
msgid "the requested upstream branch '%s' does not exist"
msgstr "请求的上游分支 '%s' 不存在"

#: branch.c
msgid ""
"\n"
"If you are planning on basing your work on an upstream\n"
"branch that already exists at the remote, you may need to\n"
"run \"git fetch\" to retrieve it.\n"
"\n"
"If you are planning to push out a new local branch that\n"
"will track its remote counterpart, you may want to use\n"
"\"git push -u\" to set the upstream config as you push."
msgstr ""
"\n"
"如果您正计划基于远程一个现存的上游分支开始您的工作，\n"
"您可能需要执行 \"git fetch\" 来获取分支。\n"
"\n"
"如果您正计划推送一个能与对应远程分支建立跟踪的新的本地分支，\n"
"您可能需要使用 \"git push -u\" 推送分支并配置和上游的关联。"

#: branch.c builtin/replace.c
#, c-format
msgid "not a valid object name: '%s'"
msgstr "不是一个有效的对象名：'%s'"

#: branch.c
#, c-format
msgid "ambiguous object name: '%s'"
msgstr "歧义的对象名：'%s'"

#: branch.c
#, c-format
msgid "not a valid branch point: '%s'"
msgstr "无效的分支点：'%s'"

#: branch.c
#, c-format
msgid "submodule '%s': unable to find submodule"
msgstr "子模组 '%s'：无法找到子模组"

#: branch.c
#, c-format
msgid ""
"You may try updating the submodules using 'git checkout --no-recurse-"
"submodules %s && git submodule update --init'"
msgstr ""
"你可以用 'git checkout --no-recurse-submodules %s && git submodule update --"
"init' 来尝试更新子模组"

#: branch.c
#, c-format
msgid "submodule '%s': cannot create branch '%s'"
msgstr "子模组 '%s'：不能创建分支 '%s'"

#: branch.c
#, c-format
msgid "'%s' is already used by worktree at '%s'"
msgstr "'%s' 已经被工作区 '%s' 使用"

#: builtin/add.c
msgid "git add [<options>] [--] <pathspec>..."
msgstr "git add [<选项>] [--] <路径规格>..."

#: builtin/add.c
#, c-format
msgid "cannot chmod %cx '%s'"
msgstr "不能 chmod %cx '%s'"

#: builtin/add.c
msgid "Unstaged changes after refreshing the index:"
msgstr "刷新索引之后尚未被暂存的变更："

#: builtin/add.c
msgid "could not read the index"
msgstr "不能读取索引"

#: builtin/add.c
msgid "editing patch failed"
msgstr "编辑补丁失败"

#: builtin/add.c read-cache.c
#, c-format
msgid "could not stat '%s'"
msgstr "不能对 '%s' 调用 stat"

#: builtin/add.c
msgid "empty patch. aborted"
msgstr "空补丁。异常终止"

#: builtin/add.c
#, c-format
msgid "could not apply '%s'"
msgstr "不能应用 '%s'"

#: builtin/add.c
msgid "The following paths are ignored by one of your .gitignore files:\n"
msgstr "下列路径根据您的一个 .gitignore 文件而被忽略：\n"

#: builtin/add.c builtin/clean.c builtin/fetch.c builtin/mv.c
#: builtin/prune-packed.c builtin/pull.c builtin/push.c builtin/remote.c
#: builtin/rm.c builtin/send-pack.c
msgid "dry run"
msgstr "演习"

#: builtin/add.c builtin/check-ignore.c builtin/commit.c
#: builtin/count-objects.c builtin/fsck.c builtin/log.c builtin/mv.c
#: builtin/read-tree.c builtin/refs.c
msgid "be verbose"
msgstr "冗长输出"

#: builtin/add.c
msgid "interactive picking"
msgstr "交互式拣选"

#: builtin/add.c builtin/checkout.c builtin/reset.c
msgid "select hunks interactively"
msgstr "交互式挑选数据块"

#: builtin/add.c
msgid "edit current diff and apply"
msgstr "编辑当前差异并应用"

#: builtin/add.c
msgid "allow adding otherwise ignored files"
msgstr "允许添加忽略的文件"

#: builtin/add.c
msgid "update tracked files"
msgstr "更新已跟踪的文件"

#: builtin/add.c
msgid "renormalize EOL of tracked files (implies -u)"
msgstr "对已跟踪文件（暗含 -u）重新归一换行符"

#: builtin/add.c
msgid "record only the fact that the path will be added later"
msgstr "只记录，该路径稍后再添加"

#: builtin/add.c
msgid "add changes from all tracked and untracked files"
msgstr "添加所有改变的已跟踪文件和未跟踪文件"

#: builtin/add.c
msgid "ignore paths removed in the working tree (same as --no-all)"
msgstr "忽略工作区中移除的路径（和 --no-all 相同）"

#: builtin/add.c
msgid "don't add, only refresh the index"
msgstr "不添加，只刷新索引"

#: builtin/add.c
msgid "just skip files which cannot be added because of errors"
msgstr "跳过因出错不能添加的文件"

#: builtin/add.c
msgid "check if - even missing - files are ignored in dry run"
msgstr "检查在演习模式下文件（即使不存在）是否被忽略"

#: builtin/add.c builtin/mv.c builtin/rm.c
msgid "allow updating entries outside of the sparse-checkout cone"
msgstr "允许更新稀疏检出锥以外的条目"

#: builtin/add.c builtin/update-index.c
msgid "override the executable bit of the listed files"
msgstr "覆盖列表里文件的可执行位"

#: builtin/add.c
msgid "warn when adding an embedded repository"
msgstr "创建一个嵌入式仓库时给予警告"

#: builtin/add.c
#, c-format
msgid ""
"You've added another git repository inside your current repository.\n"
"Clones of the outer repository will not contain the contents of\n"
"the embedded repository and will not know how to obtain it.\n"
"If you meant to add a submodule, use:\n"
"\n"
"\tgit submodule add <url> %s\n"
"\n"
"If you added this path by mistake, you can remove it from the\n"
"index with:\n"
"\n"
"\tgit rm --cached %s\n"
"\n"
"See \"git help submodule\" for more information."
msgstr ""
"您在当前仓库中添加了另一个Git仓库。克隆外层的仓库将不包含嵌入仓库的\n"
"内容，并且不知道该如何获取它。如果您要添加一个子模组，使用：\n"
"\n"
"\tgit submodule add <url> %s\n"
"\n"
"如果您不小心添加了这个路径，可以用下面的命令将其从索引中删除：\n"
"\n"
"\tgit rm --cached %s\n"
"\n"
"参见 \"git help submodule\" 获取更多信息。"

#: builtin/add.c
#, c-format
msgid "adding embedded git repository: %s"
msgstr "正在添加嵌入式 git 仓库：%s"

#: builtin/add.c
msgid "Use -f if you really want to add them."
msgstr "如果您确实想添加它们，请使用 -f 选项。"

#: builtin/add.c
msgid "adding files failed"
msgstr "添加文件失败"

#: builtin/add.c
#, c-format
msgid "--chmod param '%s' must be either -x or +x"
msgstr "参数 --chmod 取值 '%s' 必须是 -x 或 +x"

#: builtin/add.c builtin/checkout.c builtin/commit.c builtin/reset.c
#: builtin/rm.c builtin/stash.c
#, c-format
msgid "'%s' and pathspec arguments cannot be used together"
msgstr "'%s' 和路径规格参数不能同时使用"

#: builtin/add.c
#, c-format
msgid "Nothing specified, nothing added.\n"
msgstr "没有指定文件，也没有文件被添加。\n"

#: builtin/add.c
msgid "Maybe you wanted to say 'git add .'?"
msgstr "也许您想要执行 'git add .'？"

#: builtin/add.c builtin/check-ignore.c builtin/checkout.c builtin/clean.c
#: builtin/commit.c builtin/diff-tree.c builtin/grep.c builtin/mv.c
#: builtin/reset.c builtin/rm.c builtin/submodule--helper.c read-cache.c
#: rerere.c submodule.c
msgid "index file corrupt"
msgstr "索引文件损坏"

#: builtin/add.c builtin/am.c builtin/checkout.c builtin/clone.c
#: builtin/commit.c builtin/stash.c merge.c rerere.c
msgid "unable to write new index file"
msgstr "无法写新的索引文件"

#: builtin/am.c builtin/mailinfo.c mailinfo.c
#, c-format
msgid "bad action '%s' for '%s'"
msgstr "'%2$s' 的错误动作 '%1$s'"

#: builtin/am.c builtin/blame.c builtin/fetch.c builtin/pack-objects.c
#: builtin/pull.c builtin/revert.c config.c diff-merges.c gpg-interface.c
#: ls-refs.c parallel-checkout.c sequencer.c setup.c
#, c-format
msgid "invalid value for '%s': '%s'"
msgstr "'%s' 的值无效：'%s'"

#: builtin/am.c builtin/commit.c builtin/merge.c sequencer.c
#, c-format
msgid "could not read '%s'"
msgstr "不能读取 '%s'"

#: builtin/am.c
msgid "could not parse author script"
msgstr "不能解析作者脚本"

#: builtin/am.c builtin/replace.c commit.c sequencer.c
#, c-format
msgid "could not parse %s"
msgstr "不能解析 %s"

#: builtin/am.c
#, c-format
msgid "'%s' was deleted by the applypatch-msg hook"
msgstr "'%s' 被 applypatch-msg 钩子删除"

#: builtin/am.c
#, c-format
msgid "Malformed input line: '%s'."
msgstr "非法的输入行：'%s'。"

#: builtin/am.c
#, c-format
msgid "Failed to copy notes from '%s' to '%s'"
msgstr "从 '%s' 拷贝注解到 '%s' 时失败"

#: builtin/am.c
msgid "fseek failed"
msgstr "fseek 失败"

#: builtin/am.c builtin/rebase.c sequencer.c wrapper.c
#, c-format
msgid "could not open '%s' for reading"
msgstr "无法打开 '%s' 进行读取"

#: builtin/am.c builtin/rebase.c editor.c sequencer.c wrapper.c
#, c-format
msgid "could not open '%s' for writing"
msgstr "无法打开 '%s' 进行写入"

#: builtin/am.c
#, c-format
msgid "could not parse patch '%s'"
msgstr "无法解析补丁 '%s'"

#: builtin/am.c
msgid "Only one StGIT patch series can be applied at once"
msgstr "一次只能有一个 StGIT 补丁队列被应用"

#: builtin/am.c
msgid "invalid timestamp"
msgstr "无效的时间戳"

#: builtin/am.c
msgid "invalid Date line"
msgstr "无效的日期行"

#: builtin/am.c
msgid "invalid timezone offset"
msgstr "无效的时区偏移值"

#: builtin/am.c
msgid "Patch format detection failed."
msgstr "补丁格式探测失败。"

#: builtin/am.c builtin/clone.c
#, c-format
msgid "failed to create directory '%s'"
msgstr "无法创建目录 '%s'"

#: builtin/am.c
msgid "Failed to split patches."
msgstr "无法拆分补丁。"

#: builtin/am.c
#, c-format
msgid "When you have resolved this problem, run \"%s --continue\".\n"
msgstr "当您解决这一问题之后，执行 \"%s --continue\"。\n"

#: builtin/am.c
#, c-format
msgid "If you prefer to skip this patch, run \"%s --skip\" instead.\n"
msgstr "如果您想要跳过这一补丁，则执行 \"%s --skip\"。\n"

#: builtin/am.c
#, c-format
msgid ""
"To record the empty patch as an empty commit, run \"%s --allow-empty\".\n"
msgstr "若要把空补丁记录为空提交，执行 \"%s --allow-empty\"。\n"

#: builtin/am.c
#, c-format
msgid "To restore the original branch and stop patching, run \"%s --abort\"."
msgstr "若要复原至原始分支并停止补丁操作，执行 \"%s --abort\"。"

#: builtin/am.c
msgid "Patch sent with format=flowed; space at the end of lines might be lost."
msgstr "补丁使用 format=flowed 格式发送，行尾的空格可能会丢失。"

#: builtin/am.c
#, c-format
msgid "missing author line in commit %s"
msgstr "在提交 %s 中缺失作者行"

#: builtin/am.c
#, c-format
msgid "invalid ident line: %.*s"
msgstr "无效的身份标识：%.*s"

#: builtin/am.c builtin/checkout.c builtin/clone.c commit-graph.c
#, c-format
msgid "unable to parse commit %s"
msgstr "不能解析提交 %s"

#: builtin/am.c
msgid "Repository lacks necessary blobs to fall back on 3-way merge."
msgstr "仓库缺乏必要的数据对象以进行三方合并。"

#: builtin/am.c
msgid "Using index info to reconstruct a base tree..."
msgstr "使用索引来重建一个（三方合并的）基础目录树..."

#: builtin/am.c
msgid ""
"Did you hand edit your patch?\n"
"It does not apply to blobs recorded in its index."
msgstr ""
"您是否曾手动编辑过您的补丁？\n"
"无法应用补丁到索引中的数据对象上。"

#: builtin/am.c
msgid "Falling back to patching base and 3-way merge..."
msgstr "回落到基础版本上打补丁及进行三方合并..."

#: builtin/am.c
msgid "Failed to merge in the changes."
msgstr "无法合并变更。"

#: builtin/am.c builtin/merge.c sequencer.c
msgid "git write-tree failed to write a tree"
msgstr "git write-tree 无法写入树对象"

#: builtin/am.c
msgid "applying to an empty history"
msgstr "正应用到一个空历史上"

#: builtin/am.c builtin/commit.c builtin/merge.c builtin/replay.c sequencer.c
msgid "failed to write commit object"
msgstr "无法写提交对象"

#: builtin/am.c
#, c-format
msgid "cannot resume: %s does not exist."
msgstr "无法继续：%s 不存在。"

#: builtin/am.c
msgid "Commit Body is:"
msgstr "提交内容为："

#. TRANSLATORS: Make sure to include [y], [n], [e], [v] and [a]
#. in your translation. The program will only accept English
#. input at this point.
#.
#: builtin/am.c
#, c-format
msgid "Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all: "
msgstr "应用？是[y]/否[n]/编辑[e]/查看补丁[v]/应用所有[a]："

#: builtin/am.c builtin/commit.c
msgid "unable to write index file"
msgstr "无法写入索引文件"

#: builtin/am.c
#, c-format
msgid "Dirty index: cannot apply patches (dirty: %s)"
msgstr "脏索引：不能应用补丁（脏文件：%s）"

#: builtin/am.c
#, c-format
msgid "Skipping: %.*s"
msgstr "跳过：%.*s"

#: builtin/am.c
#, c-format
msgid "Creating an empty commit: %.*s"
msgstr "创建空提交：%.*s"

#: builtin/am.c
msgid "Patch is empty."
msgstr "补丁为空。"

#: builtin/am.c
#, c-format
msgid "Applying: %.*s"
msgstr "应用：%.*s"

#: builtin/am.c
msgid "No changes -- Patch already applied."
msgstr "没有变更 —— 补丁已经应用过。"

#: builtin/am.c
#, c-format
msgid "Patch failed at %s %.*s"
msgstr "打补丁失败于 %s %.*s"

#: builtin/am.c
msgid "Use 'git am --show-current-patch=diff' to see the failed patch"
msgstr "用 'git am --show-current-patch=diff' 命令查看失败的补丁"

#: builtin/am.c
msgid "No changes - recorded it as an empty commit."
msgstr "没有变更 —— 记录为空提交。"

#: builtin/am.c
msgid ""
"No changes - did you forget to use 'git add'?\n"
"If there is nothing left to stage, chances are that something else\n"
"already introduced the same changes; you might want to skip this patch."
msgstr ""
"没有变更 —— 您是不是忘了执行 'git add'？\n"
"如果没有什么要添加到暂存区的，则很可能是其它提交已经引入了相同的变更。\n"
"您也许想要跳过这个补丁。"

#: builtin/am.c
msgid ""
"You still have unmerged paths in your index.\n"
"You should 'git add' each file with resolved conflicts to mark them as "
"such.\n"
"You might run `git rm` on a file to accept \"deleted by them\" for it."
msgstr ""
"在您的索引中仍存在未合并的路径。\n"
"您应该对已经冲突解决的每一个文件执行 'git add' 来标记已经完成。 \n"
"您可以对 \"由他们删除\" 的文件执行 `git rm` 命令。"

#: builtin/am.c builtin/reset.c
#, c-format
msgid "Could not parse object '%s'."
msgstr "不能解析对象 '%s'。"

#: builtin/am.c
msgid "failed to clean index"
msgstr "无法清空索引"

#: builtin/am.c
msgid ""
"You seem to have moved HEAD since the last 'am' failure.\n"
"Not rewinding to ORIG_HEAD"
msgstr "您好像在上一次 'am' 失败后移动了 HEAD。未回退至 ORIG_HEAD"

#: builtin/am.c builtin/bisect.c builtin/tag.c worktree.c
#, c-format
msgid "failed to read '%s'"
msgstr "无法读取 '%s'"

#: builtin/am.c
msgid "git am [<options>] [(<mbox> | <Maildir>)...]"
msgstr "git am [<选项>] [(<mbox> | <Maildir>)...]"

#: builtin/am.c
msgid "git am [<options>] (--continue | --skip | --abort)"
msgstr "git am [<选项>] (--continue | --skip | --abort)"

#: builtin/am.c
msgid "run interactively"
msgstr "以交互式方式运行"

#: builtin/am.c
msgid "bypass pre-applypatch and applypatch-msg hooks"
msgstr "绕过 pre-applypatch 和 applypatch-msg 钩子"

#: builtin/am.c
msgid "historical option -- no-op"
msgstr "老的参数 —— 无作用"

#: builtin/am.c
msgid "allow fall back on 3way merging if needed"
msgstr "如果必要，允许使用三方合并。"

#: builtin/am.c builtin/init-db.c builtin/prune-packed.c builtin/repack.c
#: builtin/stash.c
msgid "be quiet"
msgstr "静默模式"

#: builtin/am.c
msgid "add a Signed-off-by trailer to the commit message"
msgstr "在提交说明中添加 Signed-off-by 尾注"

#: builtin/am.c
msgid "recode into utf8 (default)"
msgstr "使用 utf8 字符集（默认）"

#: builtin/am.c
msgid "pass -k flag to git-mailinfo"
msgstr "向 git-mailinfo 传递 -k 参数"

#: builtin/am.c
msgid "pass -b flag to git-mailinfo"
msgstr "向 git-mailinfo 传递 -b 参数"

#: builtin/am.c
msgid "pass -m flag to git-mailinfo"
msgstr "向 git-mailinfo 传递 -m 参数"

#: builtin/am.c
msgid "pass --keep-cr flag to git-mailsplit for mbox format"
msgstr "针对 mbox 格式，向 git-mailsplit 传递 --keep-cr 参数"

#: builtin/am.c
msgid "strip everything before a scissors line"
msgstr "丢弃裁切线前的所有内容"

#: builtin/am.c
msgid "pass it through git-mailinfo"
msgstr "传递给 git-mailinfo"

#: builtin/am.c
msgid "pass it through git-apply"
msgstr "传递给 git-apply"

#: builtin/am.c builtin/commit.c builtin/fmt-merge-msg.c builtin/grep.c
#: builtin/merge.c builtin/pull.c builtin/rebase.c builtin/repack.c
#: builtin/show-branch.c builtin/show-ref.c builtin/tag.c parse-options.h
msgid "n"
msgstr "n"

#: builtin/am.c builtin/branch.c builtin/bugreport.c builtin/cat-file.c
#: builtin/clone.c builtin/diagnose.c builtin/for-each-ref.c builtin/init-db.c
#: builtin/ls-files.c builtin/ls-tree.c builtin/refs.c builtin/replace.c
#: builtin/submodule--helper.c builtin/tag.c builtin/verify-tag.c
msgid "format"
msgstr "格式"

#: builtin/am.c
msgid "format the patch(es) are in"
msgstr "补丁的格式"

#: builtin/am.c
msgid "override error message when patch failure occurs"
msgstr "打补丁失败时显示的错误信息"

#: builtin/am.c
msgid "continue applying patches after resolving a conflict"
msgstr "冲突解决后继续应用补丁"

#: builtin/am.c
msgid "synonyms for --continue"
msgstr "和 --continue 同义"

#: builtin/am.c
msgid "skip the current patch"
msgstr "跳过当前补丁"

#: builtin/am.c
msgid "restore the original branch and abort the patching operation"
msgstr "恢复原始分支并终止打补丁操作"

#: builtin/am.c
msgid "abort the patching operation but keep HEAD where it is"
msgstr "终止补丁操作但保持 HEAD 不变"

#: builtin/am.c
msgid "show the patch being applied"
msgstr "显示正在应用的补丁"

#: builtin/am.c
msgid "try to apply current patch again"
msgstr "尝试再次应用当前补丁"

#: builtin/am.c
msgid "record the empty patch as an empty commit"
msgstr "把空补丁记录为空提交"

#: builtin/am.c
msgid "lie about committer date"
msgstr "将作者日期作为提交日期"

#: builtin/am.c
msgid "use current timestamp for author date"
msgstr "用当前时间作为作者日期"

#: builtin/am.c builtin/commit-tree.c builtin/commit.c builtin/merge.c
#: builtin/pull.c builtin/rebase.c builtin/revert.c builtin/tag.c
msgid "key-id"
msgstr "key-id"

#: builtin/am.c builtin/rebase.c
msgid "GPG-sign commits"
msgstr "使用 GPG 签名提交"

#: builtin/am.c
msgid "how to handle empty patches"
msgstr "如何处理空补丁"

#: builtin/am.c
msgid "(internal use for git-rebase)"
msgstr "（内部使用，用于 git-rebase）"

#: builtin/am.c
msgid ""
"The -b/--binary option has been a no-op for long time, and\n"
"it will be removed. Please do not use it anymore."
msgstr ""
"参数 -b/--binary 已经很长时间不做任何实质操作了，并且将被移除。\n"
"请不要再使用它了。"

#: builtin/am.c
msgid "failed to read the index"
msgstr "无法读取索引"

#: builtin/am.c
#, c-format
msgid "previous rebase directory %s still exists but mbox given."
msgstr "之前的变基目录 %s 仍然存在，但却提供了 mbox。"

#: builtin/am.c
#, c-format
msgid ""
"Stray %s directory found.\n"
"Use \"git am --abort\" to remove it."
msgstr ""
"发现了错误的 %s 目录。\n"
"使用 \"git am --abort\" 删除它。"

#: builtin/am.c
msgid "Resolve operation not in progress, we are not resuming."
msgstr "解决操作未进行，我们不会继续。"

#: builtin/am.c
msgid "interactive mode requires patches on the command line"
msgstr "交互式模式需要命令行上提供补丁"

#: builtin/apply.c
msgid "git apply [<options>] [<patch>...]"
msgstr "git apply [<选项>] [<补丁>...]"

#: builtin/archive.c diagnose.c
msgid "could not redirect output"
msgstr "不能重定向输出"

#: builtin/archive.c
msgid "git archive: expected ACK/NAK, got a flush packet"
msgstr "git archive：期望是 ACK/NAK，却得到 flush 包"

#: builtin/archive.c
#, c-format
msgid "git archive: NACK %s"
msgstr "git archive：NACK %s"

#: builtin/archive.c
msgid "git archive: protocol error"
msgstr "git archive：协议错误"

#: builtin/archive.c
msgid "git archive: expected a flush"
msgstr "git archive：应有一个 flush 包"

#: builtin/backfill.c
msgid "git backfill [--min-batch-size=<n>] [--[no-]sparse]"
msgstr "git backfill [--min-batch-size=<n>] [--[no-]sparse]"

#: builtin/backfill.c
msgid "problem loading sparse-checkout"
msgstr "加载稀疏检出时出现问题"

#: builtin/backfill.c
msgid "Minimum number of objects to request at a time"
msgstr "单次请求的最少对象数量"

#: builtin/backfill.c
msgid "Restrict the missing objects to the current sparse-checkout"
msgstr "将缺少的对象限制在当前的稀疏检出中"

#: builtin/bisect.c
msgid ""
"git bisect start [--term-(new|bad)=<term> --term-(old|good)=<term>]    [--no-"
"checkout] [--first-parent] [<bad> [<good>...]] [--]    [<pathspec>...]"
msgstr ""
"git bisect start [--term-{new|bad}=<术语> --term-{old|good}=<术语>]    [--no-"
"checkout] [--first-parent] [<坏> [<好>...]] [--]    [<路径规格>...]"

#: builtin/bisect.c
msgid "git bisect (good|bad) [<rev>...]"
msgstr "git bisect (good|bad) [<版本>...]"

#: builtin/bisect.c
msgid "git bisect skip [(<rev>|<range>)...]"
msgstr "git bisect skip [(<版本>|<范围>)...]"

#: builtin/bisect.c
msgid "git bisect reset [<commit>]"
msgstr "git bisect reset [<提交>]"

#: builtin/bisect.c
msgid "git bisect replay <logfile>"
msgstr "git bisect replay <日志文件>"

#: builtin/bisect.c
msgid "git bisect run <cmd> [<arg>...]"
msgstr "git bisect run <命令> [<参数>...]"

#: builtin/bisect.c
#, c-format
msgid "cannot open file '%s' in mode '%s'"
msgstr "不能以 '%2$s' 模式打开文件 '%1$s'"

#: builtin/bisect.c
#, c-format
msgid "could not write to file '%s'"
msgstr "不能写入文件 '%s'"

#: builtin/bisect.c
#, c-format
msgid "cannot open file '%s' for reading"
msgstr "不能打开文件 '%s' 来读取"

#: builtin/bisect.c
#, c-format
msgid "'%s' is not a valid term"
msgstr "'%s' 不是一个有效的术语"

#: builtin/bisect.c
#, c-format
msgid "can't use the builtin command '%s' as a term"
msgstr "不能使用内置命令 '%s' 作为术语"

#: builtin/bisect.c
#, c-format
msgid "can't change the meaning of the term '%s'"
msgstr "不能修改术语 '%s' 的含义"

#: builtin/bisect.c
msgid "please use two different terms"
msgstr "请使用两个不同的术语"

#: builtin/bisect.c
#, c-format
msgid "We are not bisecting.\n"
msgstr "我们没有在二分查找。\n"

#: builtin/bisect.c
#, c-format
msgid "'%s' is not a valid commit"
msgstr "'%s' 不是一个有效的提交"

#: builtin/bisect.c
#, c-format
msgid ""
"could not check out original HEAD '%s'. Try 'git bisect reset <commit>'."
msgstr "不能检出原始 HEAD '%s'。尝试 'git bisect reset <提交>'。"

#: builtin/bisect.c
#, c-format
msgid "Bad bisect_write argument: %s"
msgstr "坏的 bisect_write 参数：%s"

#: builtin/bisect.c
#, c-format
msgid "couldn't get the oid of the rev '%s'"
msgstr "无法获取版本 '%s' 的对象 ID"

#: builtin/bisect.c
#, c-format
msgid "couldn't open the file '%s'"
msgstr "无法打开文件 '%s'"

#: builtin/bisect.c
#, c-format
msgid "Invalid command: you're currently in a %s/%s bisect"
msgstr "无效的命令：您当前正处于一个 %s/%s 二分查找中"

#: builtin/bisect.c
#, c-format
msgid ""
"You need to give me at least one %s and %s revision.\n"
"You can use \"git bisect %s\" and \"git bisect %s\" for that."
msgstr ""
"您需要给我至少一个 %s 和一个 %s 版本。\n"
"为此您可以用 \"git bisect %s\" 和 \"git bisect %s\"。"

#: builtin/bisect.c
#, c-format
msgid ""
"You need to start by \"git bisect start\".\n"
"You then need to give me at least one %s and %s revision.\n"
"You can use \"git bisect %s\" and \"git bisect %s\" for that."
msgstr ""
"您需要执行 \"git bisect start\" 来开始。\n"
"然后需要提供我至少一个 %s 和一个 %s 版本。\n"
"为此您可以用 \"git bisect %s\" 和 \"git bisect %s\" 命令。"

#: builtin/bisect.c
#, c-format
msgid "bisecting only with a %s commit"
msgstr "在只有一个 %s 提交的情况下二分查找"

#. TRANSLATORS: Make sure to include [Y] and [n] in your
#. translation. The program will only accept English input
#. at this point.
#.
#: builtin/bisect.c
msgid "Are you sure [Y/n]? "
msgstr "您确认么[Y/n]？ "

#: builtin/bisect.c
msgid "status: waiting for both good and bad commits\n"
msgstr "状态：正在等待好的和坏的提交\n"

#: builtin/bisect.c
#, c-format
msgid "status: waiting for bad commit, %d good commit known\n"
msgid_plural "status: waiting for bad commit, %d good commits known\n"
msgstr[0] "状态：正在等待坏的提交，已知 %d 个好的提交\n"
msgstr[1] "状态：正在等待坏的提交，已知 %d 个好的提交\n"

#: builtin/bisect.c
msgid "status: waiting for good commit(s), bad commit known\n"
msgstr "状态：正在等待好的提交，已知坏的提交\n"

#: builtin/bisect.c
msgid "no terms defined"
msgstr "未定义术语"

#: builtin/bisect.c
#, c-format
msgid ""
"Your current terms are %s for the old state\n"
"and %s for the new state.\n"
msgstr "您当前针对旧状态的术语是 %s，对新状态的术语是 %s。\n"

#: builtin/bisect.c
#, c-format
msgid ""
"invalid argument %s for 'git bisect terms'.\n"
"Supported options are: --term-good|--term-old and --term-bad|--term-new."
msgstr ""
"命令 'git bisect terms' 的参数 %s 无效。\n"
"支持的选项有：--term-good|--term-old 和 --term-bad|--term-new。"

#: builtin/bisect.c
#, c-format
msgid "could not open '%s' for appending"
msgstr "无法打开 '%s' 进行追加"

#: builtin/bisect.c
msgid "'' is not a valid term"
msgstr "'' 不是一个有效的术语"

#: builtin/bisect.c
#, c-format
msgid "unrecognized option: '%s'"
msgstr "未识别的选项：'%s'"

#: builtin/bisect.c
#, c-format
msgid "'%s' does not appear to be a valid revision"
msgstr "'%s' 看起来不是一个有效的版本"

#: builtin/bisect.c
msgid "bad HEAD - I need a HEAD"
msgstr "坏的 HEAD - 我需要一个 HEAD"

#: builtin/bisect.c
#, c-format
msgid "checking out '%s' failed. Try 'git bisect start <valid-branch>'."
msgstr "检出 '%s' 失败。尝试 'git bisect start <有效分支>'。"

#: builtin/bisect.c
msgid "bad HEAD - strange symbolic ref"
msgstr "坏的 HEAD - 奇怪的符号引用"

#: builtin/bisect.c
#, c-format
msgid "invalid ref: '%s'"
msgstr "无效的引用：'%s'"

#: builtin/bisect.c
msgid "You need to start by \"git bisect start\"\n"
msgstr "您需要执行 \"git bisect start\" 来开始\n"

#. TRANSLATORS: Make sure to include [Y] and [n] in your
#. translation. The program will only accept English input
#. at this point.
#.
#: builtin/bisect.c
msgid "Do you want me to do it for you [Y/n]? "
msgstr "您想让我为您这样做么[Y/n]？ "

#: builtin/bisect.c
msgid "Please call `--bisect-state` with at least one argument"
msgstr "请使用至少一个参数调用 `--bisect-state`"

#: builtin/bisect.c
#, c-format
msgid "'git bisect %s' can take only one argument."
msgstr "'git bisect %s' 只能带一个参数。"

#: builtin/bisect.c
#, c-format
msgid "Bad rev input: %s"
msgstr "坏的版本输入：%s"

#: builtin/bisect.c
#, c-format
msgid "Bad rev input (not a commit): %s"
msgstr "坏的版本输入（不是提交）：%s"

#: builtin/bisect.c
msgid "We are not bisecting."
msgstr "我们没有在二分查找。"

#: builtin/bisect.c
#, c-format
msgid "'%s'?? what are you talking about?"
msgstr "'%s'?? 您在说什么?"

#: builtin/bisect.c
#, c-format
msgid "cannot read file '%s' for replaying"
msgstr "不能读取文件 '%s' 来重放"

#: builtin/bisect.c
#, c-format
msgid "running %s\n"
msgstr "正在执行 %s\n"

#: builtin/bisect.c
msgid "bisect run failed: no command provided."
msgstr "二分查找运行失败：没有提供命令。"

#: builtin/bisect.c
#, c-format
msgid "unable to verify %s on good revision"
msgstr "无法在好版本中验证 %s"

#: builtin/bisect.c
#, c-format
msgid "bogus exit code %d for good revision"
msgstr "好版本返回错误的退出码 %d"

#: builtin/bisect.c
#, c-format
msgid "bisect run failed: exit code %d from %s is < 0 or >= 128"
msgstr "二分查找运行失败：命令 %2$s 的退出码 %1$d < 0 或 >= 128"

#: builtin/bisect.c
#, c-format
msgid "cannot open file '%s' for writing"
msgstr "无法打开文件 '%s' 进行写入"

#: builtin/bisect.c
msgid "bisect run cannot continue any more"
msgstr "二分查找不能继续运行"

#: builtin/bisect.c
msgid "bisect run success"
msgstr "二分查找运行成功"

#: builtin/bisect.c
msgid "bisect found first bad commit"
msgstr "二分查找找到了第一个坏的提交"

#: builtin/bisect.c
#, c-format
msgid "bisect run failed: 'git bisect %s' exited with error code %d"
msgstr "二分查找运行失败：'git bisect %s' 退出码为 %d"

#: builtin/bisect.c
#, c-format
msgid "'%s' requires either no argument or a commit"
msgstr "'%s' 无需参数或者需要一个提交"

#: builtin/bisect.c
#, c-format
msgid "'%s' requires 0 or 1 argument"
msgstr "'%s' 无需参数或者需要一个参数"

#: builtin/bisect.c
#, c-format
msgid "'%s' requires 0 arguments"
msgstr "'%s' 无需参数"

#: builtin/bisect.c
msgid "no logfile given"
msgstr "未提供日志文件"

#: builtin/bisect.c
#, c-format
msgid "'%s' failed: no command provided."
msgstr "'%s' 运行失败：没有提供命令。"

#: builtin/bisect.c
msgid "need a command"
msgstr "需要一个命令"

#: builtin/bisect.c builtin/cat-file.c
#, c-format
msgid "unknown command: '%s'"
msgstr "未知命令：'%s'"

#: builtin/blame.c
msgid "git blame [<options>] [<rev-opts>] [<rev>] [--] <file>"
msgstr "git blame [<选项>] [<版本选项>] [<版本>] [--] <文件>"

#: builtin/blame.c
msgid "git annotate [<options>] [<rev-opts>] [<rev>] [--] <file>"
msgstr "git annotate [<选项>] [<版本选项>] [<版本>] [--] <文件>"

#: builtin/blame.c
msgid "<rev-opts> are documented in git-rev-list(1)"
msgstr "<版本选项> 的文档记录在 git-rev-list(1) 中"

#: builtin/blame.c
#, c-format
msgid "expecting a color: %s"
msgstr "期望一个颜色：%s"

#: builtin/blame.c
msgid "must end with a color"
msgstr "必须以一个颜色结尾"

#: builtin/blame.c
#, c-format
msgid "cannot find revision %s to ignore"
msgstr "不能找到要忽略的版本 %s"

#: builtin/blame.c
msgid "show blame entries as we find them, incrementally"
msgstr "增量式地显示发现的 blame 条目"

#: builtin/blame.c
msgid "do not show object names of boundary commits (Default: off)"
msgstr "不显示边界提交的对象名（默认：关闭）"

#: builtin/blame.c
msgid "do not treat root commits as boundaries (Default: off)"
msgstr "不把根提交作为边界（默认：关闭）"

#: builtin/blame.c
msgid "show work cost statistics"
msgstr "显示工作消耗统计"

#: builtin/blame.c builtin/checkout.c builtin/clone.c builtin/commit-graph.c
#: builtin/fetch.c builtin/merge.c builtin/multi-pack-index.c builtin/pull.c
#: builtin/push.c builtin/remote.c builtin/send-pack.c
msgid "force progress reporting"
msgstr "强制显示进度报告"

#: builtin/blame.c
msgid "show output score for blame entries"
msgstr "显示 blame 条目的输出得分"

#: builtin/blame.c
msgid "show original filename (Default: auto)"
msgstr "显示原始文件名（默认：自动）"

#: builtin/blame.c
msgid "show original linenumber (Default: off)"
msgstr "显示原始的行号（默认：关闭）"

#: builtin/blame.c
msgid "show in a format designed for machine consumption"
msgstr "显示为一个适合机器读取的格式"

#: builtin/blame.c
msgid "show porcelain format with per-line commit information"
msgstr "为每一行显示机器适用的提交信息"

#: builtin/blame.c
msgid "use the same output mode as git-annotate (Default: off)"
msgstr "使用和 git-annotate 相同的输出模式（默认：关闭）"

#: builtin/blame.c
msgid "show raw timestamp (Default: off)"
msgstr "显示原始时间戳（默认：关闭）"

#: builtin/blame.c
msgid "show long commit SHA1 (Default: off)"
msgstr "显示长的 SHA1 提交号（默认：关闭）"

#: builtin/blame.c
msgid "suppress author name and timestamp (Default: off)"
msgstr "隐藏作者名字和时间戳（默认：关闭）"

#: builtin/blame.c
msgid "show author email instead of name (Default: off)"
msgstr "显示作者的邮箱而不是名字（默认：关闭）"

#: builtin/blame.c
msgid "ignore whitespace differences"
msgstr "忽略空白差异"

#: builtin/blame.c builtin/clone.c builtin/log.c
msgid "rev"
msgstr "版本"

#: builtin/blame.c
msgid "ignore <rev> when blaming"
msgstr "在执行 blame 操作时忽略 <版本>"

#: builtin/blame.c
msgid "ignore revisions from <file>"
msgstr "忽略来自 <文件> 中的版本"

#: builtin/blame.c
msgid "color redundant metadata from previous line differently"
msgstr "使用颜色间隔输出与前一行不同的重复元信息"

#: builtin/blame.c
msgid "color lines by age"
msgstr "依据时间着色"

#: builtin/blame.c
msgid "spend extra cycles to find better match"
msgstr "花费额外的循环来找到更好的匹配"

#: builtin/blame.c
msgid "use revisions from <file> instead of calling git-rev-list"
msgstr "使用来自 <文件> 的修订集而不是调用 git-rev-list"

#: builtin/blame.c
msgid "use <file>'s contents as the final image"
msgstr "使用 <文件> 的内容作为最终的镜像"

#: builtin/blame.c
msgid "score"
msgstr "得分"

#: builtin/blame.c
msgid "find line copies within and across files"
msgstr "找到文件内及跨文件的行拷贝"

#: builtin/blame.c
msgid "find line movements within and across files"
msgstr "找到文件内及跨文件的行移动"

#: builtin/blame.c
msgid "range"
msgstr "范围"

#: builtin/blame.c
msgid "process only line range <start>,<end> or function :<funcname>"
msgstr "只处理在 <开始>,<结束> 范围内的行，或者函数：<函数名>"

#: builtin/blame.c
msgid "--progress can't be used with --incremental or porcelain formats"
msgstr "--progress 不能和 --incremental 或机器内部格式一起使用"

#. TRANSLATORS: This string is used to tell us the
#. maximum display width for a relative timestamp in
#. "git blame" output.  For C locale, "4 years, 11
#. months ago", which takes 22 places, is the longest
#. among various forms of relative timestamps, but
#. your language may need more or fewer display
#. columns.
#.
#: builtin/blame.c
msgid "4 years, 11 months ago"
msgstr "4 年 11 个月前"

#: builtin/blame.c
#, c-format
msgid "file %s has only %lu line"
msgid_plural "file %s has only %lu lines"
msgstr[0] "文件 %s 只有 %lu 行"
msgstr[1] "文件 %s 只有 %lu 行"

#: builtin/blame.c
msgid "Blaming lines"
msgstr "追踪代码行"

#: builtin/branch.c
msgid "git branch [<options>] [-r | -a] [--merged] [--no-merged]"
msgstr "git branch [<选项>] [-r | -a] [--merged] [--no-merged]"

#: builtin/branch.c
msgid ""
"git branch [<options>] [-f] [--recurse-submodules] <branch-name> [<start-"
"point>]"
msgstr "git branch [<选项>] [-f] [--recurse-submodules] <分支名> [<起始点>]"

#: builtin/branch.c
msgid "git branch [<options>] [-l] [<pattern>...]"
msgstr "git branch [<选项>] [-l] [<模式>...]"

#: builtin/branch.c
msgid "git branch [<options>] [-r] (-d | -D) <branch-name>..."
msgstr "git branch [<选项>] [-r] (-d | -D) <分支名>..."

#: builtin/branch.c
msgid "git branch [<options>] (-m | -M) [<old-branch>] <new-branch>"
msgstr "git branch [<选项>] (-m | -M) [<旧分支>] <新分支>"

#: builtin/branch.c
msgid "git branch [<options>] (-c | -C) [<old-branch>] <new-branch>"
msgstr "git branch [<选项>] (-c | -C) [<老分支>] <新分支>"

#: builtin/branch.c
msgid "git branch [<options>] [-r | -a] [--points-at]"
msgstr "git branch [<选项>] [-r | -a] [--points-at]"

#: builtin/branch.c
msgid "git branch [<options>] [-r | -a] [--format]"
msgstr "git branch [<选项>] [-r | -a] [--format]"

#  译者：保持原换行格式，在输出时 %s 的替代内容会让字符串变长
#: builtin/branch.c
#, c-format
msgid ""
"deleting branch '%s' that has been merged to\n"
"         '%s', but not yet merged to HEAD"
msgstr ""
"将要删除的分支 '%s' 已经被合并到\n"
"         '%s'，但未合并到 HEAD"

#  译者：保持原换行格式，在输出时 %s 的替代内容会让字符串变长
#: builtin/branch.c
#, c-format
msgid ""
"not deleting branch '%s' that is not yet merged to\n"
"         '%s', even though it is merged to HEAD"
msgstr ""
"并未删除分支 '%s'，虽然它已经合并到 HEAD，\n"
"         然而却尚未被合并到分支 '%s'"

#: builtin/branch.c
#, c-format
msgid "couldn't look up commit object for '%s'"
msgstr "无法查询 '%s' 指向的提交对象"

#: builtin/branch.c
#, c-format
msgid "the branch '%s' is not fully merged"
msgstr "分支 '%s' 没有完全合并"

#: builtin/branch.c
#, c-format
msgid "If you are sure you want to delete it, run 'git branch -D %s'"
msgstr "如果您确认要删除它，执行 'git branch -D %s'"

#: builtin/branch.c
msgid "update of config-file failed"
msgstr "更新配置文件失败"

#: builtin/branch.c
msgid "cannot use -a with -d"
msgstr "不能将 -a 和 -d 同时使用"

#: builtin/branch.c
#, c-format
msgid "cannot delete branch '%s' used by worktree at '%s'"
msgstr "无法强制更新被工作区 '%2$s' 所使用的分支 '%1$s'"

#: builtin/branch.c
#, c-format
msgid "remote-tracking branch '%s' not found"
msgstr "未能找到远程跟踪分支 '%s'"

#: builtin/branch.c
#, c-format
msgid ""
"branch '%s' not found.\n"
"Did you forget --remote?"
msgstr ""
"分支 '%s' 未找到。\n"
"是否忘记指定 --remote 选项？"

#: builtin/branch.c
#, c-format
msgid "branch '%s' not found"
msgstr "分支 '%s' 未发现"

#: builtin/branch.c
#, c-format
msgid "Deleted remote-tracking branch %s (was %s).\n"
msgstr "已删除远程跟踪分支 %s（曾为 %s）。\n"

#: builtin/branch.c
#, c-format
msgid "Deleted branch %s (was %s).\n"
msgstr "已删除分支 %s（曾为 %s）。\n"

#: builtin/branch.c builtin/tag.c
msgid "unable to parse format string"
msgstr "不能解析格式化字符串"

#: builtin/branch.c
msgid "could not resolve HEAD"
msgstr "不能解析 HEAD 提交"

#: builtin/branch.c
#, c-format
msgid "HEAD (%s) points outside of refs/heads/"
msgstr "HEAD (%s) 指向 refs/heads/ 之外"

#: builtin/branch.c
#, c-format
msgid "branch %s is being rebased at %s"
msgstr "分支 %s 正被变基到 %s"

#: builtin/branch.c
#, c-format
msgid "branch %s is being bisected at %s"
msgstr "分支 %s 正被二分查找于 %s"

#: builtin/branch.c
#, c-format
msgid "HEAD of working tree %s is not updated"
msgstr "工作区 %s 的 HEAD 指向没有被更新"

#: builtin/branch.c
#, c-format
msgid "invalid branch name: '%s'"
msgstr "无效的分支名：'%s'"

#: builtin/branch.c
#, c-format
msgid "no commit on branch '%s' yet"
msgstr "分支 '%s' 尚无提交"

#: builtin/branch.c
#, c-format
msgid "no branch named '%s'"
msgstr "没有分支 '%s'"

#: builtin/branch.c
msgid "branch rename failed"
msgstr "分支重命名失败"

#: builtin/branch.c
msgid "branch copy failed"
msgstr "分支拷贝失败"

#: builtin/branch.c
#, c-format
msgid "created a copy of a misnamed branch '%s'"
msgstr "已为错误命名的分支 '%s' 创建了一个副本"

#: builtin/branch.c
#, c-format
msgid "renamed a misnamed branch '%s' away"
msgstr "已将错误命名的分支 '%s' 重命名"

#: builtin/branch.c
#, c-format
msgid "branch renamed to %s, but HEAD is not updated"
msgstr "分支重命名为 %s，但 HEAD 没有更新"

#: builtin/branch.c
msgid "branch is renamed, but update of config-file failed"
msgstr "分支被重命名，但更新配置文件失败"

#: builtin/branch.c
msgid "branch is copied, but update of config-file failed"
msgstr "分支已拷贝，但更新配置文件失败"

#: builtin/branch.c
#, c-format
msgid ""
"Please edit the description for the branch\n"
"  %s\n"
"Lines starting with '%s' will be stripped.\n"
msgstr ""
"请编辑分支的描述\n"
"  %s\n"
"以 '%s' 开头的行将被过滤。\n"

#: builtin/branch.c
msgid "Generic options"
msgstr "通用选项"

#: builtin/branch.c
msgid "show hash and subject, give twice for upstream branch"
msgstr "显示哈希值和主题，若参数出现两次则显示上游分支"

#: builtin/branch.c
msgid "suppress informational messages"
msgstr "不显示信息"

#: builtin/branch.c builtin/checkout.c builtin/submodule--helper.c
msgid "set branch tracking configuration"
msgstr "设置分支跟踪配置"

#: builtin/branch.c
msgid "do not use"
msgstr "不要使用"

#: builtin/branch.c
msgid "upstream"
msgstr "上游"

#: builtin/branch.c
msgid "change the upstream info"
msgstr "改变上游信息"

#: builtin/branch.c
msgid "unset the upstream info"
msgstr "取消上游信息的设置"

#: builtin/branch.c
msgid "use colored output"
msgstr "使用彩色输出"

#: builtin/branch.c
msgid "act on remote-tracking branches"
msgstr "作用于远程跟踪分支"

#: builtin/branch.c
msgid "print only branches that contain the commit"
msgstr "只打印包含该提交的分支"

#: builtin/branch.c
msgid "print only branches that don't contain the commit"
msgstr "只打印不包含该提交的分支"

#: builtin/branch.c
msgid "Specific git-branch actions:"
msgstr "具体的 git-branch 动作："

#: builtin/branch.c
msgid "list both remote-tracking and local branches"
msgstr "列出远程跟踪及本地分支"

#: builtin/branch.c
msgid "delete fully merged branch"
msgstr "删除完全合并的分支"

#: builtin/branch.c
msgid "delete branch (even if not merged)"
msgstr "删除分支（即使没有合并）"

#: builtin/branch.c
msgid "move/rename a branch and its reflog"
msgstr "移动/重命名一个分支，以及它的引用日志"

#: builtin/branch.c
msgid "move/rename a branch, even if target exists"
msgstr "移动/重命名一个分支，即使目标已存在"

#: builtin/branch.c builtin/for-each-ref.c builtin/tag.c
msgid "do not output a newline after empty formatted refs"
msgstr "在格式化引用结果为空之后，不输出换行符"

#: builtin/branch.c
msgid "copy a branch and its reflog"
msgstr "拷贝一个分支和它的引用日志"

#: builtin/branch.c
msgid "copy a branch, even if target exists"
msgstr "拷贝一个分支，即使目标已存在"

#: builtin/branch.c
msgid "list branch names"
msgstr "列出分支名"

#: builtin/branch.c
msgid "show current branch name"
msgstr "显示当前分支名"

#: builtin/branch.c builtin/submodule--helper.c
msgid "create the branch's reflog"
msgstr "创建分支的引用日志"

#: builtin/branch.c
msgid "edit the description for the branch"
msgstr "标记分支的描述"

#: builtin/branch.c
msgid "force creation, move/rename, deletion"
msgstr "强制创建、移动/重命名、删除"

#: builtin/branch.c
msgid "print only branches that are merged"
msgstr "只打印已经合并的分支"

#: builtin/branch.c
msgid "print only branches that are not merged"
msgstr "只打印尚未合并的分支"

#: builtin/branch.c
msgid "list branches in columns"
msgstr "以列的方式显示分支"

#: builtin/branch.c builtin/for-each-ref.c builtin/notes.c builtin/tag.c
msgid "object"
msgstr "对象"

#: builtin/branch.c
msgid "print only branches of the object"
msgstr "只打印指向该对象的分支"

#: builtin/branch.c builtin/for-each-ref.c builtin/tag.c
msgid "sorting and filtering are case insensitive"
msgstr "排序和过滤属于大小写不敏感"

#: builtin/branch.c builtin/ls-files.c
msgid "recurse through submodules"
msgstr "在子模组中递归"

#: builtin/branch.c builtin/for-each-ref.c builtin/ls-files.c builtin/ls-tree.c
#: builtin/tag.c builtin/verify-tag.c
msgid "format to use for the output"
msgstr "输出格式"

#: builtin/branch.c
msgid "failed to resolve HEAD as a valid ref"
msgstr "无法将 HEAD 解析为有效引用"

#: builtin/branch.c builtin/clone.c
msgid "HEAD not found below refs/heads!"
msgstr "HEAD 没有位于 /refs/heads 之下！"

#: builtin/branch.c
msgid ""
"branch with --recurse-submodules can only be used if "
"submodule.propagateBranches is enabled"
msgstr ""
"带有 --recurse-submodules 的分支只能在 submodule.propagateBranches 启用时使用"

#: builtin/branch.c
msgid "--recurse-submodules can only be used to create branches"
msgstr "--recurse-submodules 只能用于创建分支"

#: builtin/branch.c
msgid "branch name required"
msgstr "必须提供分支名"

#: builtin/branch.c
msgid "cannot give description to detached HEAD"
msgstr "不能向分离头指针提供描述"

#: builtin/branch.c
msgid "cannot edit description of more than one branch"
msgstr "不能为一个以上的分支编辑描述"

#: builtin/branch.c
msgid "cannot copy the current branch while not on any"
msgstr "不处于任何分支上，无法拷贝当前分支"

#: builtin/branch.c
msgid "cannot rename the current branch while not on any"
msgstr "不处于任何分支上，无法重命名当前分支"

#: builtin/branch.c
msgid "too many branches for a copy operation"
msgstr "为拷贝操作提供了太多的分支名"

#: builtin/branch.c
msgid "too many arguments for a rename operation"
msgstr "为重命名操作提供了太多的参数"

#: builtin/branch.c
msgid "too many arguments to set new upstream"
msgstr "为设置新上游提供了太多的参数"

#: builtin/branch.c
#, c-format
msgid ""
"could not set upstream of HEAD to %s when it does not point to any branch"
msgstr "无法设置 HEAD 的上游为 %s，因为 HEAD 没有指向任何分支"

#: builtin/branch.c
#, c-format
msgid "no such branch '%s'"
msgstr "没有此分支 '%s'"

#: builtin/branch.c
#, c-format
msgid "branch '%s' does not exist"
msgstr "分支 '%s' 不存在"

#: builtin/branch.c
msgid "too many arguments to unset upstream"
msgstr "为取消上游设置操作提供了太多的参数"

#: builtin/branch.c
msgid "could not unset upstream of HEAD when it does not point to any branch"
msgstr "无法取消 HEAD 的上游设置因为它没有指向一个分支"

#: builtin/branch.c
#, c-format
msgid "branch '%s' has no upstream information"
msgstr "分支 '%s' 没有上游信息"

#: builtin/branch.c
msgid ""
"the -a, and -r, options to 'git branch' do not take a branch name.\n"
"Did you mean to use: -a|-r --list <pattern>?"
msgstr ""
"'git branch' 的 -a 和 -r 选项不带一个分支名。\n"
"您是否想要使用：-a|-r --list <模式>？"

#: builtin/branch.c
msgid ""
"the '--set-upstream' option is no longer supported. Please use '--track' or "
"'--set-upstream-to' instead"
msgstr "不再支持选项 '--set-upstream'。请使用 '--track' 或 '--set-upstream-to'"

#: builtin/bugreport.c
msgid "git version:\n"
msgstr "git 版本：\n"

#: builtin/bugreport.c
msgid "compiler info: "
msgstr "编译器信息："

#: builtin/bugreport.c
msgid "libc info: "
msgstr "libc 信息："

#: builtin/bugreport.c
msgid "not run from a git repository - no hooks to show\n"
msgstr "不是在 git 仓库中执行 - 没有可显示的钩子\n"

#: builtin/bugreport.c
msgid ""
"git bugreport [(-o | --output-directory) <path>]\n"
"              [(-s | --suffix) <format> | --no-suffix]\n"
"              [--diagnose[=<mode>]]"
msgstr ""
"git bugreport [-o | --output-directory <文件>]\n"
"              [(-s | --suffix) <格式> | --no-suffix]\n"
"              [--diagnose[=<模式>]"

#: builtin/bugreport.c
msgid ""
"Thank you for filling out a Git bug report!\n"
"Please answer the following questions to help us understand your issue.\n"
"\n"
"What did you do before the bug happened? (Steps to reproduce your issue)\n"
"\n"
"What did you expect to happen? (Expected behavior)\n"
"\n"
"What happened instead? (Actual behavior)\n"
"\n"
"What's different between what you expected and what actually happened?\n"
"\n"
"Anything else you want to add:\n"
"\n"
"Please review the rest of the bug report below.\n"
"You can delete any lines you don't wish to share.\n"
msgstr ""
"感谢您填写 Git 错误报告！\n"
"请填写以下问卷，以帮助我们了解您的问题。\n"
"\n"
"在错误发生之前，您做了什么？（重现问题的步骤）\n"
"\n"
"您期望发生什么？（预期行为）\n"
"\n"
"实际发生了什么？（实际行为）\n"
"\n"
"您所期望的与实际发生的有什么不同？\n"
"\n"
"您想要补充的其它内容：\n"
"\n"
"请检查下面错误报告中余下的内容。\n"
"您可以删除任何您不想共享的内容。\n"

#: builtin/bugreport.c builtin/commit.c builtin/fast-export.c builtin/rebase.c
#: parse-options.h
msgid "mode"
msgstr "模式"

#: builtin/bugreport.c
msgid ""
"create an additional zip archive of detailed diagnostics (default 'stats')"
msgstr "额外创建详细诊断信息的压缩包（默认 'stats'）"

#: builtin/bugreport.c
msgid "specify a destination for the bugreport file(s)"
msgstr "指定错误报告文件的目标位置"

#: builtin/bugreport.c
msgid "specify a strftime format suffix for the filename(s)"
msgstr "指定文件的 strftime 格式后缀"

#: builtin/bugreport.c
#, c-format
msgid "unknown argument `%s'"
msgstr "未知参数 `%s'"

#: builtin/bugreport.c builtin/diagnose.c
#, c-format
msgid "could not create leading directories for '%s'"
msgstr "不能为 '%s' 创建先导目录"

#: builtin/bugreport.c builtin/diagnose.c
#, c-format
msgid "unable to create diagnostics archive %s"
msgstr "不能创建诊断归档包 %s"

#: builtin/bugreport.c
msgid "System Info"
msgstr "系统信息"

#: builtin/bugreport.c
msgid "Enabled Hooks"
msgstr "启用的钩子"

#: builtin/bugreport.c
#, c-format
msgid "unable to write to %s"
msgstr "无法写入 %s"

#: builtin/bugreport.c
#, c-format
msgid "Created new report at '%s'.\n"
msgstr "在 '%s' 创建了新报告。\n"

#: builtin/bundle.c
msgid ""
"git bundle create [-q | --quiet | --progress]\n"
"                  [--version=<version>] <file> <git-rev-list-args>"
msgstr ""
"git bundle create [-q | --quiet | --progress]\n"
"                  [--version=<版本>] <文件> <git-rev-list-参数>"

#: builtin/bundle.c
msgid "git bundle verify [-q | --quiet] <file>"
msgstr "git bundle verify [-q | --quiet] <文件>"

#: builtin/bundle.c
msgid "git bundle list-heads <file> [<refname>...]"
msgstr "git bundle list-heads <文件> [<引用名>...]"

#: builtin/bundle.c
msgid "git bundle unbundle [--progress] <file> [<refname>...]"
msgstr "git bundle unbundle [--progress] <文件> [<引用名>...]"

#: builtin/bundle.c
msgid "need a <file> argument"
msgstr "需要一个 <文件> 参数"

#: builtin/bundle.c builtin/pack-objects.c
msgid "do not show progress meter"
msgstr "不显示进度表"

#: builtin/bundle.c builtin/pack-objects.c
msgid "show progress meter"
msgstr "显示进度表"

#: builtin/bundle.c
msgid "historical; same as --progress"
msgstr "老的参数；等同于 --progress"

#: builtin/bundle.c
msgid "historical; does nothing"
msgstr "老的参数；无作用"

#: builtin/bundle.c
msgid "specify bundle format version"
msgstr "指定归档包的格式版本"

#: builtin/bundle.c
msgid "Need a repository to create a bundle."
msgstr "需要一个仓库来创建归档包。"

#: builtin/bundle.c
msgid "do not show bundle details"
msgstr "不显示归档包的细节"

#: builtin/bundle.c bundle.c
msgid "need a repository to verify a bundle"
msgstr "需要一个仓库来校验一个归档包"

#: builtin/bundle.c
#, c-format
msgid "%s is okay\n"
msgstr "%s 可以\n"

#: builtin/bundle.c
msgid "Need a repository to unbundle."
msgstr "需要一个仓库来解开归档包。"

#: builtin/bundle.c
msgid "Unbundling objects"
msgstr "解包对象中"

#: builtin/cat-file.c merge-recursive.c
#, c-format
msgid "cannot read object %s '%s'"
msgstr "不能读取对象 %s '%s'"

#: builtin/cat-file.c
msgid "flush is only for --buffer mode"
msgstr "flush 只在 --buffer 模式中使用"

#: builtin/cat-file.c
msgid "empty command in input"
msgstr "输入为空的命令"

#: builtin/cat-file.c
#, c-format
msgid "whitespace before command: '%s'"
msgstr "命令前存在空白：'%s'"

#: builtin/cat-file.c
#, c-format
msgid "%s requires arguments"
msgstr "%s 需要参数"

#: builtin/cat-file.c
#, c-format
msgid "%s takes no arguments"
msgstr "%s 不需要参数"

#: builtin/cat-file.c
msgid "only one batch option may be specified"
msgstr "只能指定一个批处理选项"

#: builtin/cat-file.c
msgid "git cat-file <type> <object>"
msgstr "git cat-file <类型> <对象>"

#: builtin/cat-file.c
msgid "git cat-file (-e | -p) <object>"
msgstr "git cat-file (-e | -p) <对象>"

#: builtin/cat-file.c
msgid "git cat-file (-t | -s) [--allow-unknown-type] <object>"
msgstr "git cat-file (-t | -s) [--allow-unknown-type] <对象>"

#: builtin/cat-file.c
msgid ""
"git cat-file (--textconv | --filters)\n"
"             [<rev>:<path|tree-ish> | --path=<path|tree-ish> <rev>]"
msgstr ""
"git cat-file (--textconv | --filters)\n"
"             [<版本>:<路径|树对象> | --path=<路径|树对象> <版本>]"

#: builtin/cat-file.c
msgid ""
"git cat-file (--batch | --batch-check | --batch-command) [--batch-all-"
"objects]\n"
"             [--buffer] [--follow-symlinks] [--unordered]\n"
"             [--textconv | --filters] [-Z]"
msgstr ""
"git cat-file (--batch | --batch-check | --batch-command) [--batch-all-"
"objects]\n"
"             [--buffer] [--follow-symlinks] [--unordered]\n"
"             [--textconv | --filters] [-Z]"

#: builtin/cat-file.c
msgid "Check object existence or emit object contents"
msgstr "检查对象存在或输出对象内容"

#: builtin/cat-file.c
msgid "check if <object> exists"
msgstr "检查 <对象> 是否存在"

#: builtin/cat-file.c
msgid "pretty-print <object> content"
msgstr "美观地打印 <对象> 的内容"

#: builtin/cat-file.c
msgid "Emit [broken] object attributes"
msgstr "输出 [坏的] 对象属性"

#: builtin/cat-file.c
msgid "show object type (one of 'blob', 'tree', 'commit', 'tag', ...)"
msgstr "显示对象的类型（'blob'、'tree'、'commit'、'tag'……其中之一）"

#: builtin/cat-file.c
msgid "show object size"
msgstr "显示对象大小"

#: builtin/cat-file.c
msgid "allow -s and -t to work with broken/corrupt objects"
msgstr "允许 -s 和 -t 对损坏的对象生效"

#: builtin/cat-file.c builtin/log.c
msgid "use mail map file"
msgstr "使用邮件映射文件"

#: builtin/cat-file.c
msgid "Batch objects requested on stdin (or --batch-all-objects)"
msgstr "批量处理标准输入中请求的对象（或者 --batch-all-objects）"

#: builtin/cat-file.c
msgid "show full <object> or <rev> contents"
msgstr "显示完整的 <对象> 或 <版本> 内容"

#: builtin/cat-file.c
msgid "like --batch, but don't emit <contents>"
msgstr "类似于 --batch，但不输出 <内容>"

#: builtin/cat-file.c
msgid "stdin is NUL-terminated"
msgstr "标准输入以 NUL 字符分隔"

#: builtin/cat-file.c
msgid "stdin and stdout is NUL-terminated"
msgstr "标准输入和标准输出以 NUL 字符分隔"

#: builtin/cat-file.c
msgid "read commands from stdin"
msgstr "从标准输入读取命令"

#: builtin/cat-file.c
msgid "with --batch[-check]: ignores stdin, batches all known objects"
msgstr "带有 --batch[-check]：忽略标准输入，批量处理所有已知的对象"

#: builtin/cat-file.c
msgid "Change or optimize batch output"
msgstr "更改或优化批处理输出"

#: builtin/cat-file.c
msgid "buffer --batch output"
msgstr "缓冲 --batch 的输出"

#: builtin/cat-file.c
msgid "follow in-tree symlinks"
msgstr "跟随树内符号链接"

#: builtin/cat-file.c
msgid "do not order objects before emitting them"
msgstr "在输出对象前不要排序"

#: builtin/cat-file.c
msgid ""
"Emit object (blob or tree) with conversion or filter (stand-alone, or with "
"batch)"
msgstr "转换或过滤后输出对象（数据对象或树）（单独或批处理）"

#: builtin/cat-file.c
msgid "run textconv on object's content"
msgstr "对对象内容做文本转换"

#: builtin/cat-file.c
msgid "run filters on object's content"
msgstr "对对象内容做过滤"

#: builtin/cat-file.c
msgid "blob|tree"
msgstr "数据对象|树"

#: builtin/cat-file.c
msgid "use a <path> for (--textconv | --filters); Not with 'batch'"
msgstr "(--textconv | --filters) 使用 <路径>；而不是 'batch'"

#: builtin/cat-file.c
#, c-format
msgid "'%s=<%s>' needs '%s' or '%s'"
msgstr "'%s=<%s>' 需要 '%s' 或 '%s'"

#: builtin/cat-file.c
msgid "path|tree-ish"
msgstr "路径|树对象"

#: builtin/cat-file.c
#, c-format
msgid "'%s' requires a batch mode"
msgstr "'%s' 需要批处理模式"

#: builtin/cat-file.c
#, c-format
msgid "'-%c' is incompatible with batch mode"
msgstr "'-%c' 与批处理模式不兼容"

#: builtin/cat-file.c
msgid "batch modes take no arguments"
msgstr "批处理模式不带其他参数"

#: builtin/cat-file.c
#, c-format
msgid "<rev> required with '%s'"
msgstr "'%s' 需要 <版本>"

#: builtin/cat-file.c
#, c-format
msgid "<object> required with '-%c'"
msgstr "'-%c' 需要 <对象>"

#: builtin/cat-file.c
#, c-format
msgid "only two arguments allowed in <type> <object> mode, not %d"
msgstr "<类型> <对象> 模式只允许两个参数，而不是 %d 个"

#: builtin/check-attr.c
msgid ""
"git check-attr [--source <tree-ish>] [-a | --all | <attr>...] [--] "
"<pathname>..."
msgstr ""
"git check-attr [--source <树对象>] [-a | --all | <属性>...] [--] <路径名>..."

#: builtin/check-attr.c
msgid ""
"git check-attr --stdin [-z] [--source <tree-ish>] [-a | --all | <attr>...]"
msgstr ""
"git check-attr --stdin [-z] [--source <树对象>] [-a | --all | <属性>...]"

#: builtin/check-attr.c
msgid "report all attributes set on file"
msgstr "报告设置在文件上的所有属性"

#: builtin/check-attr.c
msgid "use .gitattributes only from the index"
msgstr "只使用索引中的 .gitattributes"

#: builtin/check-attr.c builtin/check-ignore.c builtin/hash-object.c
msgid "read file names from stdin"
msgstr "从标准输入读出文件名"

#: builtin/check-attr.c builtin/check-ignore.c
msgid "terminate input and output records by a NUL character"
msgstr "输入和输出的记录使用 NUL 字符终结"

#: builtin/check-attr.c
msgid "<tree-ish>"
msgstr "<树对象>"

#: builtin/check-attr.c
msgid "which tree-ish to check attributes at"
msgstr "要用哪一个树对象来检查属性"

#: builtin/check-ignore.c builtin/checkout.c builtin/gc.c builtin/worktree.c
msgid "suppress progress reporting"
msgstr "不显示进度报告"

#: builtin/check-ignore.c
msgid "show non-matching input paths"
msgstr "显示未匹配的输入路径"

#: builtin/check-ignore.c
msgid "ignore index when checking"
msgstr "检查时忽略索引"

#: builtin/check-ignore.c
msgid "cannot specify pathnames with --stdin"
msgstr "不能同时指定路径及 --stdin 参数"

#: builtin/check-ignore.c
msgid "-z only makes sense with --stdin"
msgstr "-z 需要和 --stdin 参数共用才有意义"

#: builtin/check-ignore.c
msgid "no path specified"
msgstr "未指定路径"

#: builtin/check-ignore.c
msgid "--quiet is only valid with a single pathname"
msgstr "参数 --quiet 只在提供一个路径名时有效"

#: builtin/check-ignore.c
msgid "cannot have both --quiet and --verbose"
msgstr "不能同时提供 --quiet 和 --verbose 参数"

#: builtin/check-ignore.c
msgid "--non-matching is only valid with --verbose"
msgstr "--non-matching 选项只在使用 --verbose 时有效"

#: builtin/check-mailmap.c
msgid "git check-mailmap [<options>] <contact>..."
msgstr "git check-mailmap [<选项>] <联系地址>..."

#: builtin/check-mailmap.c
msgid "also read contacts from stdin"
msgstr "还从标准输入读取联系地址"

#: builtin/check-mailmap.c
msgid "read additional mailmap entries from file"
msgstr "从文件中读取附加邮件映射条目"

#: builtin/check-mailmap.c
msgid "blob"
msgstr "数据对象"

#: builtin/check-mailmap.c
msgid "read additional mailmap entries from blob"
msgstr "从数据对象中读取附加邮件映射条目"

#: builtin/check-mailmap.c
msgid "no contacts specified"
msgstr "未指定联系地址"

#: builtin/checkout--worker.c
msgid "git checkout--worker [<options>]"
msgstr "git checkout--worker [<选项>]"

#: builtin/checkout--worker.c builtin/checkout-index.c builtin/column.c
#: builtin/submodule--helper.c builtin/worktree.c
msgid "string"
msgstr "字符串"

#: builtin/checkout--worker.c builtin/checkout-index.c
msgid "when creating files, prepend <string>"
msgstr "在创建文件时，在前面加上 <字符串>"

#: builtin/checkout-index.c
msgid "git checkout-index [<options>] [--] [<file>...]"
msgstr "git checkout-index [<选项>] [--] [<文件>...]"

#: builtin/checkout-index.c
msgid "stage should be between 1 and 3 or all"
msgstr "索引值应该取值 1 到 3 或者 all"

#: builtin/checkout-index.c
msgid "check out all files in the index"
msgstr "检出索引区的所有文件"

#: builtin/checkout-index.c
msgid "do not skip files with skip-worktree set"
msgstr "在 skip-worktree 设置时不要跳过文件"

#: builtin/checkout-index.c
msgid "force overwrite of existing files"
msgstr "强制覆盖现有的文件"

#: builtin/checkout-index.c
msgid "no warning for existing files and files not in index"
msgstr "存在或不在索引中的文件都没有警告"

#: builtin/checkout-index.c
msgid "don't checkout new files"
msgstr "不检出新文件"

#: builtin/checkout-index.c
msgid "update stat information in the index file"
msgstr "更新索引中文件的状态信息"

#: builtin/checkout-index.c
msgid "read list of paths from the standard input"
msgstr "从标准输入读取路径列表"

#: builtin/checkout-index.c
msgid "write the content to temporary files"
msgstr "将内容写入临时文件"

#: builtin/checkout-index.c
msgid "copy out the files from named stage"
msgstr "从指定暂存区中拷出文件"

#: builtin/checkout.c
msgid "git checkout [<options>] <branch>"
msgstr "git checkout [<选项>] <分支>"

#: builtin/checkout.c
msgid "git checkout [<options>] [<branch>] -- <file>..."
msgstr "git checkout [<选项>] [<分支>] -- <文件>..."

#: builtin/checkout.c
msgid "git switch [<options>] [<branch>]"
msgstr "git switch [<选项>] [<分支>]"

#: builtin/checkout.c
msgid "git restore [<options>] [--source=<branch>] <file>..."
msgstr "git restore [<选项>] [--source=<分支>] <文件>..."

#: builtin/checkout.c
#, c-format
msgid "path '%s' does not have our version"
msgstr "路径 '%s' 没有我们的版本"

#: builtin/checkout.c
#, c-format
msgid "path '%s' does not have their version"
msgstr "路径 '%s' 没有他们的版本"

#: builtin/checkout.c
#, c-format
msgid "path '%s' does not have all necessary versions"
msgstr "路径 '%s' 没有全部必需的版本"

#: builtin/checkout.c
#, c-format
msgid "path '%s' does not have necessary versions"
msgstr "路径 '%s' 没有必需的版本"

#: builtin/checkout.c
#, c-format
msgid "path '%s': cannot merge"
msgstr "path '%s'：无法合并"

#: builtin/checkout.c
#, c-format
msgid "Unable to add merge result for '%s'"
msgstr "无法为 '%s' 添加合并结果"

#: builtin/checkout.c
#, c-format
msgid "Recreated %d merge conflict"
msgid_plural "Recreated %d merge conflicts"
msgstr[0] "重新创建了 %d 个合并冲突"
msgstr[1] "重新创建了 %d 个合并冲突"

#: builtin/checkout.c
#, c-format
msgid "Updated %d path from %s"
msgid_plural "Updated %d paths from %s"
msgstr[0] "从 %2$s 更新了 %1$d 个路径"
msgstr[1] "从 %2$s 更新了 %1$d 个路径"

#: builtin/checkout.c
#, c-format
msgid "Updated %d path from the index"
msgid_plural "Updated %d paths from the index"
msgstr[0] "从索引区更新了 %d 个路径"
msgstr[1] "从索引区更新了 %d 个路径"

#: builtin/checkout.c
#, c-format
msgid "'%s' cannot be used with updating paths"
msgstr "'%s' 不能在更新路径时使用"

#: builtin/checkout.c
#, c-format
msgid "Cannot update paths and switch to branch '%s' at the same time."
msgstr "不能同时更新路径并切换到分支'%s'。"

#: builtin/checkout.c
#, c-format
msgid "neither '%s' or '%s' is specified"
msgstr "'%s' 或 '%s' 都没有指定"

#: builtin/checkout.c
#, c-format
msgid "'%s' must be used when '%s' is not specified"
msgstr "未指定 '%2$s' 时，必须使用 '%1$s'"

#: builtin/checkout.c
#, c-format
msgid "'%s' or '%s' cannot be used with %s"
msgstr "'%s' 或 '%s' 不能和 %s 一起使用"

#: builtin/checkout.c
#, c-format
msgid "'%s', '%s', or '%s' cannot be used when checking out of a tree"
msgstr "'%s'、'%s' 或 '%s' 不能在检出一个树时使用"

#: builtin/checkout.c
#, c-format
msgid "path '%s' is unmerged"
msgstr "路径 '%s' 未合并"

#: builtin/checkout.c builtin/grep.c builtin/merge-tree.c builtin/reset.c
#: merge-ort.c reset.c sequencer.c tree-walk.c
#, c-format
msgid "unable to read tree (%s)"
msgstr "无法读取树（%s）"

#: builtin/checkout.c
msgid "you need to resolve your current index first"
msgstr "您需要先解决当前索引的冲突"

#: builtin/checkout.c
#, c-format
msgid ""
"cannot continue with staged changes in the following files:\n"
"%s"
msgstr ""
"不能继续，下列文件有暂存的修改：\n"
"%s"

#: builtin/checkout.c
#, c-format
msgid "Can not do reflog for '%s': %s\n"
msgstr "不能对 '%s' 执行 reflog 操作：%s\n"

#: builtin/checkout.c
msgid "HEAD is now at"
msgstr "HEAD 目前位于"

#: builtin/checkout.c builtin/clone.c
msgid "unable to update HEAD"
msgstr "不能更新 HEAD"

#: builtin/checkout.c
#, c-format
msgid "Reset branch '%s'\n"
msgstr "重置分支 '%s'\n"

#: builtin/checkout.c
#, c-format
msgid "Already on '%s'\n"
msgstr "已经位于 '%s'\n"

#: builtin/checkout.c
#, c-format
msgid "Switched to and reset branch '%s'\n"
msgstr "切换并重置分支 '%s'\n"

#: builtin/checkout.c
#, c-format
msgid "Switched to a new branch '%s'\n"
msgstr "切换到一个新分支 '%s'\n"

#: builtin/checkout.c
#, c-format
msgid "Switched to branch '%s'\n"
msgstr "切换到分支 '%s'\n"

#  译者：注意保持前导空格
#: builtin/checkout.c
#, c-format
msgid " ... and %d more.\n"
msgstr " ... 及其它 %d 个。\n"

#: builtin/checkout.c
#, c-format
msgid ""
"Warning: you are leaving %d commit behind, not connected to\n"
"any of your branches:\n"
"\n"
"%s\n"
msgid_plural ""
"Warning: you are leaving %d commits behind, not connected to\n"
"any of your branches:\n"
"\n"
"%s\n"
msgstr[0] ""
"警告：您正丢下 %d 个提交，未和任何分支关联：\n"
"\n"
"%s\n"
msgstr[1] ""
"警告：您正丢下 %d 个提交，未和任何分支关联：\n"
"\n"
"%s\n"

#: builtin/checkout.c
#, c-format
msgid ""
"If you want to keep it by creating a new branch, this may be a good time\n"
"to do so with:\n"
"\n"
" git branch <new-branch-name> %s\n"
"\n"
msgid_plural ""
"If you want to keep them by creating a new branch, this may be a good time\n"
"to do so with:\n"
"\n"
" git branch <new-branch-name> %s\n"
"\n"
msgstr[0] ""
"如果您想要通过创建新分支保存它，这可能是一个好时候。\n"
"如下操作：\n"
"\n"
" git branch <新分支名> %s\n"
"\n"
msgstr[1] ""
"如果您想要通过创建新分支保存它们，这可能是一个好时候。\n"
"如下操作：\n"
"\n"
" git branch <新分支名> %s\n"
"\n"

#: builtin/checkout.c
msgid "internal error in revision walk"
msgstr "在版本遍历时遇到内部错误"

#: builtin/checkout.c
msgid "Previous HEAD position was"
msgstr "之前的 HEAD 位置是"

#: builtin/checkout.c
msgid "You are on a branch yet to be born"
msgstr "您位于一个尚未初始化的分支"

#: builtin/checkout.c
#, c-format
msgid ""
"'%s' could be both a local file and a tracking branch.\n"
"Please use -- (and optionally --no-guess) to disambiguate"
msgstr ""
"'%s' 既可以是一个本地文件，也可以是一个跟踪分支。\n"
"请使用 --（和可选的 --no-guess）来消除歧义"

#: builtin/checkout.c
msgid ""
"If you meant to check out a remote tracking branch on, e.g. 'origin',\n"
"you can do so by fully qualifying the name with the --track option:\n"
"\n"
"    git checkout --track origin/<name>\n"
"\n"
"If you'd like to always have checkouts of an ambiguous <name> prefer\n"
"one remote, e.g. the 'origin' remote, consider setting\n"
"checkout.defaultRemote=origin in your config."
msgstr ""
"如果您想要检出一个远程跟踪分支，例如在 'origin' 上的，您可以使用分支\n"
"全名和 --track 选项：\n"
"\n"
"    git checkout --track origin/<名称>\n"
"\n"
"如果您总是喜欢使用模糊的简短分支名 <名称>，而不喜欢如 'origin' 的远程\n"
"名称，可以在配置中设置 checkout.defaultRemote=origin。"

#: builtin/checkout.c
#, c-format
msgid "'%s' matched multiple (%d) remote tracking branches"
msgstr "'%s' 匹配多个（%d 个）远程跟踪分支"

#: builtin/checkout.c
msgid "only one reference expected"
msgstr "只期望一个引用"

#: builtin/checkout.c
#, c-format
msgid "only one reference expected, %d given."
msgstr "应只有一个引用，却给出了 %d 个"

#: builtin/checkout.c builtin/worktree.c
#, c-format
msgid "invalid reference: %s"
msgstr "无效引用：%s"

#: builtin/checkout.c
#, c-format
msgid "reference is not a tree: %s"
msgstr "引用不是一个树：%s"

#: builtin/checkout.c
#, c-format
msgid "a branch is expected, got tag '%s'"
msgstr "期望一个分支，得到标签 '%s'"

#: builtin/checkout.c
#, c-format
msgid "a branch is expected, got remote branch '%s'"
msgstr "期望一个分支，得到远程分支 '%s'"

#: builtin/checkout.c
#, c-format
msgid "a branch is expected, got '%s'"
msgstr "期望一个分支，得到 '%s'"

#: builtin/checkout.c
#, c-format
msgid "a branch is expected, got commit '%s'"
msgstr "期望一个分支，得到提交 '%s'"

#: builtin/checkout.c
msgid ""
"If you want to detach HEAD at the commit, try again with the --detach option."
msgstr "如果你在本提交分离头指针，使用 --detach 选项重试。"

#: builtin/checkout.c
msgid ""
"cannot switch branch while merging\n"
"Consider \"git merge --quit\" or \"git worktree add\"."
msgstr ""
"不能在合并时切换分支\n"
"考虑使用 \"git merge --quit\" 或 \"git worktree add\"。"

#: builtin/checkout.c
msgid ""
"cannot switch branch in the middle of an am session\n"
"Consider \"git am --quit\" or \"git worktree add\"."
msgstr ""
"不能在一个 am 会话期间切换分支\n"
"考虑使用 \"git am --quit\" 或 \"git worktree add\"。"

#: builtin/checkout.c
msgid ""
"cannot switch branch while rebasing\n"
"Consider \"git rebase --quit\" or \"git worktree add\"."
msgstr ""
"不能在变基时切换分支\n"
"考虑使用 \"git rebase --quit\" 或 \"git worktree add\"。"

#: builtin/checkout.c
msgid ""
"cannot switch branch while cherry-picking\n"
"Consider \"git cherry-pick --quit\" or \"git worktree add\"."
msgstr ""
"不能在拣选时切换分支\n"
"考虑使用 \"git cherry-pick --quit\" 或 \"git worktree add\"。"

#: builtin/checkout.c
msgid ""
"cannot switch branch while reverting\n"
"Consider \"git revert --quit\" or \"git worktree add\"."
msgstr ""
"不能在还原时切换分支\n"
"考虑使用 \"git revert --quit\" 或 \"git worktree add\"。"

#: builtin/checkout.c
msgid "you are switching branch while bisecting"
msgstr "您在执行二分查找时切换分支"

#: builtin/checkout.c
msgid "paths cannot be used with switching branches"
msgstr "路径不能和切换分支同时使用"

#: builtin/checkout.c
#, c-format
msgid "'%s' cannot be used with switching branches"
msgstr "'%s' 不能和切换分支同时使用"

#: builtin/checkout.c
#, c-format
msgid "'%s' needs the paths to check out"
msgstr "'%s' 需要路径进行检出"

#: builtin/checkout.c
#, c-format
msgid "'%s' cannot be used with '%s'"
msgstr "'%s' 不能和 '%s' 同时使用"

#: builtin/checkout.c
#, c-format
msgid "'%s' cannot take <start-point>"
msgstr "'%s' 不带 <起始点>"

#: builtin/checkout.c
#, c-format
msgid "Cannot switch branch to a non-commit '%s'"
msgstr "不能切换分支到一个非提交 '%s'"

#: builtin/checkout.c
msgid "missing branch or commit argument"
msgstr "缺少分支或提交参数"

#: builtin/checkout.c
#, c-format
msgid "unknown conflict style '%s'"
msgstr "未知的冲突风格 '%s'"

#: builtin/checkout.c
msgid "perform a 3-way merge with the new branch"
msgstr "和新的分支执行三方合并"

#: builtin/checkout.c builtin/log.c builtin/range-diff.c parse-options.h
msgid "style"
msgstr "风格"

#: builtin/checkout.c
msgid "conflict style (merge, diff3, or zdiff3)"
msgstr "冲突输出风格（merge、diff3 或 zdiff3）"

#: builtin/checkout.c builtin/worktree.c
msgid "detach HEAD at named commit"
msgstr "HEAD 从指定的提交分离"

#: builtin/checkout.c
msgid "force checkout (throw away local modifications)"
msgstr "强制检出（丢弃本地修改）"

#: builtin/checkout.c
msgid "new-branch"
msgstr "新分支"

#: builtin/checkout.c
msgid "new unborn branch"
msgstr "新的未诞生的分支"

#: builtin/checkout.c builtin/merge.c
msgid "update ignored files (default)"
msgstr "更新忽略的文件（默认）"

#: builtin/checkout.c
msgid "do not check if another worktree is using this branch"
msgstr "不检查其他工作区是否正在使用该分支"

#: builtin/checkout.c
msgid "checkout our version for unmerged files"
msgstr "对尚未合并的文件检出我们的版本"

#: builtin/checkout.c
msgid "checkout their version for unmerged files"
msgstr "对尚未合并的文件检出他们的版本"

#: builtin/checkout.c
msgid "do not limit pathspecs to sparse entries only"
msgstr "对路径不做稀疏检出的限制"

#: builtin/checkout.c
#, c-format
msgid "options '-%c', '-%c', and '%s' cannot be used together"
msgstr "选项 '-%c'、'-%c' 和 ‘%s' 不能同时使用"

#: builtin/checkout.c
msgid "--track needs a branch name"
msgstr "--track 需要一个分支名"

#: builtin/checkout.c
#, c-format
msgid "missing branch name; try -%c"
msgstr "缺少分支名，尝试 -%c"

#: builtin/checkout.c
#, c-format
msgid "could not resolve %s"
msgstr "无法解析 %s"

#: builtin/checkout.c
msgid "invalid path specification"
msgstr "无效的路径规格"

#: builtin/checkout.c
#, c-format
msgid "'%s' is not a commit and a branch '%s' cannot be created from it"
msgstr "'%s' 不是一个提交，不能基于它创建分支 '%s'"

#: builtin/checkout.c
#, c-format
msgid "git checkout: --detach does not take a path argument '%s'"
msgstr "git checkout：--detach 不能接收路径参数 '%s'"

#: builtin/checkout.c
msgid ""
"git checkout: --ours/--theirs, --force and --merge are incompatible when\n"
"checking out of the index."
msgstr ""
"git checkout：在从索引检出时，--ours/--theirs、--force 和 --merge 不兼容。"

#: builtin/checkout.c
msgid "you must specify path(s) to restore"
msgstr "您必须指定要恢复的路径"

#: builtin/checkout.c builtin/clone.c builtin/remote.c builtin/replay.c
#: builtin/submodule--helper.c builtin/worktree.c
msgid "branch"
msgstr "分支"

#: builtin/checkout.c
msgid "create and checkout a new branch"
msgstr "创建并检出一个新的分支"

#: builtin/checkout.c
msgid "create/reset and checkout a branch"
msgstr "创建/重置并检出一个分支"

#: builtin/checkout.c
msgid "create reflog for new branch"
msgstr "为新的分支创建引用日志"

#: builtin/checkout.c
msgid "second guess 'git checkout <no-such-branch>' (default)"
msgstr "二次猜测 'git checkout <无此分支>'（默认）"

#: builtin/checkout.c
msgid "use overlay mode (default)"
msgstr "使用叠加模式（默认）"

#: builtin/checkout.c
msgid "create and switch to a new branch"
msgstr "创建并切换一个新分支"

#: builtin/checkout.c
msgid "create/reset and switch to a branch"
msgstr "创建/重置并切换一个分支"

#: builtin/checkout.c
msgid "second guess 'git switch <no-such-branch>'"
msgstr "二次猜测 'git switch <无此分支>'"

#: builtin/checkout.c
msgid "throw away local modifications"
msgstr "丢弃本地修改"

#: builtin/checkout.c
msgid "which tree-ish to checkout from"
msgstr "要检出哪一个树"

#: builtin/checkout.c
msgid "restore the index"
msgstr "恢复索引"

#: builtin/checkout.c
msgid "restore the working tree (default)"
msgstr "恢复工作区（默认）"

#: builtin/checkout.c
msgid "ignore unmerged entries"
msgstr "忽略未合并条目"

#: builtin/checkout.c
msgid "use overlay mode"
msgstr "使用叠加模式"

#: builtin/clean.c
msgid ""
"git clean [-d] [-f] [-i] [-n] [-q] [-e <pattern>] [-x | -X] [--] "
"[<pathspec>...]"
msgstr ""
"git clean [-d] [-f] [-i] [-n] [-q] [-e <模式>] [-x | -X] [--] <路径规格>..."

#: builtin/clean.c
#, c-format
msgid "Removing %s\n"
msgstr "正删除 %s\n"

#: builtin/clean.c
#, c-format
msgid "Would remove %s\n"
msgstr "将删除 %s\n"

#: builtin/clean.c
#, c-format
msgid "Skipping repository %s\n"
msgstr "忽略仓库 %s\n"

#: builtin/clean.c
#, c-format
msgid "Would skip repository %s\n"
msgstr "将忽略仓库 %s\n"

#: builtin/clean.c midx.c
#, c-format
msgid "failed to remove %s"
msgstr "无法删除 %s"

#: builtin/clean.c
#, c-format
msgid "could not lstat %s\n"
msgstr "不能对 %s 调用 lstat\n"

#: builtin/clean.c
msgid "Refusing to remove current working directory\n"
msgstr "拒绝删除当前工作目录\n"

#: builtin/clean.c
msgid "Would refuse to remove current working directory\n"
msgstr "将拒绝删除当前工作目录\n"

#: builtin/clean.c
#, c-format
msgid ""
"Prompt help:\n"
"1          - select a numbered item\n"
"foo        - select item based on unique prefix\n"
"           - (empty) select nothing\n"
msgstr ""
"帮助：\n"
"1          - 通过编号选择一个选项\n"
"foo        - 通过唯一前缀选择一个选项\n"
"           - （空）什么也不选择\n"

#: builtin/clean.c
#, c-format
msgid ""
"Prompt help:\n"
"1          - select a single item\n"
"3-5        - select a range of items\n"
"2-3,6-9    - select multiple ranges\n"
"foo        - select item based on unique prefix\n"
"-...       - unselect specified items\n"
"*          - choose all items\n"
"           - (empty) finish selecting\n"
msgstr ""
"帮助：\n"
"1          - 选择一个选项\n"
"3-5        - 选择一个范围内的所有选项\n"
"2-3,6-9    - 选择多个范围内的所有选项\n"
"foo        - 通过唯一前缀选择一个选项\n"
"-...       - 反选特定的选项\n"
"*          - 选择所有选项\n"
"           - （空）结束选择\n"

#: builtin/clean.c
#, c-format
msgid "Huh (%s)?\n"
msgstr "嗯（%s）？\n"

#: builtin/clean.c
#, c-format
msgid "Input ignore patterns>> "
msgstr "输入模版以排除条目>> "

#: builtin/clean.c
#, c-format
msgid "WARNING: Cannot find items matched by: %s"
msgstr "警告：无法找到和 %s 匹配的条目"

#: builtin/clean.c
msgid "Select items to delete"
msgstr "选择要删除的条目"

#. TRANSLATORS: Make sure to keep [y/N] as is
#: builtin/clean.c
#, c-format
msgid "Remove %s [y/N]? "
msgstr "删除 %s [y/N]？"

#: builtin/clean.c
msgid ""
"clean               - start cleaning\n"
"filter by pattern   - exclude items from deletion\n"
"select by numbers   - select items to be deleted by numbers\n"
"ask each            - confirm each deletion (like \"rm -i\")\n"
"quit                - stop cleaning\n"
"help                - this screen\n"
"?                   - help for prompt selection"
msgstr ""
"clean               - 开始清理\n"
"filter by pattern   - 通过模版排除要删除的条目\n"
"select by numbers   - 通过数字选择要删除的条目\n"
"ask each            - 针对删除逐一询问（就像 \"rm -i\"）\n"
"quit                - 停止删除并退出\n"
"help                - 显示本帮助\n"
"?                   - 显示如何在提示符下选择的帮助"

#: builtin/clean.c
msgid "Would remove the following item:"
msgid_plural "Would remove the following items:"
msgstr[0] "将删除如下条目："
msgstr[1] "将删除如下条目："

#: builtin/clean.c
msgid "No more files to clean, exiting."
msgstr "没有要清理的文件，退出。"

#: builtin/clean.c
msgid "do not print names of files removed"
msgstr "不打印删除文件的名称"

#: builtin/clean.c
msgid "force"
msgstr "强制"

#: builtin/clean.c
msgid "interactive cleaning"
msgstr "交互式清除"

#: builtin/clean.c
msgid "remove whole directories"
msgstr "删除整个目录"

#: builtin/clean.c builtin/config.c builtin/describe.c builtin/grep.c
#: builtin/log.c builtin/ls-files.c builtin/name-rev.c builtin/pack-refs.c
#: builtin/show-ref.c ref-filter.h
msgid "pattern"
msgstr "模式"

#: builtin/clean.c
msgid "add <pattern> to ignore rules"
msgstr "添加 <模式> 到忽略规则"

#: builtin/clean.c
msgid "remove ignored files, too"
msgstr "也删除忽略的文件"

#: builtin/clean.c
msgid "remove only ignored files"
msgstr "只删除忽略的文件"

#: builtin/clean.c
msgid "clean.requireForce is true and -f not given: refusing to clean"
msgstr "clean.requireForce 设置为 true 且未提供 -f 选项：拒绝执行清理动作"

#: builtin/clone.c
#, c-format
msgid "info: Could not add alternate for '%s': %s\n"
msgstr "info: 不能为 '%s' 添加一个备用：%s\n"

#: builtin/clone.c builtin/diff.c builtin/rm.c grep.c setup.c
#, c-format
msgid "failed to stat '%s'"
msgstr "无法对 '%s' 调用 stat"

#: builtin/clone.c
#, c-format
msgid "%s exists and is not a directory"
msgstr "%s 存在且不是一个目录"

#: builtin/clone.c
#, c-format
msgid "'%s' is a symlink, refusing to clone with --local"
msgstr "'%s' 为符号链接，拒绝用 --local 克隆"

#: builtin/clone.c
#, c-format
msgid "failed to start iterator over '%s'"
msgstr "无法在 '%s' 上启动迭代器"

#: builtin/clone.c
#, c-format
msgid "symlink '%s' exists, refusing to clone with --local"
msgstr "符号链接 '%s' 存在，拒绝用 --local 克隆"

#: builtin/clone.c compat/precompose_utf8.c
#, c-format
msgid "failed to unlink '%s'"
msgstr "无法删除 '%s'"

#: builtin/clone.c
#, c-format
msgid "hardlink cannot be checked at '%s'"
msgstr "无法检查 '%s' 处的硬链接"

#: builtin/clone.c
#, c-format
msgid "hardlink different from source at '%s'"
msgstr "硬链接与 '%s' 处的来源不同"

#: builtin/clone.c
#, c-format
msgid "failed to create link '%s'"
msgstr "无法创建链接 '%s'"

#: builtin/clone.c
#, c-format
msgid "failed to copy file to '%s'"
msgstr "无法拷贝文件至 '%s'"

#: builtin/clone.c refs/files-backend.c
#, c-format
msgid "failed to iterate over '%s'"
msgstr "无法在 '%s' 上迭代"

#: builtin/clone.c
#, c-format
msgid "done.\n"
msgstr "完成。\n"

#: builtin/clone.c
msgid ""
"Clone succeeded, but checkout failed.\n"
"You can inspect what was checked out with 'git status'\n"
"and retry with 'git restore --source=HEAD :/'\n"
msgstr ""
"克隆成功，但是检出失败。\n"
"您可以通过 'git status' 检查哪些已被检出，然后使用命令\n"
"'git restore --source=HEAD :/' 重试\n"

#: builtin/clone.c fetch-pack.c
msgid "remote did not send all necessary objects"
msgstr "远程没有发送所有必需的对象"

#: builtin/clone.c
#, c-format
msgid "unable to update %s"
msgstr "不能更新 %s"

#: builtin/clone.c
msgid "failed to initialize sparse-checkout"
msgstr "无法初始化稀疏检出"

#: builtin/clone.c
msgid "remote HEAD refers to nonexistent ref, unable to checkout"
msgstr "远程 HEAD 指向一个不存在的引用，无法检出"

#: builtin/clone.c
msgid "unable to checkout working tree"
msgstr "不能检出工作区"

#: builtin/clone.c
msgid "unable to write parameters to config file"
msgstr "无法将参数写入配置文件"

#: builtin/clone.c
msgid "cannot repack to clean up"
msgstr "无法执行 repack 来清理"

#: builtin/clone.c
msgid "cannot unlink temporary alternates file"
msgstr "无法删除临时的备用文件"

#: builtin/clone.c
msgid "don't clone shallow repository"
msgstr "不克隆浅仓库"

#: builtin/clone.c
msgid "don't create a checkout"
msgstr "不创建一个检出"

#: builtin/clone.c builtin/init-db.c
msgid "create a bare repository"
msgstr "创建一个纯仓库"

#: builtin/clone.c
msgid "create a mirror repository (implies --bare)"
msgstr "创建一个镜像仓库（隐含 --bare）"

#: builtin/clone.c
msgid "to clone from a local repository"
msgstr "从本地仓库克隆"

#: builtin/clone.c
msgid "don't use local hardlinks, always copy"
msgstr "不使用本地硬链接，始终复制"

#: builtin/clone.c
msgid "setup as shared repository"
msgstr "设置为共享仓库"

#: builtin/clone.c
msgid "pathspec"
msgstr "路径规格"

#: builtin/clone.c
msgid "initialize submodules in the clone"
msgstr "在克隆时初始化子模组"

#: builtin/clone.c
msgid "number of submodules cloned in parallel"
msgstr "并发克隆的子模组的数量"

#: builtin/clone.c builtin/init-db.c
msgid "template-directory"
msgstr "模板目录"

#: builtin/clone.c builtin/init-db.c
msgid "directory from which templates will be used"
msgstr "模板目录将被使用"

#: builtin/clone.c builtin/submodule--helper.c
msgid "reference repository"
msgstr "参考仓库"

#: builtin/clone.c builtin/submodule--helper.c
msgid "use --reference only while cloning"
msgstr "仅在克隆时参考 --reference 指向的本地仓库"

#: builtin/clone.c builtin/column.c builtin/fmt-merge-msg.c builtin/init-db.c
#: builtin/merge-file.c builtin/merge.c builtin/pack-objects.c builtin/repack.c
#: builtin/submodule--helper.c t/helper/test-simple-ipc.c
msgid "name"
msgstr "名称"

#: builtin/clone.c
msgid "use <name> instead of 'origin' to track upstream"
msgstr "使用 <名称> 而不是 'origin' 去跟踪上游"

#: builtin/clone.c
msgid "checkout <branch> instead of the remote's HEAD"
msgstr "检出 <分支> 而不是远程 HEAD"

#: builtin/clone.c
msgid "clone single revision <rev> and check out"
msgstr "克隆单个版本 <版本> 并检出"

#: builtin/clone.c
msgid "path to git-upload-pack on the remote"
msgstr "远程 git-upload-pack 路径"

#: builtin/clone.c builtin/fetch.c builtin/pull.c
msgid "depth"
msgstr "深度"

#: builtin/clone.c
msgid "create a shallow clone of that depth"
msgstr "创建一个指定深度的浅克隆"

#: builtin/clone.c
msgid "create a shallow clone since a specific time"
msgstr "从一个特定时间创建一个浅克隆"

#: builtin/clone.c builtin/fetch.c builtin/pull.c
msgid "ref"
msgstr "引用"

#: builtin/clone.c builtin/fetch.c builtin/pull.c
msgid "deepen history of shallow clone, excluding ref"
msgstr "深化浅克隆的历史，除了给定的引用"

#: builtin/clone.c builtin/submodule--helper.c
msgid "clone only one branch, HEAD or --branch"
msgstr "只克隆一个分支、HEAD 或 --branch"

#: builtin/clone.c
msgid "clone tags, and make later fetches not to follow them"
msgstr "克隆标签，并在后续获取时不跟随它们"

#: builtin/clone.c
msgid "any cloned submodules will be shallow"
msgstr "子模组将以浅下载模式克隆"

#: builtin/clone.c builtin/init-db.c
msgid "gitdir"
msgstr "git目录"

#: builtin/clone.c builtin/init-db.c
msgid "separate git dir from working tree"
msgstr "git目录和工作区分离"

#: builtin/clone.c builtin/init-db.c builtin/submodule--helper.c
msgid "specify the reference format to use"
msgstr "指定要使用的引用格式"

#: builtin/clone.c
msgid "key=value"
msgstr "key=value"

#: builtin/clone.c
msgid "set config inside the new repository"
msgstr "在新仓库中设置配置信息"

#: builtin/clone.c builtin/fetch.c builtin/ls-remote.c builtin/pull.c
#: builtin/push.c builtin/send-pack.c
msgid "server-specific"
msgstr "server-specific"

#: builtin/clone.c builtin/fetch.c builtin/ls-remote.c builtin/pull.c
#: builtin/push.c builtin/send-pack.c
msgid "option to transmit"
msgstr "传输选项"

#: builtin/clone.c
msgid "apply partial clone filters to submodules"
msgstr "对子模组使用部分克隆过滤器"

#: builtin/clone.c
msgid "any cloned submodules will use their remote-tracking branch"
msgstr "任何克隆的子模组将使用它们的远程跟踪分支"

#: builtin/clone.c
msgid "initialize sparse-checkout file to include only files at root"
msgstr "初始化稀疏检出文件，只包含根目录文件"

#: builtin/clone.c
msgid "uri"
msgstr "uri"

#: builtin/clone.c
msgid "a URI for downloading bundles before fetching from origin remote"
msgstr "用于在从 origin 远程获取之前下载归档包的 URI"

#: builtin/clone.c
msgid "git clone [<options>] [--] <repo> [<dir>]"
msgstr "git clone [<选项>] [--] <仓库> [<目录>]"

#: builtin/clone.c
msgid "Too many arguments."
msgstr "太多参数。"

#: builtin/clone.c scalar.c
msgid "You must specify a repository to clone."
msgstr "您必须指定一个仓库来克隆。"

#: builtin/clone.c builtin/init-db.c builtin/refs.c builtin/submodule--helper.c
#: setup.c
#, c-format
msgid "unknown ref storage format '%s'"
msgstr "未知的引用存储格式 '%s'"

#: builtin/clone.c
#, c-format
msgid "repository '%s' does not exist"
msgstr "仓库 '%s' 不存在"

#: builtin/clone.c builtin/fetch.c
#, c-format
msgid "depth %s is not a positive number"
msgstr "深度 %s 不是一个正数"

#: builtin/clone.c
#, c-format
msgid "destination path '%s' already exists and is not an empty directory."
msgstr "目标路径 '%s' 已经存在，并且不是一个空目录。"

#: builtin/clone.c
#, c-format
msgid "repository path '%s' already exists and is not an empty directory."
msgstr "仓库路径 '%s' 已经存在，并且不是一个空目录。"

#: builtin/clone.c
#, c-format
msgid "working tree '%s' already exists."
msgstr "工作区 '%s' 已经存在。"

#: builtin/clone.c builtin/difftool.c builtin/log.c builtin/worktree.c
#, c-format
msgid "could not create leading directories of '%s'"
msgstr "不能为 '%s' 创建先导目录"

#: builtin/clone.c
#, c-format
msgid "could not create work tree dir '%s'"
msgstr "不能创建工作区目录 '%s'"

#: builtin/clone.c
#, c-format
msgid "Cloning into bare repository '%s'...\n"
msgstr "克隆到纯仓库 '%s'...\n"

#: builtin/clone.c
#, c-format
msgid "Cloning into '%s'...\n"
msgstr "正克隆到 '%s'...\n"

#: builtin/clone.c
msgid ""
"clone --recursive is not compatible with both --reference and --reference-if-"
"able"
msgstr "clone --recursive 和 --reference 以及 --reference-if-able 不兼容"

#: builtin/clone.c builtin/remote.c
#, c-format
msgid "'%s' is not a valid remote name"
msgstr "'%s' 不是一个有效的远程名称"

#: builtin/clone.c
msgid "--depth is ignored in local clones; use file:// instead."
msgstr "--depth 在本地克隆时被忽略，请改用 file:// 协议。"

#: builtin/clone.c
msgid "--shallow-since is ignored in local clones; use file:// instead."
msgstr "--shallow-since 在本地克隆时被忽略，请改用 file:// 协议。"

#: builtin/clone.c
msgid "--shallow-exclude is ignored in local clones; use file:// instead."
msgstr "--shallow-exclude 在本地克隆时被忽略，请改用 file:// 协议。"

#: builtin/clone.c
msgid "--filter is ignored in local clones; use file:// instead."
msgstr "--filter 在本地克隆时被忽略，请改用 file:// 协议。"

#: builtin/clone.c fetch-pack.c
msgid "source repository is shallow, reject to clone."
msgstr "源仓库是浅克隆，拒绝克隆。"

#: builtin/clone.c
msgid "source repository is shallow, ignoring --local"
msgstr "源仓库是浅克隆，忽略 --local"

#: builtin/clone.c
msgid "--local is ignored"
msgstr "--local 被忽略"

#: builtin/clone.c
msgid "cannot clone from filtered bundle"
msgstr "无法从经过过滤的归档包克隆"

#: builtin/clone.c
msgid "failed to initialize the repo, skipping bundle URI"
msgstr "无法初始化仓库，跳过归档包 URI"

#: builtin/clone.c
#, c-format
msgid "failed to fetch objects from bundle URI '%s'"
msgstr "无法从归档包 URI '%s' 获取对象"

#: builtin/clone.c
msgid "failed to fetch advertised bundles"
msgstr "无法获取公布的归档包"

#: builtin/clone.c
msgid "remote transport reported error"
msgstr "远程传输报告错误"

#: builtin/clone.c
#, c-format
msgid "Remote branch %s not found in upstream %s"
msgstr "远程分支 %s 在上游 %s 未发现"

#: builtin/clone.c
#, c-format
msgid "Remote revision %s not found in upstream %s"
msgstr "在上游 %2$s 未发现远程版本 %1$s"

#: builtin/clone.c
msgid "You appear to have cloned an empty repository."
msgstr "您似乎克隆了一个空仓库。"

#: builtin/column.c
msgid "git column [<options>]"
msgstr "git column [<选项>]"

#: builtin/column.c
msgid "lookup config vars"
msgstr "查找配置变量"

#: builtin/column.c
msgid "layout to use"
msgstr "要使用的布局"

#: builtin/column.c
msgid "maximum width"
msgstr "最大宽度"

#: builtin/column.c
msgid "padding space on left border"
msgstr "左边框的填充空间"

#: builtin/column.c
msgid "padding space on right border"
msgstr "右边框的填充空间"

#: builtin/column.c
msgid "padding space between columns"
msgstr "两列之间的填充空间"

#: builtin/column.c
#, c-format
msgid "%s must be non-negative"
msgstr "%s 必须为非负整数"

#: builtin/column.c
msgid "--command must be the first argument"
msgstr "--command 必须是第一个参数"

#: builtin/commit-graph.c
msgid ""
"git commit-graph verify [--object-dir <dir>] [--shallow] [--[no-]progress]"
msgstr ""
"git commit-graph verify [--object-dir <目录>] [--shallow] [--[no-]progress]"

#: builtin/commit-graph.c
msgid ""
"git commit-graph write [--object-dir <dir>] [--append]\n"
"                       [--split[=<strategy>]] [--reachable | --stdin-packs | "
"--stdin-commits]\n"
"                       [--changed-paths] [--[no-]max-new-filters <n>] [--"
"[no-]progress]\n"
"                       <split-options>"
msgstr ""
"git commit-graph write [--object-dir <目录>] [--append]\n"
"                       [--split[=<策略>]] [--reachable | --stdin-packs | --"
"stdin-commits] \n"
"                       [--changed-paths] [--[no-]max-new-filters <n>] [--"
"[no-]progress]\n"
"                       <切分选项>"

#: builtin/commit-graph.c builtin/fetch.c builtin/gc.c builtin/log.c
#: builtin/repack.c
msgid "dir"
msgstr "目录"

#: builtin/commit-graph.c
msgid "the object directory to store the graph"
msgstr "保存图形的对象目录"

#: builtin/commit-graph.c
msgid "if the commit-graph is split, only verify the tip file"
msgstr "如果提交图被拆分，只验证头一个文件"

#: builtin/commit-graph.c
#, c-format
msgid "Could not open commit-graph '%s'"
msgstr "无法打开提交图 '%s'"

#: builtin/commit-graph.c
#, c-format
msgid "could not open commit-graph chain '%s'"
msgstr "无法打开提交图链 '%s'"

#: builtin/commit-graph.c
#, c-format
msgid "unrecognized --split argument, %s"
msgstr "未能识别的 --split 参数，%s"

#: builtin/commit-graph.c
#, c-format
msgid "unexpected non-hex object ID: %s"
msgstr "意外的非十六进制对象 ID：%s"

#: builtin/commit-graph.c
#, c-format
msgid "invalid object: %s"
msgstr "无效对象：%s"

#: builtin/commit-graph.c parse-options-cb.c
#, c-format
msgid "option `%s' expects a numerical value"
msgstr "选项 `%s' 期望一个数字值"

#: builtin/commit-graph.c
msgid "start walk at all refs"
msgstr "开始遍历所有引用"

#: builtin/commit-graph.c
msgid "scan pack-indexes listed by stdin for commits"
msgstr "从标准输入中的包索引文件列表中扫描提交"

#: builtin/commit-graph.c
msgid "start walk at commits listed by stdin"
msgstr "从标准输入中的提交开始扫描"

#: builtin/commit-graph.c
msgid "include all commits already in the commit-graph file"
msgstr "包含 commit-graph 文件中已有所有提交"

#: builtin/commit-graph.c
msgid "enable computation for changed paths"
msgstr "启用变更路径的计算"

#: builtin/commit-graph.c
msgid "allow writing an incremental commit-graph file"
msgstr "允许写一个增量提交图文件"

#: builtin/commit-graph.c
msgid "maximum number of commits in a non-base split commit-graph"
msgstr "在非基本拆分提交图中的最大提交数"

#: builtin/commit-graph.c
msgid "maximum ratio between two levels of a split commit-graph"
msgstr "一个拆分提交图的两个级别之间的最大比率"

#: builtin/commit-graph.c
msgid "only expire files older than a given date-time"
msgstr "只让早于给定时间的文件过期"

#: builtin/commit-graph.c
msgid "maximum number of changed-path Bloom filters to compute"
msgstr "要计算的变更路径布隆过滤器的最大数"

#: builtin/commit-graph.c
msgid "use at most one of --reachable, --stdin-commits, or --stdin-packs"
msgstr "不能同时使用 --reachable、--stdin-commits 或 --stdin-packs"

#: builtin/commit-graph.c
msgid "Collecting commits from input"
msgstr "正从标准输入收集提交"

#: builtin/commit-tree.c
msgid "git commit-tree <tree> [(-p <parent>)...]"
msgstr "git commit-tree <树> [(-p <父提交>)...]"

#: builtin/commit-tree.c
msgid ""
"git commit-tree [(-p <parent>)...] [-S[<keyid>]] [(-m <message>)...]\n"
"                [(-F <file>)...] <tree>"
msgstr ""
"git commit-tree [(-p <父提交>)...] [-S[<私钥 ID>]] [(-m <消息>)...]\n"
"                [(-F <文件>)...] <树>"

#: builtin/commit-tree.c
#, c-format
msgid "duplicate parent %s ignored"
msgstr "忽略重复的父提交 %s"

#: builtin/commit-tree.c builtin/log.c
#, c-format
msgid "not a valid object name %s"
msgstr "不是一个有效的对象名 %s"

#: builtin/commit-tree.c
#, c-format
msgid "git commit-tree: failed to read '%s'"
msgstr "git commit-tree：无法读取 '%s'"

#: builtin/commit-tree.c
#, c-format
msgid "git commit-tree: failed to close '%s'"
msgstr "git commit-tree：无法关闭 '%s'"

#: builtin/commit-tree.c
msgid "parent"
msgstr "父提交"

#: builtin/commit-tree.c
msgid "id of a parent commit object"
msgstr "父提交对象 ID"

#: builtin/commit-tree.c builtin/commit.c builtin/merge.c builtin/notes.c
#: builtin/stash.c builtin/tag.c
msgid "message"
msgstr "说明"

#: builtin/commit-tree.c builtin/commit.c
msgid "commit message"
msgstr "提交说明"

#: builtin/commit-tree.c
msgid "read commit log message from file"
msgstr "从文件中读取提交说明"

#: builtin/commit-tree.c builtin/commit.c builtin/merge.c builtin/pull.c
#: builtin/revert.c
msgid "GPG sign commit"
msgstr "GPG 提交签名"

#: builtin/commit-tree.c
msgid "must give exactly one tree"
msgstr "必须精确地提供一个树"

#: builtin/commit-tree.c
msgid "git commit-tree: failed to read"
msgstr "git commit-tree：无法读取"

#: builtin/commit.c
msgid ""
"git commit [-a | --interactive | --patch] [-s] [-v] [-u[<mode>]] [--amend]\n"
"           [--dry-run] [(-c | -C | --squash) <commit> | --fixup [(amend|"
"reword):]<commit>]\n"
"           [-F <file> | -m <msg>] [--reset-author] [--allow-empty]\n"
"           [--allow-empty-message] [--no-verify] [-e] [--author=<author>]\n"
"           [--date=<date>] [--cleanup=<mode>] [--[no-]status]\n"
"           [-i | -o] [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"           [(--trailer <token>[(=|:)<value>])...] [-S[<keyid>]]\n"
"           [--] [<pathspec>...]"
msgstr ""
"git commit [-a | --interactive | --patch] [-s] [-v] [-u[<模式>]] [--amend]\n"
"           [--dry-run] [(-c | -C | --squash) <提交> | --fixup [(amend|"
"reword):]<提交>]\n"
"           [-F <文件> | -m <消息>] [--reset-author] [--allow-empty]\n"
"           [--allow-empty-message] [--no-verify] [-e] [--author=<作者>]\n"
"           [--date=<日期>] [--cleanup=<模式>] [--[no-]status]\n"
"           [-i | -o] [--pathspec-from-file=<文件> [--pathspec-file-nul]]\n"
"           [(--trailer <键>[(=|:)<值>])...] [-S[<私钥 ID>]]\n"
"           [--] [<路径规格>...]"

#: builtin/commit.c
msgid "git status [<options>] [--] [<pathspec>...]"
msgstr "git status [<选项>] [--] [<路径规格>...]"

#: builtin/commit.c
msgid ""
"You asked to amend the most recent commit, but doing so would make\n"
"it empty. You can repeat your command with --allow-empty, or you can\n"
"remove the commit entirely with \"git reset HEAD^\".\n"
msgstr ""
"您要修补最近的提交，但这么做会让它成为空提交。您可以重复您的命令并带上\n"
"--allow-empty 选项，或者您可用命令 \"git reset HEAD^\" 整个删除该提交。\n"

#: builtin/commit.c
msgid ""
"The previous cherry-pick is now empty, possibly due to conflict resolution.\n"
"If you wish to commit it anyway, use:\n"
"\n"
"    git commit --allow-empty\n"
"\n"
msgstr ""
"之前的拣选操作现在是一个空提交，可能是由冲突解决导致的。如果您无论如何\n"
"也要提交，使用命令：\n"
"\n"
"    git commit --allow-empty\n"
"\n"

#: builtin/commit.c
msgid "Otherwise, please use 'git rebase --skip'\n"
msgstr "否则，请使用 'git rebase --skip'\n"

#: builtin/commit.c
msgid "Otherwise, please use 'git cherry-pick --skip'\n"
msgstr "否则，请使用 'git cherry-pick --skip'\n"

#: builtin/commit.c
msgid ""
"and then use:\n"
"\n"
"    git cherry-pick --continue\n"
"\n"
"to resume cherry-picking the remaining commits.\n"
"If you wish to skip this commit, use:\n"
"\n"
"    git cherry-pick --skip\n"
"\n"
msgstr ""
"然后使用：\n"
"\n"
"    git cherry-pick --continue\n"
"\n"
"来继续拣选剩余提交。如果您想跳过此提交，使用：\n"
"\n"
"    git cherry-pick --skip\n"
"\n"

#: builtin/commit.c read-cache.c
msgid "updating files failed"
msgstr "更新文件失败"

#: builtin/commit.c
msgid "failed to unpack HEAD tree object"
msgstr "无法解包 HEAD 树对象"

#: builtin/commit.c
msgid "No paths with --include/--only does not make sense."
msgstr "参数 --include/--only 不跟路径没有意义。"

#: builtin/commit.c
msgid "unable to create temporary index"
msgstr "不能创建临时索引"

#: builtin/commit.c
msgid "interactive add failed"
msgstr "交互式添加失败"

#: builtin/commit.c
msgid "unable to update temporary index"
msgstr "无法更新临时索引"

#: builtin/commit.c
msgid "Failed to update main cache tree"
msgstr "不能更新树的主缓存"

#: builtin/commit.c
msgid "cannot do a partial commit during a merge."
msgstr "在合并过程中不能做部分提交。"

#: builtin/commit.c
msgid "cannot do a partial commit during a cherry-pick."
msgstr "在拣选过程中不能做部分提交。"

#: builtin/commit.c
msgid "cannot do a partial commit during a rebase."
msgstr "在变基过程中不能做部分提交。"

#: builtin/commit.c
msgid "cannot read the index"
msgstr "无法读取索引"

#: builtin/commit.c
msgid "unable to write temporary index file"
msgstr "无法写临时索引文件"

#: builtin/commit.c
#, c-format
msgid "commit '%s' lacks author header"
msgstr "提交 '%s' 缺少作者信息"

#: builtin/commit.c
#, c-format
msgid "commit '%s' has malformed author line"
msgstr "提交 '%s' 有格式错误的作者信息"

#: builtin/commit.c
msgid "malformed --author parameter"
msgstr "格式错误的 --author 参数"

#: builtin/commit.c ident.c
#, c-format
msgid "invalid date format: %s"
msgstr "无效的日期格式：%s"

#: builtin/commit.c
msgid ""
"unable to select a comment character that is not used\n"
"in the current commit message"
msgstr "无法选择一个未被当前提交说明使用的注释字符"

#: builtin/commit.c
#, c-format
msgid "could not lookup commit '%s'"
msgstr "不能查询提交 '%s'"

#: builtin/commit.c builtin/shortlog.c
#, c-format
msgid "(reading log message from standard input)\n"
msgstr "（正从标准输入中读取日志信息）\n"

#: builtin/commit.c
msgid "could not read log from standard input"
msgstr "不能从标准输入中读取日志信息"

#: builtin/commit.c
#, c-format
msgid "could not read log file '%s'"
msgstr "不能读取日志文件 '%s'"

#: builtin/commit.c
#, c-format
msgid "options '%s' and '%s:%s' cannot be used together"
msgstr "选项 '%s' 和 '%s:%s' 不能同时使用"

#: builtin/commit.c
msgid "could not read SQUASH_MSG"
msgstr "不能读取 SQUASH_MSG"

#: builtin/commit.c
msgid "could not read MERGE_MSG"
msgstr "不能读取 MERGE_MSG"

#: builtin/commit.c bundle.c rerere.c sequencer.c
#, c-format
msgid "could not open '%s'"
msgstr "不能打开 '%s'"

#: builtin/commit.c
msgid "could not write commit template"
msgstr "不能写提交模版"

#: builtin/commit.c
#, c-format
msgid ""
"Please enter the commit message for your changes. Lines starting\n"
"with '%s' will be ignored.\n"
msgstr "请为您的变更输入提交说明。以 '%s' 开始的行将被忽略。\n"

#: builtin/commit.c
#, c-format
msgid ""
"Please enter the commit message for your changes. Lines starting\n"
"with '%s' will be ignored, and an empty message aborts the commit.\n"
msgstr ""
"请为您的变更输入提交说明。以 '%s' 开始的行将被忽略，而一个空的提交\n"
"说明将会终止提交。\n"

#: builtin/commit.c
#, c-format
msgid ""
"Please enter the commit message for your changes. Lines starting\n"
"with '%s' will be kept; you may remove them yourself if you want to.\n"
msgstr ""
"请为您的变更输入提交说明。以 '%s' 开始的行将被保留，如果您愿意\n"
"也可以删除它们。\n"

#: builtin/commit.c
#, c-format
msgid ""
"Please enter the commit message for your changes. Lines starting\n"
"with '%s' will be kept; you may remove them yourself if you want to.\n"
"An empty message aborts the commit.\n"
msgstr ""
"请为您的变更输入提交说明。以 '%s' 开始的行将被保留，如果您愿意\n"
"也可以删除它们。一个空的提交说明将会终止提交。\n"

#: builtin/commit.c
msgid ""
"\n"
"It looks like you may be committing a merge.\n"
"If this is not correct, please run\n"
"\tgit update-ref -d MERGE_HEAD\n"
"and try again.\n"
msgstr ""
"\n"
"似乎您正在做一个合并提交。如果不对，请运行\n"
"\tgit update-ref -d MERGE_HEAD\n"
"然后重试。\n"

#: builtin/commit.c
msgid ""
"\n"
"It looks like you may be committing a cherry-pick.\n"
"If this is not correct, please run\n"
"\tgit update-ref -d CHERRY_PICK_HEAD\n"
"and try again.\n"
msgstr ""
"\n"
"似乎您正在做一个拣选提交。如果不对，请运行\n"
"\tgit update-ref -d CHERRY_PICK_HEAD\n"
"然后重试。\n"

#  译者：为保证在输出中对齐，注意调整句中空格！
#: builtin/commit.c
#, c-format
msgid "%sAuthor:    %.*s <%.*s>"
msgstr "%s作者：  %.*s <%.*s>"

#  译者：为保证在输出中对齐，注意调整句中空格！
#: builtin/commit.c
#, c-format
msgid "%sDate:      %s"
msgstr "%s日期：  %s"

#  译者：为保证在输出中对齐，注意调整句中空格！
#: builtin/commit.c
#, c-format
msgid "%sCommitter: %.*s <%.*s>"
msgstr "%s提交者：%.*s <%.*s>"

#: builtin/commit.c
msgid "Cannot read index"
msgstr "无法读取索引"

#: builtin/commit.c builtin/tag.c
msgid "unable to pass trailers to --trailers"
msgstr "无法将尾注传递给 --trailers"

#: builtin/commit.c
msgid "Error building trees"
msgstr "无法创建树对象"

#: builtin/commit.c builtin/tag.c
#, c-format
msgid "Please supply the message using either -m or -F option.\n"
msgstr "请使用 -m 或 -F 选项提供提交说明。\n"

#: builtin/commit.c
#, c-format
msgid "--author '%s' is not 'Name <email>' and matches no existing author"
msgstr "--author '%s' 不是 '姓名 <邮箱>' 格式，且未能在现有作者中找到匹配"

#: builtin/commit.c
#, c-format
msgid "Invalid ignored mode '%s'"
msgstr "无效的忽略模式 '%s'"

#: builtin/commit.c
#, c-format
msgid "Invalid untracked files mode '%s'"
msgstr "无效的未跟踪文件参数 '%s'"

#: builtin/commit.c
msgid "You are in the middle of a merge -- cannot reword."
msgstr "您正处于一个合并过程中 -- 无法改写说明。"

#: builtin/commit.c
msgid "You are in the middle of a cherry-pick -- cannot reword."
msgstr "您正处于一个拣选过程中 -- 无法改写说明。"

#: builtin/commit.c
#, c-format
msgid "reword option of '%s' and path '%s' cannot be used together"
msgstr "改写说明选项 '%s' 和路径 '%s' 不能同时使用"

#: builtin/commit.c
#, c-format
msgid "reword option of '%s' and '%s' cannot be used together"
msgstr "改写说明选项 '%s' 和 '%s' 不能同时使用"

#: builtin/commit.c
msgid "You have nothing to amend."
msgstr "您没有可修补的提交。"

#: builtin/commit.c
msgid "You are in the middle of a merge -- cannot amend."
msgstr "您正处于一个合并过程中 -- 无法修补提交。"

#: builtin/commit.c
msgid "You are in the middle of a cherry-pick -- cannot amend."
msgstr "您正处于一个拣选过程中 -- 无法修补提交。"

#: builtin/commit.c
msgid "You are in the middle of a rebase -- cannot amend."
msgstr "您正处于一个变基过程中 -- 无法修补提交。"

#: builtin/commit.c
msgid "--reset-author can be used only with -C, -c or --amend."
msgstr "--reset-author 只能和 -C、-c 或 --amend 同时使用。"

#: builtin/commit.c
#, c-format
msgid "unknown option: --fixup=%s:%s"
msgstr "未知选项：--fixup=%s:%s"

#: builtin/commit.c
#, c-format
msgid "paths '%s ...' with -a does not make sense"
msgstr "路径  '%s ...' 和 -a 选项同时使用没有意义"

#: builtin/commit.c
msgid "show status concisely"
msgstr "以简洁的格式显示状态"

#: builtin/commit.c
msgid "show branch information"
msgstr "显示分支信息"

#: builtin/commit.c
msgid "show stash information"
msgstr "显示贮藏区信息"

#: builtin/commit.c
msgid "compute full ahead/behind values"
msgstr "计算完整的领先/落后值"

#: builtin/commit.c
msgid "version"
msgstr "版本"

#: builtin/commit.c builtin/fetch.c builtin/push.c builtin/worktree.c
msgid "machine-readable output"
msgstr "机器可读的输出"

#: builtin/commit.c
msgid "show status in long format (default)"
msgstr "以长格式显示状态（默认）"

#: builtin/commit.c
msgid "terminate entries with NUL"
msgstr "条目以 NUL 字符结尾"

#: builtin/commit.c
msgid "show untracked files, optional modes: all, normal, no. (Default: all)"
msgstr "显示未跟踪的文件，“模式”的可选参数：all、normal、no。（默认：all）"

#: builtin/commit.c
msgid ""
"show ignored files, optional modes: traditional, matching, no. (Default: "
"traditional)"
msgstr ""
"显示已忽略的文件，可选模式：traditional、matching、no。（默认：traditional）"

#: builtin/commit.c parse-options.h
msgid "when"
msgstr "何时"

#: builtin/commit.c
msgid ""
"ignore changes to submodules, optional when: all, dirty, untracked. "
"(Default: all)"
msgstr ""
"忽略子模组的更改，“何时”的可选参数：all、dirty、untracked。（默认：all）"

#: builtin/commit.c
msgid "list untracked files in columns"
msgstr "以列的方式显示未跟踪的文件"

#: builtin/commit.c
msgid "do not detect renames"
msgstr "不检测重命名"

#: builtin/commit.c
msgid "detect renames, optionally set similarity index"
msgstr "检测重命名，可以设置索引相似度"

#: builtin/commit.c
msgid "Unsupported combination of ignored and untracked-files arguments"
msgstr "不支持已忽略和未跟踪文件参数的组合"

#: builtin/commit.c
msgid "suppress summary after successful commit"
msgstr "提交成功后不显示概述信息"

#: builtin/commit.c
msgid "show diff in commit message template"
msgstr "在提交说明模板里显示差异"

#: builtin/commit.c
msgid "Commit message options"
msgstr "提交说明选项"

#: builtin/commit.c builtin/merge.c builtin/tag.c
msgid "read message from file"
msgstr "从文件中读取提交说明"

#: builtin/commit.c
msgid "author"
msgstr "作者"

#: builtin/commit.c
msgid "override author for commit"
msgstr "提交时覆盖作者"

#: builtin/commit.c builtin/gc.c
msgid "date"
msgstr "日期"

#: builtin/commit.c
msgid "override date for commit"
msgstr "提交时覆盖日期"

#: builtin/commit.c parse-options.h ref-filter.h
msgid "commit"
msgstr "提交"

#: builtin/commit.c
msgid "reuse and edit message from specified commit"
msgstr "重用并编辑指定提交的提交说明"

#: builtin/commit.c
msgid "reuse message from specified commit"
msgstr "重用指定提交的提交说明"

#. TRANSLATORS: Leave "[(amend|reword):]" as-is,
#. and only translate <commit>.
#.
#: builtin/commit.c
msgid "[(amend|reword):]commit"
msgstr "[(amend|reword):]提交"

#: builtin/commit.c
msgid ""
"use autosquash formatted message to fixup or amend/reword specified commit"
msgstr "使用自动挤压格式的提交说明对指定的提交进行修正、修补或改写说明"

#: builtin/commit.c
msgid "use autosquash formatted message to squash specified commit"
msgstr "使用自动挤压格式的提交说明用以挤压至指定的提交"

#: builtin/commit.c
msgid "the commit is authored by me now (used with -C/-c/--amend)"
msgstr "现在将该提交的作者改为我（和 -C/-c/--amend 参数共用）"

#: builtin/commit.c builtin/interpret-trailers.c builtin/tag.c
msgid "trailer"
msgstr "尾注"

#: builtin/commit.c builtin/tag.c
msgid "add custom trailer(s)"
msgstr "添加自定义尾注"

#: builtin/commit.c builtin/log.c builtin/merge.c builtin/pull.c
#: builtin/revert.c
msgid "add a Signed-off-by trailer"
msgstr "添加 Signed-off-by 尾注"

#: builtin/commit.c
msgid "use specified template file"
msgstr "使用指定的模板文件"

#: builtin/commit.c
msgid "force edit of commit"
msgstr "强制编辑提交"

#: builtin/commit.c
msgid "include status in commit message template"
msgstr "在提交说明模板里包含状态信息"

#: builtin/commit.c
msgid "Commit contents options"
msgstr "提交内容选项"

#: builtin/commit.c
msgid "commit all changed files"
msgstr "提交所有改动的文件"

#: builtin/commit.c
msgid "add specified files to index for commit"
msgstr "添加指定的文件到索引区等待提交"

#: builtin/commit.c
msgid "interactively add files"
msgstr "交互式添加文件"

#: builtin/commit.c
msgid "interactively add changes"
msgstr "交互式添加变更"

#: builtin/commit.c
msgid "commit only specified files"
msgstr "只提交指定的文件"

#: builtin/commit.c
msgid "bypass pre-commit and commit-msg hooks"
msgstr "绕过 pre-commit 和 commit-msg 钩子"

#: builtin/commit.c
msgid "show what would be committed"
msgstr "显示将要提交的内容"

#: builtin/commit.c
msgid "amend previous commit"
msgstr "修改先前的提交"

#: builtin/commit.c
msgid "bypass post-rewrite hook"
msgstr "绕过 post-rewrite 钩子"

#: builtin/commit.c
msgid "ok to record an empty change"
msgstr "允许一个空提交"

#: builtin/commit.c
msgid "ok to record a change with an empty message"
msgstr "允许空的提交说明"

#: builtin/commit.c sequencer.c
msgid "could not parse HEAD commit"
msgstr "不能解析 HEAD 提交"

#: builtin/commit.c
#, c-format
msgid "Corrupt MERGE_HEAD file (%s)"
msgstr "损坏的 MERGE_HEAD 文件（%s）"

#: builtin/commit.c
msgid "could not read MERGE_MODE"
msgstr "不能读取 MERGE_MODE"

#: builtin/commit.c
#, c-format
msgid "could not read commit message: %s"
msgstr "不能读取提交说明：%s"

#: builtin/commit.c
#, c-format
msgid "Aborting commit due to empty commit message.\n"
msgstr "终止提交因为提交说明为空。\n"

#: builtin/commit.c
#, c-format
msgid "Aborting commit; you did not edit the message.\n"
msgstr "终止提交；您未更改来自模版的提交说明。\n"

#: builtin/commit.c
#, c-format
msgid "Aborting commit due to empty commit message body.\n"
msgstr "因提交说明的正文为空而终止提交。\n"

#: builtin/commit.c
msgid ""
"repository has been updated, but unable to write\n"
"new index file. Check that disk is not full and quota is\n"
"not exceeded, and then \"git restore --staged :/\" to recover."
msgstr ""
"仓库已更新，但无法写入索引文件。检查是否磁盘已满或\n"
"磁盘配额已耗尽，然后执行 \"git restore --staged :/\" 恢复。"

#: builtin/config.c
msgid "git config list [<file-option>] [<display-option>] [--includes]"
msgstr "git config list [<文件选项>] [<显示选项>] [--includes]"

#: builtin/config.c
msgid ""
"git config get [<file-option>] [<display-option>] [--includes] [--all] [--"
"regexp] [--value=<value>] [--fixed-value] [--default=<default>] <name>"
msgstr ""
"git config get [<文件选项>] [<显示选项>] [--includes] [--all] [--regexp] [--"
"value=<值>] [--fixed-value] [--default=<默认值>] <名称>"

#: builtin/config.c
msgid ""
"git config set [<file-option>] [--type=<type>] [--all] [--value=<value>] [--"
"fixed-value] <name> <value>"
msgstr ""
"git config set [<文件选项>] [--type=<类型>] [--all] [--value=<值>] [--fixed-"
"value] <名称> <值>"

#: builtin/config.c
msgid ""
"git config unset [<file-option>] [--all] [--value=<value>] [--fixed-value] "
"<name>"
msgstr ""
"git config unset [<文件选项>] [--all] [--value=<值>] [--fixed-value] <名称>"

#: builtin/config.c
msgid "git config rename-section [<file-option>] <old-name> <new-name>"
msgstr "git config rename-section [<文件选项>] <旧名称> <新名称>"

#: builtin/config.c
msgid "git config remove-section [<file-option>] <name>"
msgstr "git config remove-section [<文件选项>] <名称>"

#: builtin/config.c
msgid "git config edit [<file-option>]"
msgstr "git config edit [<文件选项>]"

#: builtin/config.c
msgid "git config [<file-option>] --get-colorbool <name> [<stdout-is-tty>]"
msgstr "git config [<文件选项>] --get-colorbool <名称> [<标准输出为tty>]"

#: builtin/config.c
msgid ""
"git config get [<file-option>] [<display-option>] [--includes] [--all] [--"
"regexp=<regexp>] [--value=<value>] [--fixed-value] [--default=<default>] "
"<name>"
msgstr ""
"git config get [<文件选项>] [<显示选项>] [--includes] [--all] [--regexp=<正则"
"表达式>] [--value=<值>] [--fixed-value] [--default=<默认值>] <名称>"

#: builtin/config.c
msgid ""
"git config set [<file-option>] [--type=<type>] [--comment=<message>] [--all] "
"[--value=<value>] [--fixed-value] <name> <value>"
msgstr ""
"git config set [<文件选项>] [--type=<类型>] [--comment=<消息>] [--all] [--"
"value=<值>] [--fixed-value] <名称> <值>"

#: builtin/config.c
msgid "Config file location"
msgstr "配置文件位置"

#: builtin/config.c
msgid "use global config file"
msgstr "使用全局配置文件"

#: builtin/config.c
msgid "use system config file"
msgstr "使用系统级配置文件"

#: builtin/config.c
msgid "use repository config file"
msgstr "使用仓库级配置文件"

#: builtin/config.c
msgid "use per-worktree config file"
msgstr "使用工作区级别的配置文件"

#: builtin/config.c builtin/gc.c
msgid "use given config file"
msgstr "使用指定的配置文件"

#: builtin/config.c
msgid "blob-id"
msgstr "数据对象 ID"

#: builtin/config.c
msgid "read config from given blob object"
msgstr "从给定的数据对象读取配置"

#: builtin/config.c
msgid "Type"
msgstr "类型"

#: builtin/config.c builtin/hash-object.c
msgid "type"
msgstr "类型"

#: builtin/config.c
msgid "value is given this type"
msgstr "取值为该类型"

#: builtin/config.c
msgid "value is \"true\" or \"false\""
msgstr "值是 \"true\" 或 \"false\""

#: builtin/config.c
msgid "value is decimal number"
msgstr "值是十进制数"

#: builtin/config.c
msgid "value is --bool or --int"
msgstr "值是 --bool 或 --int"

#: builtin/config.c
msgid "value is --bool or string"
msgstr "值是 --bool 或字符串"

#: builtin/config.c
msgid "value is a path (file or directory name)"
msgstr "值是一个路径（文件或目录名）"

#: builtin/config.c
msgid "value is an expiry date"
msgstr "值是一个到期日期"

#: builtin/config.c
msgid "Display options"
msgstr "显示选项"

#: builtin/config.c
msgid "terminate values with NUL byte"
msgstr "终止值是 NUL 字节"

#: builtin/config.c
msgid "show variable names only"
msgstr "只显示变量名"

#: builtin/config.c
msgid "show origin of config (file, standard input, blob, command line)"
msgstr "显示配置的来源（文件、标准输入、数据对象，或命令行）"

#: builtin/config.c
msgid "show scope of config (worktree, local, global, system, command)"
msgstr "显示配置的作用域（工作区、本地、全局、系统、命令）"

#: builtin/config.c
msgid "show config keys in addition to their values"
msgstr "显示配置键及其值"

#: builtin/config.c
#, c-format
msgid "unrecognized --type argument, %s"
msgstr "未能识别的 --type 参数，%s"

#: builtin/config.c
msgid "only one type at a time"
msgstr "一次只能一个类型"

#: builtin/config.c
#, c-format
msgid "wrong number of arguments, should be %d"
msgstr "错误的参数个数，应该为 %d 个"

#: builtin/config.c
#, c-format
msgid "wrong number of arguments, should be from %d to %d"
msgstr "错误的参数个数，应该为从 %d 个到 %d 个"

#: builtin/config.c
#, c-format
msgid "invalid key pattern: %s"
msgstr "无效键名模式：%s"

#: builtin/config.c config.c
#, c-format
msgid "invalid pattern: %s"
msgstr "无效模式：%s"

#: builtin/config.c
#, c-format
msgid "failed to format default config value: %s"
msgstr "无法格式化默认配置值：%s"

#: builtin/config.c
#, c-format
msgid "cannot parse color '%s'"
msgstr "无法解析颜色 '%s'"

#: builtin/config.c
msgid "unable to parse default color value"
msgstr "无法解析默认颜色值"

#: builtin/config.c
msgid "not in a git directory"
msgstr "不在 git 仓库中"

#: builtin/config.c
msgid "writing to stdin is not supported"
msgstr "不支持写到标准输入"

#: builtin/config.c
msgid "writing config blobs is not supported"
msgstr "不支持写到配置数据对象"

#: builtin/config.c
#, c-format
msgid ""
"# This is Git's per-user configuration file.\n"
"[user]\n"
"# Please adapt and uncomment the following lines:\n"
"#\tname = %s\n"
"#\temail = %s\n"
msgstr ""
"# This is Git's per-user configuration file.\n"
"[user]\n"
"# Please adapt and uncomment the following lines:\n"
"#\tname = %s\n"
"#\temail = %s\n"

#: builtin/config.c
msgid "only one config file at a time"
msgstr "一次只能有一个配置文件"

#: builtin/config.c
msgid "--local can only be used inside a git repository"
msgstr "--local 只能在 git 仓库内使用"

#: builtin/config.c
msgid "--blob can only be used inside a git repository"
msgstr "--blob 只能在 git 仓库内使用"

#: builtin/config.c
msgid "--worktree can only be used inside a git repository"
msgstr "--worktree 只能在 git 仓库内使用"

#: builtin/config.c builtin/gc.c
msgid "$HOME not set"
msgstr "$HOME 未设置"

#: builtin/config.c
msgid ""
"--worktree cannot be used with multiple working trees unless the config\n"
"extension worktreeConfig is enabled. Please read \"CONFIGURATION FILE\"\n"
"section in \"git help worktree\" for details"
msgstr ""
"不能和多个工作区一起使用 --worktree，除非启用 worktreeConfig 配置扩展。\n"
"详情请阅读“git help worktree”的“CONFIGURATION FILE”小节"

#: builtin/config.c
msgid "Other"
msgstr "其它"

#: builtin/config.c
msgid "respect include directives on lookup"
msgstr "查询时参照 include 指令递归查找"

#: builtin/config.c
#, c-format
msgid "unable to read config file '%s'"
msgstr "无法读取配置文件 '%s'"

#: builtin/config.c
msgid "error processing config file(s)"
msgstr "处理配置文件出错"

#: builtin/config.c
msgid "Filter options"
msgstr "过滤选项"

#: builtin/config.c
msgid "return all values for multi-valued config options"
msgstr "返回多值配置选项的所有值"

#: builtin/config.c
msgid "interpret the name as a regular expression"
msgstr "将名称解释为正则表达式"

#: builtin/config.c
msgid "show config with values matching the pattern"
msgstr "显示值与模式匹配的配置"

#: builtin/config.c
msgid "use string equality when comparing values to value pattern"
msgstr "在将值与值模式进行比较时使用字符串相等性"

#: builtin/config.c
msgid "URL"
msgstr "URL"

#: builtin/config.c
msgid "show config matching the given URL"
msgstr "显示与给定 URL 匹配的配置"

#: builtin/config.c
msgid "value"
msgstr "值"

#: builtin/config.c
msgid "use default value when missing entry"
msgstr "缺少条目时使用默认值"

#: builtin/config.c
msgid "--fixed-value only applies with 'value-pattern'"
msgstr "--fixed-value 仅适用于有 '值模式'"

#: builtin/config.c
msgid "--default= cannot be used with --all or --url="
msgstr "--default= 不能与 --all 或 --url= 一起使用"

#: builtin/config.c
msgid "--url= cannot be used with --all, --regexp or --value"
msgstr "--url= 不能与 --all、--regexp 或 --value 一起使用"

#: builtin/config.c
msgid "Filter"
msgstr "过滤器"

#: builtin/config.c
msgid "replace multi-valued config option with new value"
msgstr "将多值配置选项替换为新值"

#: builtin/config.c
msgid "human-readable comment string (# will be prepended as needed)"
msgstr "人类可读的注释字符串（# 将根据需要添加到前面）"

#: builtin/config.c
msgid "add a new line without altering any existing values"
msgstr "添加新行而不更改任何现有值"

#: builtin/config.c
msgid "--fixed-value only applies with --value=<pattern>"
msgstr "--fixed-value 只能与 --value=<模式> 配合使用"

#: builtin/config.c
msgid "--append cannot be used with --value=<pattern>"
msgstr "--append 不能与 --value=<模式> 一起使用"

#: builtin/config.c
#, c-format
msgid ""
"cannot overwrite multiple values with a single value\n"
"       Use a regexp, --add or --replace-all to change %s."
msgstr ""
"无法用一个值覆盖多个值\n"
"       使用一个正则表达式、--add 或 --replace-all 来修改 %s。"

#: builtin/config.c
#, c-format
msgid "no such section: %s"
msgstr "无此小节：%s"

#: builtin/config.c
msgid "editing stdin is not supported"
msgstr "不支持编辑标准输入"

#: builtin/config.c
msgid "editing blobs is not supported"
msgstr "不支持编辑数据对象"

#: builtin/config.c
#, c-format
msgid "cannot create configuration file %s"
msgstr "不能创建配置文件 %s"

#: builtin/config.c
msgid "Action"
msgstr "操作"

#: builtin/config.c
msgid "get value: name [<value-pattern>]"
msgstr "获取值：name [<值模式>]"

#: builtin/config.c
msgid "get all values: key [<value-pattern>]"
msgstr "获取所有值：key [<值模式>]"

#: builtin/config.c
msgid "get values for regexp: name-regex [<value-pattern>]"
msgstr "获取正则表达式的值：name-regex [<值模式>]"

#: builtin/config.c
msgid "get value specific for the URL: section[.var] URL"
msgstr "获得 URL 取值：section[.var] URL"

#: builtin/config.c
msgid "replace all matching variables: name value [<value-pattern>]"
msgstr "替换所有匹配的变量：name value [<值模式>]"

#: builtin/config.c
msgid "add a new variable: name value"
msgstr "添加一个新的变量：名称 值"

#: builtin/config.c
msgid "remove a variable: name [<value-pattern>]"
msgstr "删除一个变量：名称 [<值模式>]"

#: builtin/config.c
msgid "remove all matches: name [<value-pattern>]"
msgstr "删除所有匹配项：名称 [<值模式>]"

#: builtin/config.c
msgid "rename section: old-name new-name"
msgstr "重命名小节：old-name new-name"

#: builtin/config.c
msgid "remove a section: name"
msgstr "删除一个小节：name"

#: builtin/config.c
msgid "list all"
msgstr "列出所有"

#: builtin/config.c
msgid "open an editor"
msgstr "打开编辑器"

#: builtin/config.c
msgid "find the color configured: slot [<default>]"
msgstr "找到配置的颜色：slot [<默认>]"

#: builtin/config.c
msgid "find the color setting: slot [<stdout-is-tty>]"
msgstr "找到颜色设置：slot [<stdout-is-tty>]"

#: builtin/config.c
msgid "with --get, use default value when missing entry"
msgstr "使用 --get 参数，当缺少设置时使用默认值"

#: builtin/config.c
msgid "--get-color and variable type are incoherent"
msgstr "--get-color 和变量类型不兼容"

#: builtin/config.c
msgid "no action specified"
msgstr "未指定任何操作"

#: builtin/config.c
msgid "--name-only is only applicable to --list or --get-regexp"
msgstr "--name-only 仅适用于 --list 或 --get-regexp"

#: builtin/config.c
msgid ""
"--show-origin is only applicable to --get, --get-all, --get-regexp, and --"
"list"
msgstr "--show-origin 仅适用于 --get、--get-all、--get-regexp 和 --list"

#: builtin/config.c
msgid "--default is only applicable to --get"
msgstr "--default 仅适用于 --get"

#: builtin/config.c
msgid "--comment is only applicable to add/set/replace operations"
msgstr "--comment 仅适用于 add/set/replace 操作"

#: builtin/count-objects.c
msgid "print sizes in human readable format"
msgstr "以用户可读的格式显示大小"

#: builtin/credential-cache--daemon.c
#, c-format
msgid ""
"The permissions on your socket directory are too loose; other\n"
"users may be able to read your cached credentials. Consider running:\n"
"\n"
"\tchmod 0700 %s"
msgstr ""
"您的 socket 目录权限过于宽松，其他用户可能会读取您缓存的认证信息。考虑执"
"行：\n"
"\n"
"\tchmod 0700 %s"

#: builtin/credential-cache--daemon.c
msgid "print debugging messages to stderr"
msgstr "输出调试信息到标准错误"

#: builtin/credential-cache--daemon.c
msgid "credential-cache--daemon unavailable; no unix socket support"
msgstr "credential-cache--daemon 不可用，不支持 unix 套接字"

#: builtin/credential-cache.c
msgid "credential-cache unavailable; no unix socket support"
msgstr "credential-cache 不可用，不支持 unix 套接字"

#: builtin/credential-store.c
#, c-format
msgid "unable to get credential storage lock in %d ms"
msgstr "无法在 %d ms 获得凭证存储锁"

#: builtin/describe.c
msgid ""
"git describe [--all] [--tags] [--contains] [--abbrev=<n>] [<commit-ish>...]"
msgstr ""
"git describe [--all] [--tags] [--contains] [--abbrev=<n>] [<提交号>...]"

#: builtin/describe.c
msgid ""
"git describe [--all] [--tags] [--contains] [--abbrev=<n>] --dirty[=<mark>]"
msgstr ""
"git describe [--all] [--tags] [--contains] [--abbrev=<n>] --dirty[=<标记>]"

#: builtin/describe.c
msgid "git describe <blob>"
msgstr "git describe <数据对象>"

#: builtin/describe.c
msgid "head"
msgstr "头"

#: builtin/describe.c
msgid "lightweight"
msgstr "轻量级的"

#: builtin/describe.c
msgid "annotated"
msgstr "附注的"

#: builtin/describe.c
#, c-format
msgid "annotated tag %s not available"
msgstr "附注标签 %s 无效"

#: builtin/describe.c
#, c-format
msgid "tag '%s' is externally known as '%s'"
msgstr "标签 '%s' 在外部被认为是 '%s'"

#: builtin/describe.c
#, c-format
msgid "no tag exactly matches '%s'"
msgstr "没有标签准确匹配 '%s'"

#: builtin/describe.c
#, c-format
msgid "No exact match on refs or tags, searching to describe\n"
msgstr "没有精确匹配到引用或标签，继续搜索进行描述\n"

#: builtin/describe.c
#, c-format
msgid "finished search at %s\n"
msgstr "完成搜索 %s\n"

#: builtin/describe.c
#, c-format
msgid ""
"No annotated tags can describe '%s'.\n"
"However, there were unannotated tags: try --tags."
msgstr ""
"没有附注标签能描述 '%s'。\n"
"然而，存在未附注标签：尝试 --tags。"

#: builtin/describe.c
#, c-format
msgid ""
"No tags can describe '%s'.\n"
"Try --always, or create some tags."
msgstr ""
"没有标签能描述 '%s'。\n"
"尝试 --always，或者创建一些标签。"

#: builtin/describe.c
#, c-format
msgid "traversed %lu commits\n"
msgstr "已遍历 %lu 个提交\n"

#: builtin/describe.c
#, c-format
msgid "found %i tags; gave up search at %s\n"
msgstr "找到 %i 个标签；在 %s 处放弃搜索\n"

#: builtin/describe.c
#, c-format
msgid "describe %s\n"
msgstr "描述 %s\n"

#: builtin/describe.c
#, c-format
msgid "Not a valid object name %s"
msgstr "不是一个有效的对象名 %s"

#: builtin/describe.c
#, c-format
msgid "%s is neither a commit nor blob"
msgstr "%s 既不是提交也不是数据对象"

#: builtin/describe.c
msgid "find the tag that comes after the commit"
msgstr "寻找该提交之后的标签"

#: builtin/describe.c
msgid "debug search strategy on stderr"
msgstr "在标准错误上调试搜索策略"

#: builtin/describe.c
msgid "use any ref"
msgstr "使用任意引用"

#: builtin/describe.c
msgid "use any tag, even unannotated"
msgstr "使用任意标签，即使未附带注释"

#: builtin/describe.c
msgid "always use long format"
msgstr "始终使用长提交号格式"

#: builtin/describe.c
msgid "only follow first parent"
msgstr "只跟随第一个父提交"

#: builtin/describe.c
msgid "only output exact matches"
msgstr "只输出精确匹配"

#: builtin/describe.c
msgid "consider <n> most recent tags (default: 10)"
msgstr "考虑最近 <n> 个标签（默认：10）"

#: builtin/describe.c
msgid "only consider tags matching <pattern>"
msgstr "只考虑匹配 <模式> 的标签"

#: builtin/describe.c
msgid "do not consider tags matching <pattern>"
msgstr "不考虑匹配 <模式> 的标签"

#: builtin/describe.c builtin/name-rev.c
msgid "show abbreviated commit object as fallback"
msgstr "显示简写的提交号作为后备"

#: builtin/describe.c
msgid "mark"
msgstr "标记"

#: builtin/describe.c
msgid "append <mark> on dirty working tree (default: \"-dirty\")"
msgstr "对于脏工作区，追加 <标记>（默认：\"-dirty\"）"

#: builtin/describe.c
msgid "append <mark> on broken working tree (default: \"-broken\")"
msgstr "对于损坏的工作区，追加 <标记>（默认：\"-broken\"）"

#: builtin/describe.c
msgid "No names found, cannot describe anything."
msgstr "没有发现名称，无法描述任何东西。"

#: builtin/describe.c
#, c-format
msgid "option '%s' and commit-ishes cannot be used together"
msgstr "选项 '%s' 和提交号不能同时使用"

#: builtin/diagnose.c
msgid ""
"git diagnose [(-o | --output-directory) <path>] [(-s | --suffix) <format>]\n"
"             [--mode=<mode>]"
msgstr ""
"git diagnose [(-o | --output-directory) <路径>] [(-s | --suffix) <格式>]\n"
"             [--mode=<模式>]"

#: builtin/diagnose.c
msgid "specify a destination for the diagnostics archive"
msgstr "指定诊断归档包的目标位置"

#: builtin/diagnose.c
msgid "specify a strftime format suffix for the filename"
msgstr "指定文件的 strftime 格式后缀"

#: builtin/diagnose.c
msgid "specify the content of the diagnostic archive"
msgstr "指定诊断信息归档包的内容"

#: builtin/diff-tree.c
msgid "--merge-base only works with two commits"
msgstr "--merge-base 仅适用于两个提交"

#: builtin/diff.c
#, c-format
msgid "'%s': not a regular file or symlink"
msgstr "'%s'：不是一个普通文件或符号链接"

#: builtin/diff.c
msgid "no merge given, only parents."
msgstr "没有给出合并，只有父提交。"

#: builtin/diff.c
#, c-format
msgid "invalid option: %s"
msgstr "无效选项：%s"

#: builtin/diff.c
#, c-format
msgid "%s...%s: no merge base"
msgstr "%s...%s：无合并基线"

#: builtin/diff.c
msgid "Not a git repository"
msgstr "不是 git 仓库"

#: builtin/diff.c builtin/grep.c
#, c-format
msgid "invalid object '%s' given."
msgstr "提供了无效对象 '%s'。"

#: builtin/diff.c
#, c-format
msgid "more than two blobs given: '%s'"
msgstr "提供了超过两个数据对象：'%s'"

#: builtin/diff.c
#, c-format
msgid "unhandled object '%s' given."
msgstr "无法处理的对象 '%s'。"

#: builtin/diff.c
#, c-format
msgid "%s...%s: multiple merge bases, using %s"
msgstr "%s...%s：多条合并基线，使用 %s"

#: builtin/difftool.c
msgid "git difftool [<options>] [<commit> [<commit>]] [--] [<path>...]"
msgstr "git difftool [<选项>] [<提交> [<提交>]] [--] [<路径>...]"

#: builtin/difftool.c
#, c-format
msgid "could not read symlink %s"
msgstr "无法读取符号链接 %s"

#: builtin/difftool.c
#, c-format
msgid "could not read symlink file %s"
msgstr "无法读取符号链接文件 %s"

#: builtin/difftool.c
#, c-format
msgid "could not read object %s for symlink %s"
msgstr "无法读取符号链接 %2$s 指向的对象 %1$s"

#: builtin/difftool.c
msgid ""
"combined diff formats ('-c' and '--cc') are not supported in\n"
"directory diff mode ('-d' and '--dir-diff')."
msgstr ""
"不支持在目录比较模式（'-d' 和 '--dir-diff'）中采用组合差异格式（'-c' 和 '--"
"cc'）。"

#: builtin/difftool.c
#, c-format
msgid "both files modified: '%s' and '%s'."
msgstr "两个文件都被修改：'%s' 和 '%s'。"

#: builtin/difftool.c
msgid "working tree file has been left."
msgstr "工作区文件被留了下来。"

#: builtin/difftool.c sequencer.c
#, c-format
msgid "could not copy '%s' to '%s'"
msgstr "不能拷贝 '%s' 至 '%s'"

#: builtin/difftool.c
#, c-format
msgid "temporary files exist in '%s'."
msgstr "临时文件存在于 '%s'。"

#: builtin/difftool.c
msgid "you may want to cleanup or recover these."
msgstr "您可能想要清理或者恢复它们。"

#: builtin/difftool.c
#, c-format
msgid "failed: %d"
msgstr "失败：%d"

#: builtin/difftool.c
msgid "use `diff.guitool` instead of `diff.tool`"
msgstr "使用 `diff.guitool` 代替 `diff.tool`"

#: builtin/difftool.c
msgid "perform a full-directory diff"
msgstr "执行一个全目录差异比较"

#: builtin/difftool.c
msgid "do not prompt before launching a diff tool"
msgstr "启动差异比较工具之前不提示"

#: builtin/difftool.c
msgid "use symlinks in dir-diff mode"
msgstr "在 dir-diff 模式中使用符号链接"

#: builtin/difftool.c
msgid "tool"
msgstr "工具"

#: builtin/difftool.c
msgid "use the specified diff tool"
msgstr "使用指定的差异比较工具"

#: builtin/difftool.c
msgid "print a list of diff tools that may be used with `--tool`"
msgstr "显示可以用在 `--tool` 参数后的差异工具列表"

#: builtin/difftool.c
msgid ""
"make 'git-difftool' exit when an invoked diff tool returns a non-zero exit "
"code"
msgstr "当执行的 diff 工具返回非零退出码时，使 'git-difftool' 退出"

#: builtin/difftool.c
msgid "specify a custom command for viewing diffs"
msgstr "指定一个用于查看差异的自定义命令"

#: builtin/difftool.c
msgid "passed to `diff`"
msgstr "传递给 `diff`"

#: builtin/difftool.c
msgid "difftool requires worktree or --no-index"
msgstr "difftool 要求工作区或者 --no-index"

#: builtin/difftool.c
msgid "no <tool> given for --tool=<tool>"
msgstr "没有为 --tool=<工具> 参数提供 <工具>"

#: builtin/difftool.c
msgid "no <cmd> given for --extcmd=<cmd>"
msgstr "没有为 --extcmd=<命令> 参数提供 <命令>"

#: builtin/fast-export.c
msgid "git fast-export [<rev-list-opts>]"
msgstr "git fast-export [<rev-list 选项>]"

#: builtin/fast-export.c
msgid "Error: Cannot export nested tags unless --mark-tags is specified."
msgstr "错误：除非指定 --mark-tags，否则无法导出嵌套标签。"

#: builtin/fast-export.c
msgid "--anonymize-map token cannot be empty"
msgstr "--anonymize-map 取值不能为空"

#: builtin/fast-export.c
msgid "show progress after <n> objects"
msgstr "在 <n> 个对象之后显示进度"

#: builtin/fast-export.c
msgid "select handling of signed tags"
msgstr "选择如何处理签名标签"

#: builtin/fast-export.c
msgid "select handling of tags that tag filtered objects"
msgstr "选择当标签指向被过滤对象时该标签的处理方式"

#: builtin/fast-export.c
msgid "select handling of commit messages in an alternate encoding"
msgstr "选择使用备用编码处理提交说明"

#: builtin/fast-export.c
msgid "dump marks to this file"
msgstr "把标记存储到这个文件"

#: builtin/fast-export.c
msgid "import marks from this file"
msgstr "从这个文件导入标记"

#: builtin/fast-export.c
msgid "import marks from this file if it exists"
msgstr "如果文件存在，从该文件导入标记"

#: builtin/fast-export.c
msgid "fake a tagger when tags lack one"
msgstr "当标签缺少标记人字段时，假装提供一个"

#: builtin/fast-export.c
msgid "output full tree for each commit"
msgstr "每次提交都输出整个树"

#: builtin/fast-export.c
msgid "use the done feature to terminate the stream"
msgstr "使用 done 功能来终止流"

#: builtin/fast-export.c
msgid "skip output of blob data"
msgstr "跳过数据对象的输出"

#: builtin/fast-export.c builtin/log.c
msgid "refspec"
msgstr "引用规格"

#: builtin/fast-export.c
msgid "apply refspec to exported refs"
msgstr "对导出的引用应用引用规格"

#: builtin/fast-export.c
msgid "anonymize output"
msgstr "匿名输出"

#: builtin/fast-export.c
msgid "from:to"
msgstr "from:to"

#: builtin/fast-export.c
msgid "convert <from> to <to> in anonymized output"
msgstr "在匿名输出中将 <from> 转换为 <to>"

#: builtin/fast-export.c
msgid "reference parents which are not in fast-export stream by object id"
msgstr "引用父对象 ID 不在 fast-export 流中"

#: builtin/fast-export.c
msgid "show original object ids of blobs/commits"
msgstr "显示数据对象/提交的原始对象 ID"

#: builtin/fast-export.c
msgid "label tags with mark ids"
msgstr "对带有标记 ID 的标签做标记"

#: builtin/fast-import.c
#, c-format
msgid "Missing from marks for submodule '%s'"
msgstr "子模组 '%s' 缺少 from 标记"

#: builtin/fast-import.c
#, c-format
msgid "Missing to marks for submodule '%s'"
msgstr "子模组 '%s' 缺少 to 标记"

#: builtin/fast-import.c
#, c-format
msgid "Expected 'mark' command, got %s"
msgstr "预期 'mark' 命令，得到 %s"

#: builtin/fast-import.c
#, c-format
msgid "Expected 'to' command, got %s"
msgstr "预期 'to' 命令，得到 %s"

#: builtin/fast-import.c
msgid "Expected format name:filename for submodule rewrite option"
msgstr "子模组重写选项的预期格式为 name:filename"

#: builtin/fast-import.c
#, c-format
msgid "feature '%s' forbidden in input without --allow-unsafe-features"
msgstr "不带 --allow-unsafe-features 的输入中禁止使用功能 '%s'"

#: builtin/fetch-pack.c
#, c-format
msgid "Lockfile created but not reported: %s"
msgstr "Lockfile 已创建但未报告：%s"

#: builtin/fetch.c
msgid "git fetch [<options>] [<repository> [<refspec>...]]"
msgstr "git fetch [<选项>] [<仓库> [<引用规格>...]]"

#: builtin/fetch.c
msgid "git fetch [<options>] <group>"
msgstr "git fetch [<选项>] <组>"

#: builtin/fetch.c
msgid "git fetch --multiple [<options>] [(<repository> | <group>)...]"
msgstr "git fetch --multiple [<选项>] [(<仓库> | <组>)...]"

#: builtin/fetch.c
msgid "git fetch --all [<options>]"
msgstr "git fetch --all [<选项>]"

#: builtin/fetch.c
msgid "fetch.parallel cannot be negative"
msgstr "fetch.parallel 不能为负数"

#: builtin/fetch.c
msgid "couldn't find remote ref HEAD"
msgstr "无法发现远程 HEAD 引用"

#: builtin/fetch.c
#, c-format
msgid "From %.*s\n"
msgstr "来自 %.*s\n"

#: builtin/fetch.c
#, c-format
msgid "object %s not found"
msgstr "对象 %s 未发现"

#: builtin/fetch.c
msgid "[up to date]"
msgstr "[最新]"

#: builtin/fetch.c
msgid "[rejected]"
msgstr "[已拒绝]"

#: builtin/fetch.c
msgid "can't fetch into checked-out branch"
msgstr "无法获取到已检出的分支"

#: builtin/fetch.c
msgid "[tag update]"
msgstr "[标签更新]"

#: builtin/fetch.c
msgid "unable to update local ref"
msgstr "不能更新本地引用"

#: builtin/fetch.c
msgid "would clobber existing tag"
msgstr "会破坏现有的标签"

#: builtin/fetch.c
msgid "[new tag]"
msgstr "[新标签]"

#: builtin/fetch.c
msgid "[new branch]"
msgstr "[新分支]"

#: builtin/fetch.c
msgid "[new ref]"
msgstr "[新引用]"

#: builtin/fetch.c
msgid "forced update"
msgstr "强制更新"

#: builtin/fetch.c
msgid "non-fast-forward"
msgstr "非快进"

#: builtin/fetch.c builtin/grep.c sequencer.c
#, c-format
msgid "cannot open '%s'"
msgstr "不能打开 '%s'"

#: builtin/fetch.c
msgid ""
"fetch normally indicates which branches had a forced update,\n"
"but that check has been disabled; to re-enable, use '--show-forced-updates'\n"
"flag or run 'git config fetch.showForcedUpdates true'"
msgstr ""
"获取操作通常显示哪些分支发生了强制更新，但该检查已被禁用；\n"
"要重新启用，请使用 '--show-forced-updates' 选项或运行\n"
"'git config fetch.showForcedUpdates true'"

#: builtin/fetch.c
#, c-format
msgid ""
"it took %.2f seconds to check forced updates; you can use\n"
"'--no-show-forced-updates' or run 'git config fetch.showForcedUpdates "
"false'\n"
"to avoid this check\n"
msgstr ""
"花了 %.2f 秒来检查强制更新；您可以使用 '--no-show-forced-updates'\n"
"或运行 'git config fetch.showForcedUpdates false' 以避免此项检查\n"

#: builtin/fetch.c
#, c-format
msgid "%s did not send all necessary objects"
msgstr "%s 未发送所有必需的对象"

#: builtin/fetch.c
#, c-format
msgid "rejected %s because shallow roots are not allowed to be updated"
msgstr "拒绝 %s 因为浅克隆的根不允许被更新"

#: builtin/fetch.c
#, c-format
msgid ""
"some local refs could not be updated; try running\n"
" 'git remote prune %s' to remove any old, conflicting branches"
msgstr ""
"一些本地引用不能被更新；尝试运行\n"
" 'git remote prune %s' 来删除旧的、有冲突的分支"

#  译者：注意保持前导空格
#: builtin/fetch.c
#, c-format
msgid "   (%s will become dangling)"
msgstr "   （%s 将成为悬空状态）"

#  译者：注意保持前导空格
#: builtin/fetch.c
#, c-format
msgid "   (%s has become dangling)"
msgstr "   （%s 已成为悬空状态）"

#: builtin/fetch.c
msgid "[deleted]"
msgstr "[已删除]"

#: builtin/fetch.c builtin/remote.c
msgid "(none)"
msgstr "（无）"

#: builtin/fetch.c
#, c-format
msgid "refusing to fetch into branch '%s' checked out at '%s'"
msgstr "拒绝获取于 '%2$s' 检出的分支 '%1$s'"

#: builtin/fetch.c
#, c-format
msgid "option \"%s\" value \"%s\" is not valid for %s"
msgstr "选项 \"%s\" 的值 \"%s\" 对于 %s 是无效的"

#: builtin/fetch.c
#, c-format
msgid "option \"%s\" is ignored for %s"
msgstr "选项 \"%s\" 为 %s 所忽略"

#: builtin/fetch.c object-file.c
#, c-format
msgid "%s is not a valid object"
msgstr "%s 不是一个有效的对象"

#: builtin/fetch.c
#, c-format
msgid "the object %s does not exist"
msgstr "对象 '%s' 不存在"

#: builtin/fetch.c
#, c-format
msgid ""
"Run 'git remote set-head %s %s' to follow the change, or set\n"
"'remote.%s.followRemoteHEAD' configuration option to a different value\n"
"if you do not want to see this message. Specifically running\n"
"'git config set remote.%s.followRemoteHEAD warn-if-not-branch-%s'\n"
"will disable the warning until the remote changes HEAD to something else."
msgstr ""
"运行 'git remote set-head %s %s' 同步变更，或通过配置选项\n"
"'remote.%s.followRemoteHEAD' 设置为其他值以屏蔽此提示。具体可通过\n"
"运行命令 'git config remote.%s.followRemoteHEAD warn-if-not-branch-%s'\n"
"以禁用该警告，直到远程将 HEAD 更改为其他内容。"

#: builtin/fetch.c
msgid "multiple branches detected, incompatible with --set-upstream"
msgstr "检测到多分支，和 --set-upstream 不兼容"

#: builtin/fetch.c
#, c-format
msgid ""
"could not set upstream of HEAD to '%s' from '%s' when it does not point to "
"any branch."
msgstr "无法在不指向任何分支时将 HEAD 的上游从 '%s' 设置为 '%s'。"

#: builtin/fetch.c
msgid "not setting upstream for a remote remote-tracking branch"
msgstr "没有为一个远程跟踪分支设置上游"

#: builtin/fetch.c
msgid "not setting upstream for a remote tag"
msgstr "没有为一个远程标签设置上游"

#: builtin/fetch.c
msgid "unknown branch type"
msgstr "未知的分支类型"

#: builtin/fetch.c
msgid ""
"no source branch found;\n"
"you need to specify exactly one branch with the --set-upstream option"
msgstr ""
"未发现源分支；\n"
"您需要使用 --set-upstream 选项指定一个分支"

#: builtin/fetch.c
#, c-format
msgid "Fetching %s\n"
msgstr "正在获取 %s\n"

#: builtin/fetch.c
#, c-format
msgid "could not fetch %s"
msgstr "不能获取 %s"

#: builtin/fetch.c
#, c-format
msgid "could not fetch '%s' (exit code: %d)\n"
msgstr "无法获取 '%s'（退出码：%d）\n"

#: builtin/fetch.c
msgid ""
"no remote repository specified; please specify either a URL or a\n"
"remote name from which new revisions should be fetched"
msgstr "未指定远程仓库；请指定一个用于获取新版本的 URL 或远程仓库名"

#: builtin/fetch.c
msgid "you need to specify a tag name"
msgstr "您需要指定一个标签名称"

#: builtin/fetch.c builtin/pull.c
msgid "fetch from all remotes"
msgstr "从所有远程抓取"

#: builtin/fetch.c builtin/pull.c
msgid "set upstream for git pull/fetch"
msgstr "为 git pull/fetch 设置上游"

#: builtin/fetch.c builtin/pull.c
msgid "append to .git/FETCH_HEAD instead of overwriting"
msgstr "追加到 .git/FETCH_HEAD 而不是覆盖它"

#: builtin/fetch.c
msgid "use atomic transaction to update references"
msgstr "使用原子事务更新引用"

#: builtin/fetch.c builtin/pull.c
msgid "path to upload pack on remote end"
msgstr "上传包到远程的路径"

#: builtin/fetch.c
msgid "force overwrite of local reference"
msgstr "强制覆盖本地引用"

#: builtin/fetch.c
msgid "fetch from multiple remotes"
msgstr "从多个远程抓取"

#: builtin/fetch.c builtin/pull.c
msgid "fetch all tags and associated objects"
msgstr "抓取所有的标签和关联对象"

#: builtin/fetch.c
msgid "do not fetch all tags (--no-tags)"
msgstr "不抓取任何标签（--no-tags）"

#: builtin/fetch.c
msgid "number of submodules fetched in parallel"
msgstr "获取子模组的并发数"

#: builtin/fetch.c
msgid "modify the refspec to place all refs within refs/prefetch/"
msgstr "修改引用规格以将所有引用放入 refs/prefetch/"

#: builtin/fetch.c builtin/pull.c
msgid "prune remote-tracking branches no longer on remote"
msgstr "清除远程已经不存在的分支的跟踪分支"

#: builtin/fetch.c
msgid "prune local tags no longer on remote and clobber changed tags"
msgstr "清除远程不存在的本地标签，并且替换变更标签"

#  译者：可选值，不能翻译
#: builtin/fetch.c builtin/pull.c
msgid "on-demand"
msgstr "on-demand"

#: builtin/fetch.c
msgid "control recursive fetching of submodules"
msgstr "控制子模组的递归抓取"

#: builtin/fetch.c
msgid "write fetched references to the FETCH_HEAD file"
msgstr "将获取到的引用写入 FETCH_HEAD 文件"

#: builtin/fetch.c builtin/pull.c
msgid "keep downloaded pack"
msgstr "保持已下载的包"

#: builtin/fetch.c
msgid "allow updating of HEAD ref"
msgstr "允许更新 HEAD 引用"

#: builtin/fetch.c builtin/pull.c
msgid "deepen history of shallow clone"
msgstr "深化浅克隆的历史"

#: builtin/fetch.c builtin/pull.c
msgid "deepen history of shallow repository based on time"
msgstr "基于时间来深化浅克隆的历史"

#: builtin/fetch.c builtin/pull.c
msgid "convert to a complete repository"
msgstr "转换为一个完整的仓库"

#: builtin/fetch.c
msgid "re-fetch without negotiating common commits"
msgstr "重新获取而不协商共同提交"

#: builtin/fetch.c
msgid "prepend this to submodule path output"
msgstr "在子模组路径输出的前面加上此目录"

#: builtin/fetch.c
msgid ""
"default for recursive fetching of submodules (lower priority than config "
"files)"
msgstr "递归获取子模组的缺省值（比配置文件优先级低）"

#: builtin/fetch.c builtin/pull.c
msgid "accept refs that update .git/shallow"
msgstr "接受更新 .git/shallow 的引用"

#: builtin/fetch.c builtin/pull.c
msgid "refmap"
msgstr "引用映射"

#: builtin/fetch.c builtin/pull.c
msgid "specify fetch refmap"
msgstr "指定获取操作的引用映射"

#: builtin/fetch.c builtin/pull.c builtin/rebase.c builtin/replay.c
msgid "revision"
msgstr "版本"

#: builtin/fetch.c builtin/pull.c
msgid "report that we have only objects reachable from this object"
msgstr "报告我们只拥有从该对象开始可达的对象"

#: builtin/fetch.c
msgid "do not fetch a packfile; instead, print ancestors of negotiation tips"
msgstr "不获取包文件；而是打印协商的祖先提交"

#: builtin/fetch.c
msgid "run 'maintenance --auto' after fetching"
msgstr "获取后执行 'maintenance --auto'"

#: builtin/fetch.c builtin/pull.c
msgid "check for forced-updates on all updated branches"
msgstr "在所有更新分支上检查强制更新"

#: builtin/fetch.c
msgid "write the commit-graph after fetching"
msgstr "抓取后写提交图"

#: builtin/fetch.c
msgid "accept refspecs from stdin"
msgstr "从标准输入获取引用规格"

#: builtin/fetch.c
msgid "--negotiate-only needs one or more --negotiation-tip=*"
msgstr "--negotiate-only 需要一个或多个 --negotiation-tip=*"

#: builtin/fetch.c
msgid "negative depth in --deepen is not supported"
msgstr "--deepen 不支持负数深度"

#: builtin/fetch.c
msgid "--unshallow on a complete repository does not make sense"
msgstr "对于一个完整的仓库，参数 --unshallow 没有意义"

#: builtin/fetch.c
#, c-format
msgid "failed to fetch bundles from '%s'"
msgstr "无法从 '%s' 获取归档包"

#: builtin/fetch.c
msgid "fetch --all does not take a repository argument"
msgstr "fetch --all 不能带一个仓库参数"

#: builtin/fetch.c
msgid "fetch --all does not make sense with refspecs"
msgstr "fetch --all 带引用规格没有任何意义"

#: builtin/fetch.c
#, c-format
msgid "no such remote or remote group: %s"
msgstr "没有这样的远程或远程组：%s"

#: builtin/fetch.c
msgid "fetching a group and specifying refspecs does not make sense"
msgstr "获取组并指定引用规格没有意义"

#: builtin/fetch.c
msgid "must supply remote when using --negotiate-only"
msgstr "在使用 --negotiate-only 时必须提供远程仓库"

#: builtin/fetch.c
msgid "protocol does not support --negotiate-only, exiting"
msgstr "协议不支持 --negotiate-only，退出"

#: builtin/fetch.c
msgid ""
"--filter can only be used with the remote configured in "
"extensions.partialclone"
msgstr "只可以将 --filter 用于在 extensions.partialclone 中配置的远程仓库"

#: builtin/fetch.c
msgid "--atomic can only be used when fetching from one remote"
msgstr "--atomic 仅在从一个远程仓库获取的时候可用"

#: builtin/fetch.c
msgid "--stdin can only be used when fetching from one remote"
msgstr "--stdin 仅在从一个远程仓库获取的时候可用"

#: builtin/fmt-merge-msg.c
msgid ""
"git fmt-merge-msg [-m <message>] [--log[=<n>] | --no-log] [--file <file>]"
msgstr "git fmt-merge-msg [-m <说明>] [--log[=<n>] | --no-log] [--file <文件>]"

#: builtin/fmt-merge-msg.c
msgid "populate log with at most <n> entries from shortlog"
msgstr "向提交说明中最多复制指定条目（合并而来的提交）的简短说明"

#: builtin/fmt-merge-msg.c
msgid "alias for --log (deprecated)"
msgstr "参数 --log 的别名（已弃用）"

#: builtin/fmt-merge-msg.c
msgid "text"
msgstr "文本"

#: builtin/fmt-merge-msg.c
msgid "use <text> as start of message"
msgstr "使用 <文本> 作为提交说明的开始"

#: builtin/fmt-merge-msg.c
msgid "use <name> instead of the real target branch"
msgstr "使用 <名称> 而不是真正的目标分支"

#: builtin/fmt-merge-msg.c
msgid "file to read from"
msgstr "从文件中读取"

#: builtin/for-each-ref.c
msgid "git for-each-ref [<options>] [<pattern>]"
msgstr "git for-each-ref [<选项>] [<模式>]"

#: builtin/for-each-ref.c
msgid "git for-each-ref [--points-at <object>]"
msgstr "git for-each-ref [--points-at <对象>]"

#: builtin/for-each-ref.c
msgid "git for-each-ref [--merged [<commit>]] [--no-merged [<commit>]]"
msgstr "git for-each-ref [--merged [<提交>]] [--no-merged [<提交>]]"

#: builtin/for-each-ref.c
msgid "git for-each-ref [--contains [<commit>]] [--no-contains [<commit>]]"
msgstr "git for-each-ref [--contains [<提交>]] [--no-contains [<提交>]]"

#: builtin/for-each-ref.c
msgid "quote placeholders suitably for shells"
msgstr "引用占位符适用于 shells"

#: builtin/for-each-ref.c
msgid "quote placeholders suitably for perl"
msgstr "引用占位符适用于 perl"

#: builtin/for-each-ref.c
msgid "quote placeholders suitably for python"
msgstr "引用占位符适用于 python"

#: builtin/for-each-ref.c
msgid "quote placeholders suitably for Tcl"
msgstr "引用占位符适用于 Tcl"

#: builtin/for-each-ref.c
msgid "show only <n> matched refs"
msgstr "只显示 <n> 个匹配的引用"

#: builtin/for-each-ref.c builtin/tag.c
msgid "respect format colors"
msgstr "遵照格式中的颜色输出"

#: builtin/for-each-ref.c
msgid "print only refs which points at the given object"
msgstr "只打印指向给定对象的引用"

#: builtin/for-each-ref.c
msgid "print only refs that are merged"
msgstr "只打印已经合并的引用"

#: builtin/for-each-ref.c
msgid "print only refs that are not merged"
msgstr "只打印没有合并的引用"

#: builtin/for-each-ref.c
msgid "print only refs which contain the commit"
msgstr "只打印包含该提交的引用"

#: builtin/for-each-ref.c
msgid "print only refs which don't contain the commit"
msgstr "只打印不包含该提交的引用"

#: builtin/for-each-ref.c
msgid "read reference patterns from stdin"
msgstr "从标准输入读取引用的模式"

#: builtin/for-each-ref.c
msgid "also include HEAD ref and pseudorefs"
msgstr "还包括 HEAD 引用和伪引用"

#: builtin/for-each-ref.c
msgid "unknown arguments supplied with --stdin"
msgstr "为 --stdin 提供了未知的命令参数"

#: builtin/for-each-repo.c
msgid "git for-each-repo --config=<config> [--] <arguments>"
msgstr "git for-each-repo --config=<配置> [--] <命令参数>"

#: builtin/for-each-repo.c
msgid "config"
msgstr "配置"

#: builtin/for-each-repo.c
msgid "config key storing a list of repository paths"
msgstr "存储着仓库路径列表的配置项键名"

#: builtin/for-each-repo.c
msgid "keep going even if command fails in a repository"
msgstr "即使仓库中的命令失败，仍继续执行"

#: builtin/for-each-repo.c
msgid "missing --config=<config>"
msgstr "缺少 --config=<配置>"

#: builtin/for-each-repo.c
#, c-format
msgid "got bad config --config=%s"
msgstr "发现错误的配置行 --config=%s"

#: builtin/fsck.c
msgid "unknown"
msgstr "未知"

#. TRANSLATORS: e.g. error in tree 01bfda: <more explanation>
#: builtin/fsck.c
#, c-format
msgid "error in %s %s: %s"
msgstr "%s %s 错误：%s"

#. TRANSLATORS: e.g. warning in tree 01bfda: <more explanation>
#: builtin/fsck.c
#, c-format
msgid "warning in %s %s: %s"
msgstr "%s %s 警告：%s"

#: builtin/fsck.c
#, c-format
msgid "broken link from %7s %s"
msgstr "来自 %7s %s 的损坏的链接"

#: builtin/fsck.c
msgid "wrong object type in link"
msgstr "链接中错误的对象类型"

#: builtin/fsck.c
#, c-format
msgid ""
"broken link from %7s %s\n"
"              to %7s %s"
msgstr ""
"损坏的链接来自于 %7s %s\n"
"              到 %7s %s"

#: builtin/fsck.c builtin/prune.c connected.c
msgid "Checking connectivity"
msgstr "正在检查连通性"

#: builtin/fsck.c
#, c-format
msgid "missing %s %s"
msgstr "缺失 %s %s"

#: builtin/fsck.c
#, c-format
msgid "unreachable %s %s"
msgstr "不可达 %s %s"

#: builtin/fsck.c
#, c-format
msgid "dangling %s %s"
msgstr "悬空 %s %s"

#: builtin/fsck.c
msgid "could not create lost-found"
msgstr "不能创建 lost-found"

#: builtin/fsck.c builtin/gc.c builtin/rebase.c rebase-interactive.c rerere.c
#: sequencer.c
#, c-format
msgid "could not write '%s'"
msgstr "不能写入 '%s'"

#: builtin/fsck.c
#, c-format
msgid "could not finish '%s'"
msgstr "不能完成 '%s'"

#: builtin/fsck.c
#, c-format
msgid "Checking %s"
msgstr "正在检查 %s"

#: builtin/fsck.c
#, c-format
msgid "Checking connectivity (%d objects)"
msgstr "正在检查连通性（%d 个对象）"

#: builtin/fsck.c
#, c-format
msgid "Checking %s %s"
msgstr "正在检查 %s %s"

#: builtin/fsck.c
msgid "broken links"
msgstr "损坏的链接"

#: builtin/fsck.c
#, c-format
msgid "root %s"
msgstr "根 %s"

#: builtin/fsck.c
#, c-format
msgid "tagged %s %s (%s) in %s"
msgstr "标记 %s %s (%s) 于 %s"

#: builtin/fsck.c
#, c-format
msgid "%s: object corrupt or missing"
msgstr "%s：对象损坏或丢失"

#: builtin/fsck.c
#, c-format
msgid "%s: invalid reflog entry %s"
msgstr "%s：无效的引用日志条目 %s"

#: builtin/fsck.c
#, c-format
msgid "Checking reflog %s->%s"
msgstr "正在检查引用日志 %s->%s"

#: builtin/fsck.c
#, c-format
msgid "%s: invalid sha1 pointer %s"
msgstr "%s：无效的 sha1 指针 %s"

#: builtin/fsck.c
#, c-format
msgid "%s: not a commit"
msgstr "%s：不是一个提交"

#: builtin/fsck.c
msgid "notice: No default references"
msgstr "注意：无默认引用"

#: builtin/fsck.c
#, c-format
msgid "%s: hash-path mismatch, found at: %s"
msgstr "%s：哈希路径不匹配，发现于 %s"

#: builtin/fsck.c
#, c-format
msgid "%s: object corrupt or missing: %s"
msgstr "%s：对象损坏或丢失：%s"

#: builtin/fsck.c
#, c-format
msgid "%s: object is of unknown type '%s': %s"
msgstr "%s：对象有未知的类型 '%s': %s"

#: builtin/fsck.c
#, c-format
msgid "%s: object could not be parsed: %s"
msgstr "%s：不能解析对象：%s"

#: builtin/fsck.c
#, c-format
msgid "bad sha1 file: %s"
msgstr "坏的 sha1 文件：%s"

#: builtin/fsck.c
msgid "Checking object directory"
msgstr "正在检查对象目录"

#: builtin/fsck.c
msgid "Checking object directories"
msgstr "正在检查对象目录"

#: builtin/fsck.c
#, c-format
msgid "Checking %s link"
msgstr "正在检查 %s 链接"

#: builtin/fsck.c builtin/index-pack.c
#, c-format
msgid "invalid %s"
msgstr "无效的 %s"

#: builtin/fsck.c
#, c-format
msgid "%s points to something strange (%s)"
msgstr "%s 指向奇怪的东西（%s）"

#: builtin/fsck.c
#, c-format
msgid "%s: detached HEAD points at nothing"
msgstr "%s：分离头指针的指向不存在"

#: builtin/fsck.c
#, c-format
msgid "notice: %s points to an unborn branch (%s)"
msgstr "注意：%s 指向一个尚未诞生的分支（%s）"

#: builtin/fsck.c
#, c-format
msgid "Checking cache tree of %s"
msgstr "正在检查缓存树 %s"

#: builtin/fsck.c
#, c-format
msgid "%s: invalid sha1 pointer in cache-tree of %s"
msgstr "%s：cache-tree %s 中存在无效的 sha1 指针"

#: builtin/fsck.c
msgid "non-tree in cache-tree"
msgstr "cache-tree 中非树对象"

#: builtin/fsck.c
#, c-format
msgid "%s: invalid sha1 pointer in resolve-undo of %s"
msgstr "%s：resolve-undo %s 中存在无效的 sha1 指针"

#: builtin/fsck.c
#, c-format
msgid "unable to load rev-index for pack '%s'"
msgstr "无法为包文件 %s 加载反向索引"

#: builtin/fsck.c
#, c-format
msgid "invalid rev-index for pack '%s'"
msgstr "包文件 '%s' 的反向索引文件无效"

#: builtin/fsck.c
msgid ""
"git fsck [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]\n"
"         [--[no-]full] [--strict] [--verbose] [--lost-found]\n"
"         [--[no-]dangling] [--[no-]progress] [--connectivity-only]\n"
"         [--[no-]name-objects] [<object>...]"
msgstr ""
"git fsck [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]\n"
"         [--[no-]full] [--strict] [--verbose] [--lost-found]\n"
"         [--[no-]dangling] [--[no-]progress] [--connectivity-only]\n"
"         [--[no-]name-objects] [<对象>...]"

#: builtin/fsck.c
msgid "show unreachable objects"
msgstr "显示不可达的对象"

#: builtin/fsck.c
msgid "show dangling objects"
msgstr "显示悬空的对象"

#: builtin/fsck.c
msgid "report tags"
msgstr "报告标签"

#: builtin/fsck.c
msgid "report root nodes"
msgstr "报告根节点"

#: builtin/fsck.c
msgid "make index objects head nodes"
msgstr "将索引亦作为检查的头节点"

#: builtin/fsck.c
msgid "make reflogs head nodes (default)"
msgstr "将引用日志作为检查的头节点（默认）"

#: builtin/fsck.c
msgid "also consider packs and alternate objects"
msgstr "也考虑包和备用对象"

#: builtin/fsck.c
msgid "check only connectivity"
msgstr "仅检查连通性"

#: builtin/fsck.c builtin/mktag.c
msgid "enable more strict checking"
msgstr "启用更严格的检查"

#: builtin/fsck.c
msgid "write dangling objects in .git/lost-found"
msgstr "将悬空对象写入 .git/lost-found 中"

#: builtin/fsck.c builtin/prune.c
msgid "show progress"
msgstr "显示进度"

#: builtin/fsck.c
msgid "show verbose names for reachable objects"
msgstr "显示可达对象的详细名称"

#: builtin/fsck.c builtin/index-pack.c
msgid "Checking objects"
msgstr "正在检查对象"

#: builtin/fsck.c
#, c-format
msgid "%s: object missing"
msgstr "%s：对象缺失"

#: builtin/fsck.c
#, c-format
msgid "invalid parameter: expected sha1, got '%s'"
msgstr "无效的参数：期望 sha1，得到 '%s'"

#: builtin/fsmonitor--daemon.c
msgid "git fsmonitor--daemon start [<options>]"
msgstr "git fsmonitor--daemon start [<选项>]"

#: builtin/fsmonitor--daemon.c
msgid "git fsmonitor--daemon run [<options>]"
msgstr "git fsmonitor--daemon run [<选项>]"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "value of '%s' out of range: %d"
msgstr "'%s' 的值超出范围：%d"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "value of '%s' not bool or int: %d"
msgstr "'%s' 的值不是 bool 或 int：%d"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "fsmonitor-daemon is watching '%s'\n"
msgstr "fsmonitor-daemon 正在监视 '%s'\n"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "fsmonitor-daemon is not watching '%s'\n"
msgstr "fsmonitor-daemon 不在监视 '%s'\n"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "could not create fsmonitor cookie '%s'"
msgstr "无法创建 fsmonitor cookie '%s'"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "fsmonitor: cookie_result '%d' != SEEN"
msgstr "fsmonitor: cookie_result '%d' != SEEN"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "could not start IPC thread pool on '%s'"
msgstr "无法在 '%s' 启动 IPC 线程池"

#: builtin/fsmonitor--daemon.c
msgid "could not start fsmonitor listener thread"
msgstr "无法启动 fsmonitor 监听线程"

#: builtin/fsmonitor--daemon.c
msgid "could not start fsmonitor health thread"
msgstr "无法启动 fsmonitor 健康检查线程"

#: builtin/fsmonitor--daemon.c
msgid "could not initialize listener thread"
msgstr "无法初始化监听线程"

#: builtin/fsmonitor--daemon.c
msgid "could not initialize health thread"
msgstr "无法初始化健康检查线程"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "could not cd home '%s'"
msgstr "不能切换至家目录 '%s'"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "fsmonitor--daemon is already running '%s'"
msgstr "fsmonitor--daemon 已经在运行 '%s'"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "running fsmonitor-daemon in '%s'\n"
msgstr "在 '%s' 中运行 fsmonitor-daemon\n"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "starting fsmonitor-daemon in '%s'\n"
msgstr "在 '%s' 中启动 fsmonitor-daemon\n"

#: builtin/fsmonitor--daemon.c
msgid "daemon failed to start"
msgstr "守护进程无法启动"

#: builtin/fsmonitor--daemon.c
msgid "daemon not online yet"
msgstr "守护进程尚未在线"

#: builtin/fsmonitor--daemon.c
msgid "daemon terminated"
msgstr "守护进程被终结"

#: builtin/fsmonitor--daemon.c
msgid "detach from console"
msgstr "从控制台分离"

#: builtin/fsmonitor--daemon.c
msgid "use <n> ipc worker threads"
msgstr "使用 <n> 个 IPC 工作线程"

#: builtin/fsmonitor--daemon.c
msgid "max seconds to wait for background daemon startup"
msgstr "等待守护进程启动的最大秒数"

#: builtin/fsmonitor--daemon.c
#, c-format
msgid "invalid 'ipc-threads' value (%d)"
msgstr "无效的 'ipc-threads' 值（%d）"

#: builtin/fsmonitor--daemon.c t/helper/test-cache-tree.c
#, c-format
msgid "Unhandled subcommand '%s'"
msgstr "未处理的子命令 '%s'"

#: builtin/fsmonitor--daemon.c
msgid "fsmonitor--daemon not supported on this platform"
msgstr "fsmonitor--daemon 不支持本平台"

#: builtin/gc.c
msgid "git gc [<options>]"
msgstr "git gc [<选项>]"

#: builtin/gc.c
#, c-format
msgid "Failed to fstat %s: %s"
msgstr "对 %s 调用 fstat 失败：%s"

#: builtin/gc.c
#, c-format
msgid "failed to parse '%s' value '%s'"
msgstr "无法解析 '%s' 值 '%s'"

#: builtin/gc.c setup.c
#, c-format
msgid "cannot stat '%s'"
msgstr "不能对 '%s' 调用 stat"

#: builtin/gc.c
#, c-format
msgid ""
"The last gc run reported the following. Please correct the root cause\n"
"and remove %s\n"
"Automatic cleanup will not be performed until the file is removed.\n"
"\n"
"%s"
msgstr ""
"最后一次 gc 操作报告如下信息。请检查原因并删除 %s\n"
"在该文件被删除之前，自动清理将不会执行。\n"
"\n"
"%s"

#: builtin/gc.c
msgid "prune unreferenced objects"
msgstr "清除未引用的对象"

#: builtin/gc.c
msgid "pack unreferenced objects separately"
msgstr "分开打包未引用的对象"

#: builtin/gc.c builtin/repack.c
msgid "with --cruft, limit the size of new cruft packs"
msgstr "使用 --cruft，限制新 cruft 包的总大小"

#: builtin/gc.c
msgid "be more thorough (increased runtime)"
msgstr "更彻底（增加运行时间）"

#: builtin/gc.c
msgid "enable auto-gc mode"
msgstr "启用自动垃圾回收模式"

#: builtin/gc.c
msgid "perform garbage collection in the background"
msgstr "在后台进行垃圾回收"

#: builtin/gc.c
msgid "force running gc even if there may be another gc running"
msgstr "强制执行 gc 即使另外一个 gc 正在执行"

#: builtin/gc.c
msgid "repack all other packs except the largest pack"
msgstr "除了最大的包之外，对所有其它包文件重新打包"

#: builtin/gc.c builtin/repack.c
msgid "pack prefix to store a pack containing pruned objects"
msgstr "用于存储修剪对象的包前缀"

#: builtin/gc.c
#, c-format
msgid "failed to parse gc.logExpiry value %s"
msgstr "无法解析 gc.logExpiry 的值 %s"

#: builtin/gc.c
#, c-format
msgid "failed to parse prune expiry value %s"
msgstr "无法解析清除期限值 %s"

#: builtin/gc.c
#, c-format
msgid "Auto packing the repository in background for optimum performance.\n"
msgstr "自动在后台执行仓库打包以求最佳性能。\n"

#: builtin/gc.c
#, c-format
msgid "Auto packing the repository for optimum performance.\n"
msgstr "自动打包仓库以求最佳性能。\n"

#: builtin/gc.c
#, c-format
msgid "See \"git help gc\" for manual housekeeping.\n"
msgstr "手工维护参见 \"git help gc\"。\n"

#: builtin/gc.c
#, c-format
msgid ""
"gc is already running on machine '%s' pid %<PRIuMAX> (use --force if not)"
msgstr ""
"已经有一个 gc 正运行在机器 '%s' pid %<PRIuMAX>（如果不是，使用 --force）"

#: builtin/gc.c
msgid ""
"There are too many unreachable loose objects; run 'git prune' to remove them."
msgstr "有太多不可达的松散对象，运行 'git prune' 删除它们。"

#: builtin/gc.c
msgid ""
"git maintenance run [--auto] [--[no-]quiet] [--task=<task>] [--schedule]"
msgstr ""
"git maintenance run [--auto] [--[no-]quiet] [--task=<任务>] [--schedule]"

#: builtin/gc.c
msgid "--no-schedule is not allowed"
msgstr "--no-schedule 不被允许"

#: builtin/gc.c
#, c-format
msgid "unrecognized --schedule argument '%s'"
msgstr "无法识别的 --schedule 参数 '%s'"

#: builtin/gc.c
msgid "failed to write commit-graph"
msgstr "无法写入提交图"

#: builtin/gc.c
msgid "failed to prefetch remotes"
msgstr "无法预先获取远程仓库"

#: builtin/gc.c
msgid "failed to start 'git pack-objects' process"
msgstr "无法启动 'git pack-objects' 进程"

#: builtin/gc.c
msgid "failed to finish 'git pack-objects' process"
msgstr "无法完成 'git pack-objects' 进程"

#: builtin/gc.c
msgid "failed to write multi-pack-index"
msgstr "无法写入多包索引"

#: builtin/gc.c
msgid "'git multi-pack-index expire' failed"
msgstr "'git multi-pack-index expire' 失败"

#: builtin/gc.c
msgid "'git multi-pack-index repack' failed"
msgstr "'git multi-pack-index repack' 失败"

#: builtin/gc.c
msgid ""
"skipping incremental-repack task because core.multiPackIndex is disabled"
msgstr "跳过增量重新打包任务，因为 core.multiPackIndex 被禁用"

#: builtin/gc.c
#, c-format
msgid "lock file '%s' exists, skipping maintenance"
msgstr "锁文件 '%s' 已存在，跳过维护"

#: builtin/gc.c
#, c-format
msgid "task '%s' failed"
msgstr "任务 '%s' 失败"

#: builtin/gc.c
#, c-format
msgid "'%s' is not a valid task"
msgstr "'%s' 不是一个有效的任务"

#: builtin/gc.c
#, c-format
msgid "task '%s' cannot be selected multiple times"
msgstr "任务 '%s' 不能被多次选择"

#: builtin/gc.c
msgid "run tasks based on the state of the repository"
msgstr "基于仓库状态来运行任务"

#: builtin/gc.c
msgid "perform maintenance in the background"
msgstr "在后台执行运维"

#: builtin/gc.c
msgid "frequency"
msgstr "频率"

#: builtin/gc.c
msgid "run tasks based on frequency"
msgstr "基于频率运行任务"

#: builtin/gc.c
msgid "do not report progress or other information over stderr"
msgstr "不通过标准错误报告进度或其它信息"

#: builtin/gc.c
msgid "task"
msgstr "任务"

#: builtin/gc.c
msgid "run a specific task"
msgstr "运行一个特定的任务"

#: builtin/gc.c
msgid "use at most one of --auto and --schedule=<frequency>"
msgstr "最多使用 --auto 和 --schedule=<频率> 其中之一"

#: builtin/gc.c
#, c-format
msgid "unable to add '%s' value of '%s'"
msgstr "无法添加 '%2$s' 的 '%1$s' 值"

#: builtin/gc.c
msgid "return success even if repository was not registered"
msgstr "即便仓库非注册仍然返回成功"

#: builtin/gc.c
#, c-format
msgid "unable to unset '%s' value of '%s'"
msgstr "无法取消设置 '%2$s' 的 '%1$s' 值"

#: builtin/gc.c
#, c-format
msgid "repository '%s' is not registered"
msgstr "仓库 '%s' 未注册"

#: builtin/gc.c
#, c-format
msgid "failed to expand path '%s'"
msgstr "无法扩展路径 '%s'"

#: builtin/gc.c
msgid "failed to start launchctl"
msgstr "无法启动 launchctl"

#: builtin/gc.c
#, c-format
msgid "failed to create directories for '%s'"
msgstr "无法为 '%s' 创建目录"

#: builtin/gc.c
#, c-format
msgid "failed to bootstrap service %s"
msgstr "无法引导服务 %s"

#: builtin/gc.c
msgid "failed to create temp xml file"
msgstr "无法创建临时 XML 文件"

#: builtin/gc.c
msgid "failed to start schtasks"
msgstr "无法启动计划任务"

#: builtin/gc.c
msgid "failed to run 'crontab -l'; your system might not support 'cron'"
msgstr "无法执行 'crontab -l'，您的系统可能不支持 'cron'"

#: builtin/gc.c
msgid "failed to create crontab temporary file"
msgstr "无法创建 crontab 临时文件"

#: builtin/gc.c
msgid "failed to open temporary file"
msgstr "无法打开临时文件"

#: builtin/gc.c
msgid "failed to run 'crontab'; your system might not support 'cron'"
msgstr "无法运行 'crontab'，您的系统可能不支持 'cron'"

#: builtin/gc.c
msgid "'crontab' died"
msgstr "'crontab' 终止"

#: builtin/gc.c builtin/worktree.c
#, c-format
msgid "failed to delete '%s'"
msgstr "无法删除 '%s'"

#: builtin/gc.c rerere.c
#, c-format
msgid "failed to flush '%s'"
msgstr "无法刷新 '%s'"

#: builtin/gc.c
msgid "failed to start systemctl"
msgstr "无法启动 systemctl"

#: builtin/gc.c
msgid "failed to run systemctl"
msgstr "无法运行 systemctl"

#: builtin/gc.c
#, c-format
msgid "unrecognized --scheduler argument '%s'"
msgstr "无法识别的 --scheduler 参数 '%s'"

#: builtin/gc.c
msgid "neither systemd timers nor crontab are available"
msgstr "systemd 和 crontab 的定时器都不可用"

#: builtin/gc.c
#, c-format
msgid "%s scheduler is not available"
msgstr "%s 调度器不可用"

#: builtin/gc.c
#, c-format
msgid ""
"unable to create '%s.lock': %s.\n"
"\n"
"Another scheduled git-maintenance(1) process seems to be running in this\n"
"repository. Please make sure no other maintenance processes are running and\n"
"then try again. If it still fails, a git-maintenance(1) process may have\n"
"crashed in this repository earlier: remove the file manually to continue."
msgstr ""
"无法创建 '%s.lock'：%s。\n"
"\n"
"另一个已计划的 git-maintenance(1) 进程似乎正在该仓库中运行。\n"
"请确保没有其他维护进程正在运行，然后重试。如果仍然运行失败，则\n"
"git-maintenance(1) 进程可能之前已在此仓库中崩溃：请手动删除该文件以继续。"

#: builtin/gc.c
msgid "cannot acquire lock for scheduled background maintenance"
msgstr "无法获取计划的后台维护锁"

#: builtin/gc.c
msgid "git maintenance start [--scheduler=<scheduler>]"
msgstr "git maintenance start [--scheduler=<调度器>]"

#: builtin/gc.c
msgid "scheduler"
msgstr "调度器"

#: builtin/gc.c
msgid "scheduler to trigger git maintenance run"
msgstr "触发 git maintenance 执行的调度器"

#: builtin/gc.c
msgid "failed to set up maintenance schedule"
msgstr "无法设置维护计划"

#: builtin/gc.c
msgid "failed to add repo to global config"
msgstr "无法将仓库添加到全局配置"

#: builtin/gc.c
msgid "git maintenance <subcommand> [<options>]"
msgstr "git maintenance <子命令> [<选项>]"

#: builtin/grep.c
msgid "git grep [<options>] [-e] <pattern> [<rev>...] [[--] <path>...]"
msgstr "git grep [<选项>] [-e] <模式> [<版本>...] [[--] <路径>...]"

#: builtin/grep.c
#, c-format
msgid "grep: failed to create thread: %s"
msgstr "grep：无法创建线程：%s"

#: builtin/grep.c
#, c-format
msgid "invalid number of threads specified (%d) for %s"
msgstr "为 %2$s 设定的线程数 (%1$d) 无效"

#. #-#-#-#-#  grep.c.po  #-#-#-#-#
#. TRANSLATORS: %s is the configuration
#. variable for tweaking threads, currently
#. grep.threads
#.
#: builtin/grep.c builtin/index-pack.c builtin/pack-objects.c
#, c-format
msgid "no threads support, ignoring %s"
msgstr "没有线程支持，忽略 %s"

#: builtin/grep.c
#, c-format
msgid "unable to read tree %s"
msgstr "无法读取树 %s"

#: builtin/grep.c
#, c-format
msgid "unable to grep from object of type %s"
msgstr "无法抓取来自于 %s 类型的对象"

#: builtin/grep.c
#, c-format
msgid "switch `%c' expects a numerical value"
msgstr "开关 `%c' 期望一个数字值"

#: builtin/grep.c
msgid "search in index instead of in the work tree"
msgstr "在索引区搜索而不是在工作区"

#: builtin/grep.c
msgid "find in contents not managed by git"
msgstr "在未被 git 管理的内容中查找"

#: builtin/grep.c
msgid "search in both tracked and untracked files"
msgstr "在跟踪和未跟踪的文件中搜索"

#: builtin/grep.c
msgid "ignore files specified via '.gitignore'"
msgstr "忽略 '.gitignore' 包含的文件"

#: builtin/grep.c
msgid "recursively search in each submodule"
msgstr "在每一个子模组中递归搜索"

#: builtin/grep.c
msgid "show non-matching lines"
msgstr "显示未匹配的行"

#: builtin/grep.c
msgid "case insensitive matching"
msgstr "不区分大小写匹配"

#: builtin/grep.c
msgid "match patterns only at word boundaries"
msgstr "只在单词边界匹配模式"

#: builtin/grep.c
msgid "process binary files as text"
msgstr "把二进制文件当做文本处理"

#: builtin/grep.c
msgid "don't match patterns in binary files"
msgstr "不在二进制文件中匹配模式"

#: builtin/grep.c
msgid "process binary files with textconv filters"
msgstr "用 textconv 过滤器处理二进制文件"

#: builtin/grep.c
msgid "search in subdirectories (default)"
msgstr "在子目录中寻找（默认）"

#: builtin/grep.c
msgid "descend at most <n> levels"
msgstr "最多向下寻找 <n> 层"

#: builtin/grep.c
msgid "use extended POSIX regular expressions"
msgstr "使用扩展的 POSIX 正则表达式"

#: builtin/grep.c
msgid "use basic POSIX regular expressions (default)"
msgstr "使用基本的 POSIX 正则表达式（默认）"

#: builtin/grep.c
msgid "interpret patterns as fixed strings"
msgstr "把模式解析为固定的字符串"

#: builtin/grep.c
msgid "use Perl-compatible regular expressions"
msgstr "使用 Perl 兼容的正则表达式"

#: builtin/grep.c
msgid "show line numbers"
msgstr "显示行号"

#: builtin/grep.c
msgid "show column number of first match"
msgstr "显示第一个匹配的列号"

#: builtin/grep.c
msgid "don't show filenames"
msgstr "不显示文件名"

#: builtin/grep.c
msgid "show filenames"
msgstr "显示文件名"

#: builtin/grep.c
msgid "show filenames relative to top directory"
msgstr "显示相对于顶级目录的文件名"

#: builtin/grep.c
msgid "show only filenames instead of matching lines"
msgstr "只显示文件名而不显示匹配的行"

#: builtin/grep.c
msgid "synonym for --files-with-matches"
msgstr "和 --files-with-matches 同义"

#: builtin/grep.c
msgid "show only the names of files without match"
msgstr "只显示未匹配的文件名"

#: builtin/grep.c
msgid "print NUL after filenames"
msgstr "在文件名后输出 NUL 字符"

#: builtin/grep.c
msgid "show only matching parts of a line"
msgstr "只显示行中的匹配的部分"

#: builtin/grep.c
msgid "show the number of matches instead of matching lines"
msgstr "显示总匹配行数，而不显示匹配的行"

#: builtin/grep.c
msgid "highlight matches"
msgstr "高亮显示匹配项"

#: builtin/grep.c
msgid "print empty line between matches from different files"
msgstr "在不同文件的匹配项之间打印空行"

#: builtin/grep.c
msgid "show filename only once above matches from same file"
msgstr "只在同一文件的匹配项的上面显示一次文件名"

#: builtin/grep.c
msgid "show <n> context lines before and after matches"
msgstr "显示匹配项前后的 <n> 行上下文"

#: builtin/grep.c
msgid "show <n> context lines before matches"
msgstr "显示匹配项前 <n> 行上下文"

#: builtin/grep.c
msgid "show <n> context lines after matches"
msgstr "显示匹配项后 <n> 行上下文"

#: builtin/grep.c
msgid "use <n> worker threads"
msgstr "使用 <n> 个工作线程"

#: builtin/grep.c
msgid "shortcut for -C NUM"
msgstr "快捷键 -C 数字"

#: builtin/grep.c
msgid "show a line with the function name before matches"
msgstr "在匹配的前面显示一行函数名"

#: builtin/grep.c
msgid "show the surrounding function"
msgstr "显示所在函数的前后内容"

#: builtin/grep.c
msgid "read patterns from file"
msgstr "从文件读取模式"

#: builtin/grep.c
msgid "match <pattern>"
msgstr "匹配 <模式>"

#: builtin/grep.c
msgid "combine patterns specified with -e"
msgstr "组合用 -e 参数设定的模式"

#: builtin/grep.c
msgid "indicate hit with exit status without output"
msgstr "不输出，而用退出码标识命中状态"

#: builtin/grep.c
msgid "show only matches from files that match all patterns"
msgstr "只显示匹配所有模式的文件中的匹配"

#: builtin/grep.c
msgid "pager"
msgstr "分页"

#: builtin/grep.c
msgid "show matching files in the pager"
msgstr "分页显示匹配的文件"

#: builtin/grep.c
msgid "allow calling of grep(1) (ignored by this build)"
msgstr "允许调用 grep(1)（本次构建忽略）"

#: builtin/grep.c
msgid "maximum number of results per file"
msgstr "每个文件的最大结果数量"

#: builtin/grep.c
msgid "no pattern given"
msgstr "未提供匹配模式"

#: builtin/grep.c
msgid "--no-index or --untracked cannot be used with revs"
msgstr "--no-index 或 --untracked 不能和版本同时使用"

#: builtin/grep.c
#, c-format
msgid "unable to resolve revision: %s"
msgstr "不能解析版本：%s"

#: builtin/grep.c
msgid "--untracked not supported with --recurse-submodules"
msgstr "--untracked 不支持和 --recurse-submodules 共用"

#: builtin/grep.c
msgid "invalid option combination, ignoring --threads"
msgstr "无效的选项组合，忽略 --threads"

#: builtin/grep.c builtin/pack-objects.c
msgid "no threads support, ignoring --threads"
msgstr "没有线程支持，忽略 --threads"

#: builtin/grep.c builtin/index-pack.c builtin/pack-objects.c
#, c-format
msgid "invalid number of threads specified (%d)"
msgstr "指定的线程数无效（%d）"

#: builtin/grep.c
msgid "--open-files-in-pager only works on the worktree"
msgstr "--open-files-in-pager 仅用于工作区"

#: builtin/grep.c
msgid "--[no-]exclude-standard cannot be used for tracked contents"
msgstr "--[no-]exclude-standard 不能用于已跟踪内容"

#: builtin/grep.c
msgid "both --cached and trees are given"
msgstr "同时给出了 --cached 和树对象"

#: builtin/hash-object.c
msgid ""
"git hash-object [-t <type>] [-w] [--path=<file> | --no-filters]\n"
"                [--stdin [--literally]] [--] <file>..."
msgstr ""
"git hash-object [-t <类型>] [-w] [--path=<文件> | --no-filters]\n"
"                [--stdin [--literally]] [--] <文件>..."

#: builtin/hash-object.c
msgid "git hash-object [-t <type>] [-w] --stdin-paths [--no-filters]"
msgstr "git hash-object [-t <类型>] [-w] --stdin-paths [--no-filters]"

#: builtin/hash-object.c
msgid "object type"
msgstr "对象类型"

#: builtin/hash-object.c
msgid "write the object into the object database"
msgstr "将对象写入对象数据库"

#: builtin/hash-object.c
msgid "read the object from stdin"
msgstr "从标准输入读取对象"

#: builtin/hash-object.c
msgid "store file as is without filters"
msgstr "原样存储文件不使用过滤器"

#: builtin/hash-object.c
msgid ""
"just hash any random garbage to create corrupt objects for debugging Git"
msgstr "允许对任意随机垃圾数据做散列来创建损坏的对象以便调试 Git"

#: builtin/hash-object.c
msgid "process file as it were from this path"
msgstr "处理文件并假设其来自于此路径"

#: builtin/help.c
msgid "print all available commands"
msgstr "打印所有可用的命令"

#: builtin/help.c
msgid "show external commands in --all"
msgstr "在 --all 中显示外部命令"

#: builtin/help.c
msgid "show aliases in --all"
msgstr "在 --all 中显示别名"

#: builtin/help.c
msgid "exclude guides"
msgstr "排除向导"

#: builtin/help.c
msgid "show man page"
msgstr "显示 man 手册"

#: builtin/help.c
msgid "show manual in web browser"
msgstr "在 web 浏览器中显示手册"

#: builtin/help.c
msgid "show info page"
msgstr "显示 info 手册"

#: builtin/help.c
msgid "print command description"
msgstr "打印命令描述"

#: builtin/help.c
msgid "print list of useful guides"
msgstr "显示有用的指南列表"

#: builtin/help.c
msgid "print list of user-facing repository, command and file interfaces"
msgstr "打印面向用户的仓库、命令和文件接口列表"

#: builtin/help.c
msgid "print list of file formats, protocols and other developer interfaces"
msgstr "打印文件格式、协议和其他开发者接口列表"

#: builtin/help.c
msgid "print all configuration variable names"
msgstr "打印所有配置变量名称"

#: builtin/help.c
msgid "git help [[-i|--info] [-m|--man] [-w|--web]] [<command>|<doc>]"
msgstr "git help [[-i|--info] [-m|--man] [-w|--web]] [<命令>|<文档>]"

#: builtin/help.c
#, c-format
msgid "unrecognized help format '%s'"
msgstr "未能识别的帮助格式 '%s'"

#: builtin/help.c
msgid "Failed to start emacsclient."
msgstr "无法启动 emacsclient。"

#: builtin/help.c
msgid "Failed to parse emacsclient version."
msgstr "无法解析 emacsclient 版本。"

#: builtin/help.c
#, c-format
msgid "emacsclient version '%d' too old (< 22)."
msgstr "emacsclient 版本 '%d' 太老（< 22）。"

#: builtin/help.c
#, c-format
msgid "failed to exec '%s'"
msgstr "无法执行 '%s'"

#: builtin/help.c
#, c-format
msgid ""
"'%s': path for unsupported man viewer.\n"
"Please consider using 'man.<tool>.cmd' instead."
msgstr ""
"'%s'：不支持的 man 手册查看器的路径。\n"
"请使用 'man.<工具>.cmd'。"

#: builtin/help.c
#, c-format
msgid ""
"'%s': cmd for supported man viewer.\n"
"Please consider using 'man.<tool>.path' instead."
msgstr ""
"'%s': 支持的 man 手册查看器命令。\n"
"请使用 'man.<工具>.path'。"

#: builtin/help.c
#, c-format
msgid "'%s': unknown man viewer."
msgstr "'%s'：未知的 man 查看器。"

#: builtin/help.c
msgid "no man viewer handled the request"
msgstr "没有 man 查看器处理此请求"

#: builtin/help.c
msgid "no info viewer handled the request"
msgstr "没有 info 查看器处理此请求"

#: builtin/help.c git.c
#, c-format
msgid "'%s' is aliased to '%s'"
msgstr "'%s' 是 '%s' 的别名"

#: builtin/help.c git.c
#, c-format
msgid "bad alias.%s string: %s"
msgstr "坏的 alias.%s 字符串：%s"

#: builtin/help.c
#, c-format
msgid "the '%s' option doesn't take any non-option arguments"
msgstr "'%s' 选项不带任何非选项参数"

#: builtin/help.c
msgid ""
"the '--no-[external-commands|aliases]' options can only be used with '--all'"
msgstr "'--no-[external-commands|aliases]' 选项只能和 '--all' 一起使用"

#: builtin/help.c
#, c-format
msgid "usage: %s%s"
msgstr "用法：%s%s"

#: builtin/help.c
msgid "'git help config' for more information"
msgstr "'git help config' 获取更多信息"

#: builtin/hook.c
msgid ""
"git hook run [--ignore-missing] [--to-stdin=<path>] <hook-name> [-- <hook-"
"args>]"
msgstr ""
"git hook run [--ignore-missing] [--to-stdin=<路径>] <钩子名称> [-- <钩子参数"
">]"

#: builtin/hook.c
msgid "silently ignore missing requested <hook-name>"
msgstr "静默地忽略缺失的 <钩子名称>"

#: builtin/hook.c
msgid "file to read into hooks' stdin"
msgstr "读取至钩子标准输入的文件"

#: builtin/index-pack.c
#, c-format
msgid "object type mismatch at %s"
msgstr "%s 的对象类型不匹配"

#: builtin/index-pack.c
#, c-format
msgid "did not receive expected object %s"
msgstr "未能获取预期的对象 %s"

#: builtin/index-pack.c
#, c-format
msgid "object %s: expected type %s, found %s"
msgstr "对象 %s：应为类型 %s，却是 %s"

#: builtin/index-pack.c
#, c-format
msgid "cannot fill %d byte"
msgid_plural "cannot fill %d bytes"
msgstr[0] "无法填充 %d 字节"
msgstr[1] "无法填充 %d 字节"

#: builtin/index-pack.c
msgid "early EOF"
msgstr "过早的文件结束符（EOF）"

#: builtin/index-pack.c
msgid "read error on input"
msgstr "输入上的读错误"

#: builtin/index-pack.c
msgid "used more bytes than were available"
msgstr "用掉了超过可用的字节"

#: builtin/index-pack.c builtin/pack-objects.c
msgid "pack too large for current definition of off_t"
msgstr "包太大超过了当前 off_t 的定义"

#: builtin/index-pack.c
#, c-format
msgid "pack exceeds maximum allowed size (%s)"
msgstr "包超过了最大允许大小（%s）"

#: builtin/index-pack.c
msgid "pack signature mismatch"
msgstr "包签名不匹配"

#: builtin/index-pack.c
#, c-format
msgid "pack version %<PRIu32> unsupported"
msgstr "不支持包版本 %<PRIu32>"

#: builtin/index-pack.c
#, c-format
msgid "pack has bad object at offset %<PRIuMAX>: %s"
msgstr "包中有错误的对象位于偏移量 %<PRIuMAX>：%s"

#: builtin/index-pack.c
#, c-format
msgid "inflate returned %d"
msgstr "解压缩返回 %d"

#: builtin/index-pack.c
msgid "offset value overflow for delta base object"
msgstr "偏移值覆盖了 delta 基准对象"

#: builtin/index-pack.c
msgid "delta base offset is out of bound"
msgstr "delta 基准偏移越界"

#: builtin/index-pack.c
#, c-format
msgid "unknown object type %d"
msgstr "未知对象类型 %d"

#: builtin/index-pack.c
msgid "cannot pread pack file"
msgstr "无法读取包文件"

#: builtin/index-pack.c
#, c-format
msgid "premature end of pack file, %<PRIuMAX> byte missing"
msgid_plural "premature end of pack file, %<PRIuMAX> bytes missing"
msgstr[0] "包文件过早结束，缺少 %<PRIuMAX> 字节"
msgstr[1] "包文件过早结束，缺少 %<PRIuMAX> 字节"

#: builtin/index-pack.c
msgid "serious inflate inconsistency"
msgstr "解压缩严重的不一致"

#: builtin/index-pack.c
#, c-format
msgid "SHA1 COLLISION FOUND WITH %s !"
msgstr "发现 %s 出现 SHA1 冲突！"

#: builtin/index-pack.c
#, c-format
msgid "cannot read existing object info %s"
msgstr "不能读取现存对象信息 %s"

#: builtin/index-pack.c
#, c-format
msgid "cannot read existing object %s"
msgstr "不能读取现存对象 %s"

#: builtin/index-pack.c
#, c-format
msgid "invalid blob object %s"
msgstr "无效的数据对象 %s"

#: builtin/index-pack.c
msgid "fsck error in packed object"
msgstr "对打包对象 fsck 检查出错"

#: builtin/index-pack.c
#, c-format
msgid "Not all child objects of %s are reachable"
msgstr "%s 的所有子对象并非都可达"

#: builtin/index-pack.c
msgid "failed to apply delta"
msgstr "无法应用 delta"

#: builtin/index-pack.c
msgid "Receiving objects"
msgstr "接收对象中"

#: builtin/index-pack.c
msgid "Indexing objects"
msgstr "索引对象中"

#: builtin/index-pack.c
msgid "pack is corrupted (SHA1 mismatch)"
msgstr "包冲突（SHA1 不匹配）"

#: builtin/index-pack.c
msgid "cannot fstat packfile"
msgstr "不能对包文件调用 fstat"

#: builtin/index-pack.c
msgid "pack has junk at the end"
msgstr "包的结尾有垃圾数据"

#: builtin/index-pack.c
msgid "confusion beyond insanity in parse_pack_objects()"
msgstr "parse_pack_objects() 中遇到不可理喻的问题"

#: builtin/index-pack.c
msgid "Resolving deltas"
msgstr "处理 delta 中"

#: builtin/index-pack.c builtin/pack-objects.c
#, c-format
msgid "unable to create thread: %s"
msgstr "不能创建线程：%s"

#: builtin/index-pack.c
msgid "confusion beyond insanity"
msgstr "不可理喻"

#: builtin/index-pack.c
#, c-format
msgid "completed with %d local object"
msgid_plural "completed with %d local objects"
msgstr[0] "完成 %d 个本地对象"
msgstr[1] "完成 %d 个本地对象"

#: builtin/index-pack.c
#, c-format
msgid "Unexpected tail checksum for %s (disk corruption?)"
msgstr "对 %s 的尾部校验出现意外（磁盘损坏？）"

#: builtin/index-pack.c
#, c-format
msgid "pack has %d unresolved delta"
msgid_plural "pack has %d unresolved deltas"
msgstr[0] "包有 %d 个未解决的 delta"
msgstr[1] "包有 %d 个未解决的 delta"

#: builtin/index-pack.c
#, c-format
msgid "unable to deflate appended object (%d)"
msgstr "不能压缩附加对象（%d）"

#: builtin/index-pack.c
#, c-format
msgid "local object %s is corrupt"
msgstr "本地对象 %s 已损坏"

#: builtin/index-pack.c
#, c-format
msgid "packfile name '%s' does not end with '.%s'"
msgstr "包文件名 '%s' 没有以 '.%s' 结尾"

#: builtin/index-pack.c
#, c-format
msgid "cannot write %s file '%s'"
msgstr "无法写入 %s 文件 '%s'"

#: builtin/index-pack.c
#, c-format
msgid "cannot close written %s file '%s'"
msgstr "无法关闭已写入的 %s 文件 '%s'"

#: builtin/index-pack.c
#, c-format
msgid "unable to rename temporary '*.%s' file to '%s'"
msgstr "不能重命名临时文件 '*.%s' 为 '%s'"

#: builtin/index-pack.c
msgid "error while closing pack file"
msgstr "关闭包文件时出错"

#: builtin/index-pack.c builtin/pack-objects.c
#, c-format
msgid "bad pack.indexVersion=%<PRIu32>"
msgstr "坏的 pack.indexVersion=%<PRIu32>"

#: builtin/index-pack.c
#, c-format
msgid "Cannot open existing pack file '%s'"
msgstr "无法打开现存包文件 '%s'"

#: builtin/index-pack.c
#, c-format
msgid "Cannot open existing pack idx file for '%s'"
msgstr "无法为 %s 打开包索引文件"

#: builtin/index-pack.c
#, c-format
msgid "non delta: %d object"
msgid_plural "non delta: %d objects"
msgstr[0] "非 delta：%d 个对象"
msgstr[1] "非 delta：%d 个对象"

#: builtin/index-pack.c
#, c-format
msgid "chain length = %d: %lu object"
msgid_plural "chain length = %d: %lu objects"
msgstr[0] "链长 = %d: %lu 对象"
msgstr[1] "链长 = %d: %lu 对象"

#: builtin/index-pack.c
msgid "could not start pack-objects to repack local links"
msgstr "无法启动 pack-objects 来重新打包本地链接"

#: builtin/index-pack.c
msgid "failed to feed local object to pack-objects"
msgstr "无法将本地对象提供给 pack-objects"

#: builtin/index-pack.c
msgid "index-pack: Expecting full hex object ID lines only from pack-objects."
msgstr ""
"index-pack：期望仅从 pack-objects 的输出行中获得完整的十六进制对象 ID。"

#: builtin/index-pack.c
msgid "could not finish pack-objects to repack local links"
msgstr "无法完成 pack-objects 来重新打包本地链接"

#: builtin/index-pack.c
msgid "Cannot come back to cwd"
msgstr "无法返回当前工作目录"

#: builtin/index-pack.c builtin/unpack-objects.c
#, c-format
msgid "bad --pack_header: %s"
msgstr "错误的 --pack_header：%s"

#: builtin/index-pack.c
#, c-format
msgid "bad %s"
msgstr "错误选项 %s"

#: builtin/index-pack.c builtin/init-db.c setup.c
#, c-format
msgid "unknown hash algorithm '%s'"
msgstr "未知的哈希算法 '%s'"

#: builtin/index-pack.c
msgid "--promisor cannot be used with a pack name"
msgstr "--promisor 无法与包名称一起使用"

#: builtin/index-pack.c
msgid "--stdin requires a git repository"
msgstr "--stdin 需要 git 仓库"

#: builtin/index-pack.c
msgid "--verify with no packfile name given"
msgstr "--verify 没有提供包文件名参数"

#: builtin/index-pack.c builtin/unpack-objects.c
msgid "fsck error in pack objects"
msgstr "在打包对象中 fsck 检查出错"

#: builtin/init-db.c
msgid ""
"git init [-q | --quiet] [--bare] [--template=<template-directory>]\n"
"         [--separate-git-dir <git-dir>] [--object-format=<format>]\n"
"         [--ref-format=<format>]\n"
"         [-b <branch-name> | --initial-branch=<branch-name>]\n"
"         [--shared[=<permissions>]] [<directory>]"
msgstr ""
"git init [-q | --quiet] [--bare] [--template=<模板目录>]\n"
"         [--separate-git-dir <git 目录>] [--object-format=<格式>]\n"
"         [--ref-format=<格式>]\n"
"         [-b <分支名> | --initial-branch=<分支名>]\n"
"         [--shared[=<权限>]] [<目录>]"

#: builtin/init-db.c
msgid "permissions"
msgstr "权限"

#: builtin/init-db.c
msgid "specify that the git repository is to be shared amongst several users"
msgstr "指定 git 仓库是多个用户之间共享的"

#: builtin/init-db.c
msgid "override the name of the initial branch"
msgstr "覆盖初始分支名称"

#: builtin/init-db.c builtin/verify-pack.c
msgid "hash"
msgstr "hash"

#: builtin/init-db.c builtin/show-index.c builtin/verify-pack.c
msgid "specify the hash algorithm to use"
msgstr "指定要使用的哈希算法"

#: builtin/init-db.c
#, c-format
msgid "cannot mkdir %s"
msgstr "不能创建目录 %s"

#: builtin/init-db.c
#, c-format
msgid "cannot chdir to %s"
msgstr "不能切换目录到 %s"

#: builtin/init-db.c
#, c-format
msgid ""
"%s (or --work-tree=<directory>) not allowed without specifying %s (or --git-"
"dir=<directory>)"
msgstr "不允许 %s（或 --work-tree=<目录>）而没有指定 %s（或 --git-dir=<目录>）"

#: builtin/init-db.c
#, c-format
msgid "Cannot access work tree '%s'"
msgstr "不能访问工作区 '%s'"

#: builtin/init-db.c
msgid "--separate-git-dir incompatible with bare repository"
msgstr "--separate-git-dir 不能用于纯仓库"

#: builtin/interpret-trailers.c
msgid ""
"git interpret-trailers [--in-place] [--trim-empty]\n"
"                       [(--trailer (<key>|<key-alias>)[(=|:)<value>])...]\n"
"                       [--parse] [<file>...]"
msgstr ""
"git interpret-trailers [--in-place] [--trim-empty]\n"
"                       [(--trailer (<键|键别名>)[(=|:)<值>])...]\n"
"                       [--parse] [<文件>...]"

#: builtin/interpret-trailers.c wrapper.c
#, c-format
msgid "could not stat %s"
msgstr "不能对 %s 调用 stat"

#: builtin/interpret-trailers.c
#, c-format
msgid "file %s is not a regular file"
msgstr "文件 %s 不是一个普通文件"

#: builtin/interpret-trailers.c
#, c-format
msgid "file %s is not writable by user"
msgstr "文件 %s 用户不可写"

#: builtin/interpret-trailers.c
msgid "could not open temporary file"
msgstr "不能打开临时文件"

#: builtin/interpret-trailers.c
#, c-format
msgid "could not read input file '%s'"
msgstr "不能读取输入文件 '%s'"

#: builtin/interpret-trailers.c builtin/mktag.c imap-send.c
msgid "could not read from stdin"
msgstr "不能自标准输入读取"

#: builtin/interpret-trailers.c
#, c-format
msgid "could not rename temporary file to %s"
msgstr "不能重命名临时文件为 %s"

#: builtin/interpret-trailers.c
msgid "edit files in place"
msgstr "在原位编辑文件"

#: builtin/interpret-trailers.c
msgid "trim empty trailers"
msgstr "删除空的尾注"

#: builtin/interpret-trailers.c
msgid "placement"
msgstr "安置"

#: builtin/interpret-trailers.c
msgid "where to place the new trailer"
msgstr "在哪里放置新的尾注"

#: builtin/interpret-trailers.c
msgid "action if trailer already exists"
msgstr "当尾注已经存在时所采取的动作"

#: builtin/interpret-trailers.c
msgid "action if trailer is missing"
msgstr "当尾注缺失时所采取的动作"

#: builtin/interpret-trailers.c
msgid "output only the trailers"
msgstr "只输出尾注"

#: builtin/interpret-trailers.c
msgid "do not apply trailer.* configuration variables"
msgstr "不应用 trailer.* 配置变量"

#: builtin/interpret-trailers.c
msgid "reformat multiline trailer values as single-line values"
msgstr "将多行尾注值重新格式化为单行值"

#: builtin/interpret-trailers.c
msgid "alias for --only-trailers --only-input --unfold"
msgstr "--only-trailers --only-input --unfold 的别名"

#: builtin/interpret-trailers.c
msgid "do not treat \"---\" as the end of input"
msgstr "不要将 \"---\" 视为输入的结束"

#: builtin/interpret-trailers.c
msgid "trailer(s) to add"
msgstr "要添加的尾注"

#: builtin/interpret-trailers.c
msgid "--trailer with --only-input does not make sense"
msgstr "--trailer 和 --only-input 同时使用没有意义"

#: builtin/interpret-trailers.c
msgid "no input file given for in-place editing"
msgstr "没有给出要原位编辑的文件"

#: builtin/log.c
msgid "git log [<options>] [<revision-range>] [[--] <path>...]"
msgstr "git log [<选项>] [<版本范围>] [[--] <路径>...]"

#: builtin/log.c
msgid "git show [<options>] <object>..."
msgstr "git show [<选项>] <对象>..."

#: builtin/log.c
#, c-format
msgid "invalid --decorate option: %s"
msgstr "无效的 --decorate 选项：%s"

#: builtin/log.c diff.c
msgid "suppress diff output"
msgstr "不显示差异输出"

#: builtin/log.c
msgid "show source"
msgstr "显示源"

#: builtin/log.c
msgid "clear all previously-defined decoration filters"
msgstr "清除所有之前定义的修饰过滤器"

#: builtin/log.c
msgid "only decorate refs that match <pattern>"
msgstr "只修饰与 <模式> 匹配的引用"

#: builtin/log.c
msgid "do not decorate refs that match <pattern>"
msgstr "不修饰和 <模式> 匹配的引用"

#: builtin/log.c
msgid "decorate options"
msgstr "修饰选项"

#: builtin/log.c
msgid ""
"trace the evolution of line range <start>,<end> or function :<funcname> in "
"<file>"
msgstr "跟踪 <文件> 中 <开始>,<结束> 范围内的行或函数 :<函数名> 的演变"

#: builtin/log.c builtin/replay.c builtin/shortlog.c bundle.c
#, c-format
msgid "unrecognized argument: %s"
msgstr "未能识别的参数：%s"

#: builtin/log.c
msgid "-L<range>:<file> cannot be used with pathspec"
msgstr "-L<范围>:<文件> 不能和路径表达式共用"

#: builtin/log.c
#, c-format
msgid "Final output: %d %s\n"
msgstr "最终输出：%d %s\n"

#: builtin/log.c
#, c-format
msgid "git show %s: bad file"
msgstr "git show %s: 损坏的文件"

#: builtin/log.c
#, c-format
msgid "could not read object %s"
msgstr "不能读取对象 %s"

#: builtin/log.c
#, c-format
msgid "unknown type: %d"
msgstr "未知类型：%d"

#: builtin/log.c
#, c-format
msgid "%s: invalid cover from description mode"
msgstr "%s：从描述生成附函的模式无效"

#: builtin/log.c
msgid "format.headers without value"
msgstr "format.headers 没有值"

#: builtin/log.c
#, c-format
msgid "cannot open patch file %s"
msgstr "无法打开补丁文件 %s"

#: builtin/log.c
msgid "need exactly one range"
msgstr "只需要一个范围"

#: builtin/log.c
msgid "not a range"
msgstr "不是一个范围"

#: builtin/log.c
#, c-format
msgid "unable to read branch description file '%s'"
msgstr "无法读取分支描述文件 '%s'"

#: builtin/log.c
msgid "cover letter needs email format"
msgstr "附函需要邮件地址格式"

#: builtin/log.c
msgid "failed to create cover-letter file"
msgstr "无法创建附函文件"

#: builtin/log.c
#, c-format
msgid "insane in-reply-to: %s"
msgstr "不正常的 in-reply-to：%s"

#: builtin/log.c
msgid "git format-patch [<options>] [<since> | <revision-range>]"
msgstr "git format-patch [<选项>] [<从> | <版本范围>]"

#: builtin/log.c
msgid "two output directories?"
msgstr "两个输出目录？"

#: builtin/log.c
#, c-format
msgid "unknown commit %s"
msgstr "未知提交 %s"

#: builtin/log.c builtin/replace.c
#, c-format
msgid "failed to resolve '%s' as a valid ref"
msgstr "无法将 '%s' 解析为一个有效引用"

#: builtin/log.c
msgid "could not find exact merge base"
msgstr "不能找到准确的合并基线"

#: builtin/log.c
msgid ""
"failed to get upstream, if you want to record base commit automatically,\n"
"please use git branch --set-upstream-to to track a remote branch.\n"
"Or you could specify base commit by --base=<base-commit-id> manually"
msgstr ""
"无法得到上游地址，如果您想自动记录基线提交，请使用命令\n"
"git branch --set-upstream-to 来跟踪一个远程分支。或者您可以通过\n"
"参数 --base=<基线提交> 手动指定一个基线提交"

#: builtin/log.c
msgid "failed to find exact merge base"
msgstr "无法找到准确的合并基线"

#: builtin/log.c
msgid "base commit should be the ancestor of revision list"
msgstr "基线提交应该是版本列表的祖先"

#: builtin/log.c
msgid "base commit shouldn't be in revision list"
msgstr "基线提交不应该出现在版本列表中"

#: builtin/log.c
msgid "cannot get patch id"
msgstr "无法得到补丁 id"

#: builtin/log.c
msgid "failed to infer range-diff origin of current series"
msgstr "无法推断当前系列的 range-diff 起始"

#: builtin/log.c
#, c-format
msgid "using '%s' as range-diff origin of current series"
msgstr "使用 '%s' 作为当前系列的 range-diff 源"

#: builtin/log.c
msgid "use [PATCH n/m] even with a single patch"
msgstr "使用 [PATCH n/m]，即使只有一个补丁"

#: builtin/log.c
msgid "use [PATCH] even with multiple patches"
msgstr "使用 [PATCH]，即使有多个补丁"

#: builtin/log.c
msgid "print patches to standard out"
msgstr "打印补丁到标准输出"

#: builtin/log.c
msgid "generate a cover letter"
msgstr "生成一封附函"

#: builtin/log.c
msgid "use simple number sequence for output file names"
msgstr "使用简单的数字序列作为输出文件名"

#: builtin/log.c
msgid "sfx"
msgstr "后缀"

#: builtin/log.c
msgid "use <sfx> instead of '.patch'"
msgstr "使用 <后缀> 代替 '.patch'"

#: builtin/log.c
msgid "start numbering patches at <n> instead of 1"
msgstr "补丁以 <n> 开始编号，而不是1"

#: builtin/log.c
msgid "reroll-count"
msgstr "重制-计数"

#: builtin/log.c
msgid "mark the series as Nth re-roll"
msgstr "标记补丁系列是第几次重制"

#: builtin/log.c
msgid "max length of output filename"
msgstr "输出文件名的最大长度"

#: builtin/log.c
msgid "rfc"
msgstr "RFC"

#: builtin/log.c
msgid "add <rfc> (default 'RFC') before 'PATCH'"
msgstr "在 'PATCH' 之前添加 <RFC> （默认为 'RFC'）"

#: builtin/log.c
msgid "cover-from-description-mode"
msgstr "从分支描述获取附函的模式"

#: builtin/log.c
msgid "generate parts of a cover letter based on a branch's description"
msgstr "基于一个分支描述生成部分附函"

#: builtin/log.c
msgid "use branch description from file"
msgstr "使用来自文件的分支描述"

#: builtin/log.c
msgid "use [<prefix>] instead of [PATCH]"
msgstr "使用 [<前缀>] 代替 [PATCH]"

#: builtin/log.c
msgid "store resulting files in <dir>"
msgstr "把结果文件存储在 <目录>"

#: builtin/log.c
msgid "don't strip/add [PATCH]"
msgstr "不删除/添加 [PATCH]"

#: builtin/log.c
msgid "don't output binary diffs"
msgstr "不输出二进制差异"

#: builtin/log.c
msgid "output all-zero hash in From header"
msgstr "在 From 头信息中输出全为零的哈希值"

#: builtin/log.c
msgid "don't include a patch matching a commit upstream"
msgstr "不包含已在上游提交中的补丁"

#: builtin/log.c
msgid "show patch format instead of default (patch + stat)"
msgstr "显示纯补丁格式而非默认的（补丁+状态）"

#: builtin/log.c
msgid "Messaging"
msgstr "邮件发送"

#: builtin/log.c
msgid "header"
msgstr "header"

#: builtin/log.c
msgid "add email header"
msgstr "添加邮件头"

#: builtin/log.c
msgid "email"
msgstr "邮件地址"

#: builtin/log.c
msgid "add To: header"
msgstr "添加收件人"

#: builtin/log.c
msgid "add Cc: header"
msgstr "添加抄送"

#: builtin/log.c
msgid "ident"
msgstr "标识"

#: builtin/log.c
msgid "set From address to <ident> (or committer ident if absent)"
msgstr "将 From 地址设置为 <标识>（如若不提供，则用提交者 ID 做为地址）"

#: builtin/log.c
msgid "message-id"
msgstr "邮件标识"

#: builtin/log.c
msgid "make first mail a reply to <message-id>"
msgstr "使第一封邮件作为对 <邮件标识> 的回复"

#: builtin/log.c
msgid "boundary"
msgstr "边界"

#: builtin/log.c
msgid "attach the patch"
msgstr "附件方式添加补丁"

#: builtin/log.c
msgid "inline the patch"
msgstr "内联显示补丁"

#: builtin/log.c
msgid "enable message threading, styles: shallow, deep"
msgstr "启用邮件线索，风格：浅，深"

#: builtin/log.c
msgid "signature"
msgstr "签名"

#: builtin/log.c
msgid "add a signature"
msgstr "添加一个签名"

#: builtin/log.c
msgid "base-commit"
msgstr "基线提交"

#: builtin/log.c
msgid "add prerequisite tree info to the patch series"
msgstr "为补丁列表添加前置树信息"

#: builtin/log.c
msgid "add a signature from a file"
msgstr "从文件添加一个签名"

#: builtin/log.c
msgid "don't print the patch filenames"
msgstr "不要打印补丁文件名"

#: builtin/log.c
msgid "show progress while generating patches"
msgstr "在生成补丁时显示进度"

#: builtin/log.c
msgid "show changes against <rev> in cover letter or single patch"
msgstr "在附函或单个补丁中显示和 <版本> 的差异"

#: builtin/log.c
msgid "show changes against <refspec> in cover letter or single patch"
msgstr "在附函或单个补丁中显示和 <引用规格> 的差异"

#: builtin/log.c builtin/range-diff.c
msgid "percentage by which creation is weighted"
msgstr "创建权重的百分比"

#: builtin/log.c
msgid "show in-body From: even if identical to the e-mail header"
msgstr "显示正文内的 From:，即使其与电子邮件头中一致"

#: builtin/log.c
#, c-format
msgid "invalid ident line: %s"
msgstr "包含无效的身份标识：%s"

#: builtin/log.c
msgid "--name-only does not make sense"
msgstr "--name-only 无意义"

#: builtin/log.c
msgid "--name-status does not make sense"
msgstr "--name-status 无意义"

#: builtin/log.c
msgid "--check does not make sense"
msgstr "--check 无意义"

#: builtin/log.c
msgid "--remerge-diff does not make sense"
msgstr "--remerge-diff 无意义"

#: builtin/log.c builtin/submodule--helper.c rerere.c submodule.c
#, c-format
msgid "could not create directory '%s'"
msgstr "不能创建目录 '%s'"

#: builtin/log.c
msgid "--interdiff requires --cover-letter or single patch"
msgstr "--interdiff 需要 --cover-letter 或单一补丁"

#: builtin/log.c
msgid "Interdiff:"
msgstr "版本间差异："

#: builtin/log.c
#, c-format
msgid "Interdiff against v%d:"
msgstr "对 v%d 的版本差异："

#: builtin/log.c
msgid "--range-diff requires --cover-letter or single patch"
msgstr "--range-diff 需要 --cover-letter 或单一补丁"

#: builtin/log.c
msgid "Range-diff:"
msgstr "范围差异："

#: builtin/log.c
#, c-format
msgid "Range-diff against v%d:"
msgstr "对 v%d 的范围差异："

#: builtin/log.c
#, c-format
msgid "unable to read signature file '%s'"
msgstr "无法读取签名文件 '%s'"

#: builtin/log.c
msgid "Generating patches"
msgstr "生成补丁"

#: builtin/log.c
msgid "failed to create output files"
msgstr "无法创建输出文件"

#: builtin/log.c
msgid "git cherry [-v] [<upstream> [<head> [<limit>]]]"
msgstr "git cherry [-v] [<上游> [<头> [<限制>]]]"

#: builtin/log.c
#, c-format
msgid ""
"Could not find a tracked remote branch, please specify <upstream> manually.\n"
msgstr "不能找到跟踪的远程分支，请手工指定 <上游>。\n"

#: builtin/ls-files.c builtin/ls-tree.c
#, c-format
msgid "could not get object info about '%s'"
msgstr "无法获得关于 '%s' 的对象信息"

#: builtin/ls-files.c
msgid "git ls-files [<options>] [<file>...]"
msgstr "git ls-files [<选项>] [<文件>...]"

#: builtin/ls-files.c builtin/merge-tree.c
msgid "separate paths with the NUL character"
msgstr "用 NUL 字符分隔路径"

#: builtin/ls-files.c
msgid "identify the file status with tags"
msgstr "用标签标识文件的状态"

#: builtin/ls-files.c
msgid "use lowercase letters for 'assume unchanged' files"
msgstr "使用小写字母表示 '假设未改变的' 文件"

#: builtin/ls-files.c
msgid "use lowercase letters for 'fsmonitor clean' files"
msgstr "使用小写字母表示 'fsmonitor clean' 文件"

#: builtin/ls-files.c
msgid "show cached files in the output (default)"
msgstr "显示缓存的文件（默认）"

#: builtin/ls-files.c
msgid "show deleted files in the output"
msgstr "显示已删除的文件"

#: builtin/ls-files.c
msgid "show modified files in the output"
msgstr "显示已修改的文件"

#: builtin/ls-files.c
msgid "show other files in the output"
msgstr "显示其它文件"

#: builtin/ls-files.c
msgid "show ignored files in the output"
msgstr "显示忽略的文件"

#: builtin/ls-files.c
msgid "show staged contents' object name in the output"
msgstr "显示暂存区内容的对象名称"

#: builtin/ls-files.c
msgid "show files on the filesystem that need to be removed"
msgstr "显示文件系统需要删除的文件"

#: builtin/ls-files.c
msgid "show 'other' directories' names only"
msgstr "只显示“其他”目录的名称"

#: builtin/ls-files.c
msgid "show line endings of files"
msgstr "显示文件换行符格式"

#: builtin/ls-files.c
msgid "don't show empty directories"
msgstr "不显示空目录"

#: builtin/ls-files.c
msgid "show unmerged files in the output"
msgstr "显示未合并的文件"

#: builtin/ls-files.c
msgid "show resolve-undo information"
msgstr "显示 resolve-undo 信息"

#: builtin/ls-files.c
msgid "skip files matching pattern"
msgstr "跳过和模式匹配的文件"

#: builtin/ls-files.c
msgid "read exclude patterns from <file>"
msgstr "从 <文件> 读取排除模式"

#: builtin/ls-files.c
msgid "read additional per-directory exclude patterns in <file>"
msgstr "从 <文件> 读取额外的每个目录的排除模式"

#: builtin/ls-files.c
msgid "add the standard git exclusions"
msgstr "添加标准的 git 排除"

#: builtin/ls-files.c
msgid "make the output relative to the project top directory"
msgstr "显示相对于顶级目录的文件名"

#: builtin/ls-files.c
msgid "if any <file> is not in the index, treat this as an error"
msgstr "如果任何 <文件> 都不在索引区，视为错误"

#: builtin/ls-files.c builtin/merge-tree.c
msgid "tree-ish"
msgstr "树对象"

#: builtin/ls-files.c
msgid "pretend that paths removed since <tree-ish> are still present"
msgstr "假装自从 <树对象> 之后删除的路径仍然存在"

#: builtin/ls-files.c
msgid "show debugging data"
msgstr "显示调试数据"

#: builtin/ls-files.c
msgid "suppress duplicate entries"
msgstr "抑制重复条目"

#: builtin/ls-files.c
msgid "show sparse directories in the presence of a sparse index"
msgstr "在稀疏索引存在时显示稀疏目录"

#: builtin/ls-files.c
msgid ""
"--format cannot be used with -s, -o, -k, -t, --resolve-undo, --deduplicate, "
"--eol"
msgstr ""
"--format 不能和 -s、-o、-k、-t、--resolve-undo、--deduplicate 和 --eol 同时使"
"用"

#: builtin/ls-remote.c
msgid ""
"git ls-remote [--branches] [--tags] [--refs] [--upload-pack=<exec>]\n"
"              [-q | --quiet] [--exit-code] [--get-url] [--sort=<key>]\n"
"              [--symref] [<repository> [<patterns>...]]"
msgstr ""
"git ls-remote [--branches] [--tags] [--refs] [--upload-pack=<可执行文件>]\n"
"              [-q | --quiet] [--exit-code] [--get-url] [--sort=<键>]\n"
"              [--symref] [<仓库> [<模式>...]]"

#: builtin/ls-remote.c
msgid "do not print remote URL"
msgstr "不打印远程 URL"

#: builtin/ls-remote.c builtin/rebase.c
msgid "exec"
msgstr "exec"

#: builtin/ls-remote.c
msgid "path of git-upload-pack on the remote host"
msgstr "远程主机上的 git-upload-pack 路径"

#: builtin/ls-remote.c
msgid "limit to tags"
msgstr "仅限于标签"

#: builtin/ls-remote.c
msgid "limit to branches"
msgstr "仅限于分支"

#: builtin/ls-remote.c builtin/show-ref.c
msgid "deprecated synonym for --branches"
msgstr "已弃用的 --branches 同义词"

#: builtin/ls-remote.c
msgid "do not show peeled tags"
msgstr "不显示已解析的标签"

#: builtin/ls-remote.c
msgid "take url.<base>.insteadOf into account"
msgstr "参考 url.<base>.insteadOf 设置"

#: builtin/ls-remote.c
msgid "exit with exit code 2 if no matching refs are found"
msgstr "若未找到匹配的引用则以退出码2退出"

#: builtin/ls-remote.c
msgid "show underlying ref in addition to the object pointed by it"
msgstr "除了显示指向的对象外，显示指向的引用名"

#: builtin/ls-tree.c
msgid "git ls-tree [<options>] <tree-ish> [<path>...]"
msgstr "git ls-tree [<选项>] <树对象> [<路径>...]"

#: builtin/ls-tree.c
msgid "only show trees"
msgstr "只显示树"

#: builtin/ls-tree.c
msgid "recurse into subtrees"
msgstr "递归到子树"

#: builtin/ls-tree.c
msgid "show trees when recursing"
msgstr "当递归时显示树"

#: builtin/ls-tree.c
msgid "terminate entries with NUL byte"
msgstr "条目以 NUL 字符终止"

#: builtin/ls-tree.c
msgid "include object size"
msgstr "包括对象大小"

#: builtin/ls-tree.c
msgid "list only filenames"
msgstr "只列出文件名"

#: builtin/ls-tree.c
msgid "list only objects"
msgstr "只列出对象"

#: builtin/ls-tree.c
msgid "use full path names"
msgstr "使用文件的全路径"

#: builtin/ls-tree.c
msgid "list entire tree; not just current directory (implies --full-name)"
msgstr "列出整个树；不仅仅当前目录（隐含 --full-name）"

#: builtin/ls-tree.c
msgid "--format can't be combined with other format-altering options"
msgstr "--format 不能和改变格式的选项同时使用"

#. TRANSLATORS: keep <> in "<" mail ">" info.
#: builtin/mailinfo.c
msgid "git mailinfo [<options>] <msg> <patch> < mail >info"
msgstr "git mailinfo [<选项>] <消息> <补丁> < mail >info"

#: builtin/mailinfo.c
msgid "keep subject"
msgstr "保持主题"

#: builtin/mailinfo.c
msgid "keep non patch brackets in subject"
msgstr "在主题中保持无补丁括号标注"

#: builtin/mailinfo.c
msgid "copy Message-ID to the end of commit message"
msgstr "拷贝 Message-ID 至提交说明结尾"

#: builtin/mailinfo.c
msgid "re-code metadata to i18n.commitEncoding"
msgstr "将元数据重新编码为 i18n.commitEncoding"

#: builtin/mailinfo.c
msgid "disable charset re-coding of metadata"
msgstr "禁用元数据的字符集重新编码"

#: builtin/mailinfo.c
msgid "encoding"
msgstr "编码"

#: builtin/mailinfo.c
msgid "re-code metadata to this encoding"
msgstr "将元数据用此编码重新编码"

#: builtin/mailinfo.c
msgid "use scissors"
msgstr "使用剪刀标记"

#: builtin/mailinfo.c
msgid "<action>"
msgstr "<动作>"

#: builtin/mailinfo.c
msgid "action when quoted CR is found"
msgstr "找到引号中的 CR 时的操作"

#: builtin/mailinfo.c
msgid "use headers in message's body"
msgstr "在消息正文中使用标头"

#: builtin/mailsplit.c
msgid "reading patches from stdin/tty..."
msgstr "从标准输入或tty读取补丁……"

#: builtin/mailsplit.c
#, c-format
msgid "empty mbox: '%s'"
msgstr "空的 mbox：'%s'"

#: builtin/merge-base.c
msgid "git merge-base [-a | --all] <commit> <commit>..."
msgstr "git merge-base [-a | --all] <提交> <提交>..."

#: builtin/merge-base.c
msgid "git merge-base [-a | --all] --octopus <commit>..."
msgstr "git merge-base [-a | --all] --octopus <提交>..."

#: builtin/merge-base.c
msgid "git merge-base --is-ancestor <commit> <commit>"
msgstr "git merge-base --is-ancestor <提交> <提交>"

#: builtin/merge-base.c
msgid "git merge-base --independent <commit>..."
msgstr "git merge-base --independent <提交>..."

#: builtin/merge-base.c
msgid "git merge-base --fork-point <ref> [<commit>]"
msgstr "git merge-base --fork-point <引用> [<提交>]"

#: builtin/merge-base.c
msgid "output all common ancestors"
msgstr "输出所有共同的祖先"

#: builtin/merge-base.c
msgid "find ancestors for a single n-way merge"
msgstr "查找一个多路合并的祖先提交"

#: builtin/merge-base.c
msgid "list revs not reachable from others"
msgstr "显示不能被其他访问到的版本"

#: builtin/merge-base.c
msgid "is the first one ancestor of the other?"
msgstr "第一个是其他的祖先提交么？"

#: builtin/merge-base.c
msgid "find where <commit> forked from reflog of <ref>"
msgstr "根据 <引用> 的引用日志查找 <提交> 的分叉点"

#: builtin/merge-file.c
msgid ""
"git merge-file [<options>] [-L <name1> [-L <orig> [-L <name2>]]] <file1> "
"<orig-file> <file2>"
msgstr ""
"git merge-file [<选项>] [-L <名字1> [-L <初始名字> [-L <名字2>]]] <文件1> <初"
"始文件> <文件2>"

#: builtin/merge-file.c diff.c
msgid ""
"option diff-algorithm accepts \"myers\", \"minimal\", \"patience\" and "
"\"histogram\""
msgstr ""
"选项 diff-algorithm 接受参数 \"myers\"、\"minimal\"、\"patience\" 和 "
"\"histogram\""

#: builtin/merge-file.c
msgid "send results to standard output"
msgstr "将结果发送到标准输出"

#: builtin/merge-file.c
msgid "use object IDs instead of filenames"
msgstr "使用对象 ID 替换文件名"

#: builtin/merge-file.c
msgid "use a diff3 based merge"
msgstr "使用基于 diff3 的合并"

#: builtin/merge-file.c
msgid "use a zealous diff3 based merge"
msgstr "使用基于狂热 diff3（zealous diff3）的合并"

#: builtin/merge-file.c diff.c
msgid "<algorithm>"
msgstr "<算法>"

#: builtin/merge-file.c diff.c
msgid "choose a diff algorithm"
msgstr "选择一个差异算法"

#: builtin/merge-file.c
msgid "for conflicts, use this marker size"
msgstr "如果冲突，使用指定长度的标记"

#: builtin/merge-file.c
msgid "do not warn about conflicts"
msgstr "不要警告冲突"

#: builtin/merge-file.c
msgid "set labels for file1/orig-file/file2"
msgstr "为 文件1/初始文件/文件2 设置标签"

#: builtin/merge-file.c
#, c-format
msgid "object '%s' does not exist"
msgstr "对象 '%s' 不存在"

#: builtin/merge-file.c
msgid "Could not write object file"
msgstr "不能写入对象文件"

#: builtin/merge-recursive.c
#, c-format
msgid "unknown option %s"
msgstr "未知选项 %s"

#: builtin/merge-recursive.c
#, c-format
msgid "could not parse object '%s'"
msgstr "不能解析对象 '%s'"

#: builtin/merge-recursive.c
#, c-format
msgid "cannot handle more than %d base. Ignoring %s."
msgid_plural "cannot handle more than %d bases. Ignoring %s."
msgstr[0] "无法处理 %d 条以上的基线。忽略 %s。"
msgstr[1] "无法处理 %d 条以上的基线。忽略 %s。"

#: builtin/merge-recursive.c
msgid "not handling anything other than two heads merge."
msgstr "不能处理两个头合并之外的任何操作。"

#: builtin/merge-recursive.c
#, c-format
msgid "could not resolve ref '%s'"
msgstr "无法解析引用 '%s'"

#: builtin/merge-recursive.c
#, c-format
msgid "Merging %s with %s\n"
msgstr "合并 %s 和 %s\n"

#: builtin/merge-tree.c
#, c-format
msgid "could not parse as tree '%s'"
msgstr "无法解析为树对象 '%s'"

#: builtin/merge-tree.c builtin/merge.c
msgid "not something we can merge"
msgstr "不是可以合并的东西"

#: builtin/merge-tree.c builtin/merge.c
msgid "refusing to merge unrelated histories"
msgstr "拒绝合并无关的历史"

#: builtin/merge-tree.c
msgid "failure to merge"
msgstr "合并失败"

#: builtin/merge-tree.c
msgid "git merge-tree [--write-tree] [<options>] <branch1> <branch2>"
msgstr "git merge-tree [--write-tree] [<选项>] <分支1> <分支2>"

#: builtin/merge-tree.c
msgid "git merge-tree [--trivial-merge] <base-tree> <branch1> <branch2>"
msgstr "git merge-tree [--trivial-merge] <基准树> <分支1> <分支2>"

#: builtin/merge-tree.c
msgid "do a real merge instead of a trivial merge"
msgstr "进行真正的合并而不是简单的合并"

#: builtin/merge-tree.c
msgid "do a trivial merge only"
msgstr "只进行简单的合并"

#: builtin/merge-tree.c
msgid "also show informational/conflict messages"
msgstr "同时显示额外信息/冲突消息"

#: builtin/merge-tree.c
msgid "list filenames without modes/oids/stages"
msgstr "列出没有模式/对象 ID/暂存的文件名"

#: builtin/merge-tree.c builtin/merge.c builtin/pull.c
msgid "allow merging unrelated histories"
msgstr "允许合并不相关的历史"

#: builtin/merge-tree.c
msgid "perform multiple merges, one per line of input"
msgstr "实施多个合并，每输入行一个"

#: builtin/merge-tree.c
msgid "specify a merge-base for the merge"
msgstr "指定用于合并的合并基线"

#: builtin/merge-tree.c builtin/merge.c builtin/pull.c
msgid "option=value"
msgstr "option=value"

#: builtin/merge-tree.c builtin/merge.c builtin/pull.c
msgid "option for selected merge strategy"
msgstr "所选的合并策略的选项"

#: builtin/merge-tree.c
msgid "--trivial-merge is incompatible with all other options"
msgstr "--trivial-merge 与其他所有选项不兼容"

#: builtin/merge-tree.c builtin/merge.c
#, c-format
msgid "unknown strategy option: -X%s"
msgstr "未知的策略选项：-X%s"

#: builtin/merge-tree.c builtin/notes.c
#, c-format
msgid "malformed input line: '%s'."
msgstr "格式错误的输入行：'%s'。"

#: builtin/merge.c
msgid "git merge [<options>] [<commit>...]"
msgstr "git merge [<选项>] [<提交>...]"

#: builtin/merge.c
msgid "switch `m' requires a value"
msgstr "开关 `m' 需要一个值"

#: builtin/merge.c
#, c-format
msgid "option `%s' requires a value"
msgstr "选项 `%s' 需要一个值"

#: builtin/merge.c
#, c-format
msgid "Could not find merge strategy '%s'.\n"
msgstr "不能找到合并策略 '%s'。\n"

#: builtin/merge.c
#, c-format
msgid "Available strategies are:"
msgstr "可用的策略有："

#: builtin/merge.c
#, c-format
msgid "Available custom strategies are:"
msgstr "可用的自定义策略有："

#: builtin/merge.c builtin/pull.c
msgid "do not show a diffstat at the end of the merge"
msgstr "在合并的最后不显示差异统计"

#: builtin/merge.c builtin/pull.c
msgid "show a diffstat at the end of the merge"
msgstr "在合并的最后显示差异统计"

#: builtin/merge.c builtin/pull.c
msgid "(synonym to --stat)"
msgstr "（和 --stat 同义）"

#: builtin/merge.c builtin/pull.c
msgid "add (at most <n>) entries from shortlog to merge commit message"
msgstr "在合并提交信息中添加（最多 <n> 条）精简提交记录"

#: builtin/merge.c builtin/pull.c
msgid "create a single commit instead of doing a merge"
msgstr "创建一个单独的提交而不是做一次合并"

#: builtin/merge.c builtin/pull.c
msgid "perform a commit if the merge succeeds (default)"
msgstr "如果合并成功，执行一次提交（默认）"

#: builtin/merge.c builtin/pull.c
msgid "edit message before committing"
msgstr "在提交前编辑提交说明"

#: builtin/merge.c
msgid "allow fast-forward (default)"
msgstr "允许快进（默认）"

#: builtin/merge.c builtin/pull.c
msgid "abort if fast-forward is not possible"
msgstr "如果不能快进就放弃合并"

#: builtin/merge.c builtin/pull.c
msgid "verify that the named commit has a valid GPG signature"
msgstr "验证指定的提交是否包含一个有效的 GPG 签名"

#: builtin/merge.c builtin/notes.c builtin/pull.c builtin/rebase.c
#: builtin/revert.c
msgid "strategy"
msgstr "策略"

#: builtin/merge.c builtin/pull.c
msgid "merge strategy to use"
msgstr "要使用的合并策略"

#: builtin/merge.c
msgid "merge commit message (for a non-fast-forward merge)"
msgstr "合并的提交说明（针对非快进式合并）"

#: builtin/merge.c
msgid "use <name> instead of the real target"
msgstr "使用 <名称> 而不是真正的目标"

#: builtin/merge.c
msgid "abort the current in-progress merge"
msgstr "放弃当前正在进行的合并"

#
#: builtin/merge.c
msgid "--abort but leave index and working tree alone"
msgstr "--abort，但是保留索引和工作区"

#: builtin/merge.c
msgid "continue the current in-progress merge"
msgstr "继续当前正在进行的合并"

#: builtin/merge.c
msgid "bypass pre-merge-commit and commit-msg hooks"
msgstr "绕过 pre-merge-commit 和 commit-msg 钩子"

#: builtin/merge.c
msgid "could not run stash."
msgstr "不能运行贮藏。"

#: builtin/merge.c
msgid "stash failed"
msgstr "贮藏失败"

#: builtin/merge.c
#, c-format
msgid "not a valid object: %s"
msgstr "不是一个有效对象：%s"

#: builtin/merge.c
msgid "read-tree failed"
msgstr "读取树失败"

#: builtin/merge.c
msgid "Already up to date. (nothing to squash)"
msgstr "已经是最新的。（无可挤压）"

#: builtin/merge.c merge-ort-wrappers.c merge-recursive.c
msgid "Already up to date."
msgstr "已经是最新的。"

#: builtin/merge.c
#, c-format
msgid "Squash commit -- not updating HEAD\n"
msgstr "挤压提交 -- 未更新 HEAD\n"

#: builtin/merge.c
#, c-format
msgid "No merge message -- not updating HEAD\n"
msgstr "无合并信息 -- 未更新 HEAD\n"

#: builtin/merge.c
#, c-format
msgid "'%s' does not point to a commit"
msgstr "'%s' 没有指向一个提交"

#: builtin/merge.c
#, c-format
msgid "Bad branch.%s.mergeoptions string: %s"
msgstr "坏的 branch.%s.mergeoptions 字符串：%s"

#: builtin/merge.c merge-recursive.c
msgid "Unable to write index."
msgstr "不能写入索引。"

#: builtin/merge.c
msgid "Not handling anything other than two heads merge."
msgstr "未处理两个头合并之外的任何操作。"

#: builtin/merge.c builtin/sparse-checkout.c
#, c-format
msgid "unable to write %s"
msgstr "不能写 %s"

#: builtin/merge.c
#, c-format
msgid "Could not read from '%s'"
msgstr "不能从 '%s' 读取"

#: builtin/merge.c
#, c-format
msgid "Not committing merge; use 'git commit' to complete the merge.\n"
msgstr "未提交合并，使用 'git commit' 完成此次合并。\n"

#: builtin/merge.c
msgid ""
"Please enter a commit message to explain why this merge is necessary,\n"
"especially if it merges an updated upstream into a topic branch.\n"
"\n"
msgstr ""
"请输入一个提交信息以解释此合并的必要性，尤其是将一个更新后的上游分支\n"
"合并到主题分支。\n"
"\n"

#: builtin/merge.c
msgid "An empty message aborts the commit.\n"
msgstr "空的提交说明会终止提交。\n"

#: builtin/merge.c
#, c-format
msgid ""
"Lines starting with '%s' will be ignored, and an empty message aborts\n"
"the commit.\n"
msgstr "以 '%s' 开始的行将被忽略，而空的提交说明将终止提交。\n"

#: builtin/merge.c
msgid "Empty commit message."
msgstr "空提交信息。"

#: builtin/merge.c
#, c-format
msgid "Wonderful.\n"
msgstr "太棒了。\n"

#: builtin/merge.c
#, c-format
msgid "Automatic merge failed; fix conflicts and then commit the result.\n"
msgstr "自动合并失败，修正冲突然后提交修正的结果。\n"

#: builtin/merge.c
msgid "No current branch."
msgstr "没有当前分支。"

#: builtin/merge.c
msgid "No remote for the current branch."
msgstr "当前分支没有对应的远程仓库。"

#: builtin/merge.c
msgid "No default upstream defined for the current branch."
msgstr "当前分支没有定义默认的上游分支。"

#: builtin/merge.c
#, c-format
msgid "No remote-tracking branch for %s from %s"
msgstr "对于 %s 没有来自 %s 的远程跟踪分支"

#: builtin/merge.c
#, c-format
msgid "Bad value '%s' in environment '%s'"
msgstr "环境 '%2$s' 中存在坏的取值 '%1$s'"

#: builtin/merge.c editor.c read-cache.c wrapper.c
#, c-format
msgid "could not close '%s'"
msgstr "不能关闭 '%s'"

#: builtin/merge.c
#, c-format
msgid "not something we can merge in %s: %s"
msgstr "不能在 %s 中合并：%s"

#: builtin/merge.c
msgid "--abort expects no arguments"
msgstr "--abort 不带参数"

#: builtin/merge.c
msgid "There is no merge to abort (MERGE_HEAD missing)."
msgstr "没有要终止的合并（MERGE_HEAD 丢失）。"

#: builtin/merge.c
msgid "--quit expects no arguments"
msgstr "--quit 不带参数"

#: builtin/merge.c
msgid "--continue expects no arguments"
msgstr "--continue 不带参数"

#: builtin/merge.c
msgid "There is no merge in progress (MERGE_HEAD missing)."
msgstr "没有进行中的合并（MERGE_HEAD 丢失）。"

#: builtin/merge.c
msgid ""
"You have not concluded your merge (MERGE_HEAD exists).\n"
"Please, commit your changes before you merge."
msgstr ""
"您尚未结束您的合并（存在 MERGE_HEAD）。\n"
"请在合并前先提交您的修改。"

#: builtin/merge.c
msgid ""
"You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists).\n"
"Please, commit your changes before you merge."
msgstr ""
"您尚未结束您的拣选（存在 CHERRY_PICK_HEAD）。\n"
"请在合并前先提交您的修改。"

#: builtin/merge.c
msgid "You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists)."
msgstr "您尚未结束您的拣选（存在 CHERRY_PICK_HEAD）。"

#: builtin/merge.c
msgid "No commit specified and merge.defaultToUpstream not set."
msgstr "未指定提交并且 merge.defaultToUpstream 未设置。"

#: builtin/merge.c
msgid "Squash commit into empty head not supported yet"
msgstr "尚不支持到空分支的压缩提交"

#: builtin/merge.c
msgid "Non-fast-forward commit does not make sense into an empty head"
msgstr "到空分支的非快进式提交没有意义"

#: builtin/merge.c
#, c-format
msgid "%s - not something we can merge"
msgstr "%s - 不能被合并"

#: builtin/merge.c
msgid "Can merge only exactly one commit into empty head"
msgstr "只能将一个提交合并到空分支上"

#: builtin/merge.c
#, c-format
msgid "Updating %s..%s\n"
msgstr "更新 %s..%s\n"

#: builtin/merge.c merge-ort-wrappers.c merge-recursive.c
#, c-format
msgid ""
"Your local changes to the following files would be overwritten by merge:\n"
"  %s"
msgstr ""
"您对下列文件的本地修改将被合并操作覆盖：\n"
"  %s"

#: builtin/merge.c
#, c-format
msgid "Trying really trivial in-index merge...\n"
msgstr "尝试非常小的索引内合并...\n"

#: builtin/merge.c
#, c-format
msgid "Nope.\n"
msgstr "无。\n"

#: builtin/merge.c
#, c-format
msgid "Rewinding the tree to pristine...\n"
msgstr "将树回滚至原始状态...\n"

#: builtin/merge.c
#, c-format
msgid "Trying merge strategy %s...\n"
msgstr "尝试合并策略 %s...\n"

#: builtin/merge.c
#, c-format
msgid "No merge strategy handled the merge.\n"
msgstr "没有合并策略处理此合并。\n"

#: builtin/merge.c
#, c-format
msgid "Merge with strategy %s failed.\n"
msgstr "使用策略 %s 合并失败。\n"

#: builtin/merge.c
#, c-format
msgid "Using the %s strategy to prepare resolving by hand.\n"
msgstr "使用 %s 策略以准备手工解决。\n"

#: builtin/merge.c
#, c-format
msgid "Automatic merge went well; stopped before committing as requested\n"
msgstr "自动合并进展顺利，按要求在提交前停止\n"

#: builtin/merge.c
#, c-format
msgid "When finished, apply stashed changes with `git stash pop`\n"
msgstr "在完成后，使用 `git stash pop` 应用贮藏的变更\n"

#: builtin/mktag.c
#, c-format
msgid "warning: tag input does not pass fsck: %s"
msgstr "警告：标签输入未通过 fsck：%s"

#: builtin/mktag.c
#, c-format
msgid "error: tag input does not pass fsck: %s"
msgstr "错误：标签输入未通过 fsck：%s"

#: builtin/mktag.c
#, c-format
msgid "%d (FSCK_IGNORE?) should never trigger this callback"
msgstr "%d (FSCK_IGNORE?) 永远不应该触发这个回调"

#: builtin/mktag.c
#, c-format
msgid "could not read tagged object '%s'"
msgstr "不能读取被标记的对象 '%s'"

#: builtin/mktag.c
#, c-format
msgid "object '%s' tagged as '%s', but is a '%s' type"
msgstr "对象 '%s' 被标记为 '%s'，然而是一个 '%s' 类型"

#: builtin/mktag.c
msgid "tag on stdin did not pass our strict fsck check"
msgstr "标准输入上的标签未通过我们严格的 fsck 检查"

#: builtin/mktag.c
msgid "tag on stdin did not refer to a valid object"
msgstr "标准输入上的标签未指向一个有效的对象"

#: builtin/mktag.c builtin/tag.c
msgid "unable to write tag file"
msgstr "无法写标签文件"

#: builtin/mktree.c
msgid "input is NUL terminated"
msgstr "输入以 NUL 字符终止"

#: builtin/mktree.c builtin/write-tree.c
msgid "allow missing objects"
msgstr "允许丢失的对象"

#: builtin/mktree.c
msgid "allow creation of more than one tree"
msgstr "允许创建一个以上的树"

#: builtin/multi-pack-index.c
msgid ""
"git multi-pack-index [<options>] write [--preferred-pack=<pack>][--refs-"
"snapshot=<path>]"
msgstr ""
"git multi-pack-index [<选项>] write [--preferred-pack=<包>][--refs-snapshot=<"
"路径>]"

#: builtin/multi-pack-index.c
msgid "git multi-pack-index [<options>] verify"
msgstr "git multi-pack-index [<选项>] verify"

#: builtin/multi-pack-index.c
msgid "git multi-pack-index [<options>] expire"
msgstr "git multi-pack-index [<选项>] expire"

#: builtin/multi-pack-index.c
msgid "git multi-pack-index [<options>] repack [--batch-size=<size>]"
msgstr "git multi-pack-index [<选项>] repack [--batch-size=<尺寸>]"

#: builtin/multi-pack-index.c
msgid "directory"
msgstr "目录"

#: builtin/multi-pack-index.c
msgid "object directory containing set of packfile and pack-index pairs"
msgstr "包含成对包文件和包索引的对象目录"

#: builtin/multi-pack-index.c
msgid "preferred-pack"
msgstr "首选包"

#: builtin/multi-pack-index.c
msgid "pack for reuse when computing a multi-pack bitmap"
msgstr "在计算多包位图时打包以供重用"

#: builtin/multi-pack-index.c
msgid "write multi-pack bitmap"
msgstr "写入多包位图"

#: builtin/multi-pack-index.c
msgid "write a new incremental MIDX"
msgstr "写入一个新的增量 MIDX"

#: builtin/multi-pack-index.c
msgid "write multi-pack index containing only given indexes"
msgstr "写入只包括给定索引的多包索引"

#: builtin/multi-pack-index.c
msgid "refs snapshot for selecting bitmap commits"
msgstr "用于选择位图提交的引用快照"

#: builtin/multi-pack-index.c
msgid ""
"during repack, collect pack-files of smaller size into a batch that is "
"larger than this size"
msgstr "在 repack 期间，将较小尺寸的包文件收集到大于此大小的批次中"

#: builtin/mv.c
msgid "git mv [<options>] <source>... <destination>"
msgstr "git mv [<选项>] <源>... <目标>"

#: builtin/mv.c
#, c-format
msgid "Directory %s is in index and no submodule?"
msgstr "目录 %s 在索引中并且不是子模组？"

#: builtin/mv.c
msgid "Please stage your changes to .gitmodules or stash them to proceed"
msgstr "请将您的修改暂存到 .gitmodules 中或贮藏后再继续"

#: builtin/mv.c
#, c-format
msgid "%.*s is in index"
msgstr "%.*s 在索引中"

#: builtin/mv.c
msgid "force move/rename even if target exists"
msgstr "强制移动/重命令，即使目标存在"

#: builtin/mv.c
msgid "skip move/rename errors"
msgstr "跳过移动/重命名错误"

#: builtin/mv.c
#, c-format
msgid "destination '%s' is not a directory"
msgstr "目标 '%s' 不是一个目录"

#: builtin/mv.c
#, c-format
msgid "Checking rename of '%s' to '%s'\n"
msgstr "检查 '%s' 到 '%s' 的重命名\n"

#: builtin/mv.c
msgid "bad source"
msgstr "坏的源"

#: builtin/mv.c
msgid "destination exists"
msgstr "目标已存在"

#: builtin/mv.c
msgid "can not move directory into itself"
msgstr "不能将目录移动到自身"

#: builtin/mv.c
msgid "destination already exists"
msgstr "目标已存在"

#: builtin/mv.c
msgid "source directory is empty"
msgstr "源目录为空"

#: builtin/mv.c
msgid "not under version control"
msgstr "不在版本控制之下"

#: builtin/mv.c
msgid "conflicted"
msgstr "冲突"

#: builtin/mv.c
#, c-format
msgid "overwriting '%s'"
msgstr "覆盖 '%s'"

#: builtin/mv.c
msgid "Cannot overwrite"
msgstr "不能覆盖"

#: builtin/mv.c
msgid "multiple sources for the same target"
msgstr "同一目标具有多个源"

#: builtin/mv.c
msgid "destination directory does not exist"
msgstr "目标目录不存在"

#: builtin/mv.c
msgid "destination exists in the index"
msgstr "目标在索引中已存在"

#: builtin/mv.c
#, c-format
msgid "%s, source=%s, destination=%s"
msgstr "%s，源=%s，目标=%s"

#: builtin/mv.c
#, c-format
msgid "Renaming %s to %s\n"
msgstr "重命名 %s 至 %s\n"

#: builtin/mv.c builtin/remote.c
#, c-format
msgid "renaming '%s' failed"
msgstr "重命名 '%s' 失败"

#: builtin/name-rev.c
msgid "git name-rev [<options>] <commit>..."
msgstr "git name-rev [<选项>] <提交>..."

#: builtin/name-rev.c
msgid "git name-rev [<options>] --all"
msgstr "git name-rev [<选项>] --all"

#: builtin/name-rev.c
msgid "git name-rev [<options>] --annotate-stdin"
msgstr "git name-rev [<选项>] --annotate-stdin"

#: builtin/name-rev.c
msgid "print only ref-based names (no object names)"
msgstr "只打印基于引用的名称（非对象名）"

#: builtin/name-rev.c
msgid "only use tags to name the commits"
msgstr "只使用标签来命名提交"

#: builtin/name-rev.c
msgid "only use refs matching <pattern>"
msgstr "只使用和 <模式> 相匹配的引用"

#: builtin/name-rev.c
msgid "ignore refs matching <pattern>"
msgstr "忽略和 <模式> 相匹配的引用"

#: builtin/name-rev.c
msgid "list all commits reachable from all refs"
msgstr "列出可以从所有引用访问的提交"

#: builtin/name-rev.c
msgid "deprecated: use --annotate-stdin instead"
msgstr "已弃用：取而代之使用 --annotate-stdin"

#: builtin/name-rev.c
msgid "annotate text from stdin"
msgstr "标注标准输入的文字"

#: builtin/name-rev.c
msgid "allow to print `undefined` names (default)"
msgstr "允许打印 `未定义` 的名称（默认）"

#: builtin/name-rev.c
msgid "dereference tags in the input (internal use)"
msgstr "反向解析输入中的标签（内部使用）"

#: builtin/notes.c
msgid "git notes [--ref <notes-ref>] [list [<object>]]"
msgstr "git notes [--ref <注解引用>] [list [<对象>]]"

#: builtin/notes.c
msgid ""
"git notes [--ref <notes-ref>] add [-f] [--allow-empty] [--[no-]separator|--"
"separator=<paragraph-break>] [--[no-]stripspace] [-m <msg> | -F <file> | (-c "
"| -C) <object>] [<object>] [-e]"
msgstr ""
"git notes [--ref <注解引用>] add [-f] [--allow-empty] [--[no-]separator|--"
"separator=<分段符>] [--[no-]stripspace] [-m <说明> | -F <文件> | (-c | -C) <"
"对象>] [<对象>] [-e]"

#: builtin/notes.c
msgid "git notes [--ref <notes-ref>] copy [-f] <from-object> <to-object>"
msgstr "git notes [--ref <注解引用>] copy [-f] <源对象> <目标对象>"

#: builtin/notes.c
msgid ""
"git notes [--ref <notes-ref>] append [--allow-empty] [--[no-]separator|--"
"separator=<paragraph-break>] [--[no-]stripspace] [-m <msg> | -F <file> | (-c "
"| -C) <object>] [<object>] [-e]"
msgstr ""
"git notes [--ref <注解引用>] append [--allow-empty] [--[no-]separator|--"
"separator=<分段符>] [--[no-]stripspace] [-m <说明> | -F <文件> | (-c | -C) <"
"对象>] [<对象>] [-e]"

#: builtin/notes.c
msgid "git notes [--ref <notes-ref>] edit [--allow-empty] [<object>]"
msgstr "git notes [--ref <注解引用>] edit [--allow-empty] [<对象>]"

#: builtin/notes.c
msgid "git notes [--ref <notes-ref>] show [<object>]"
msgstr "git notes [--ref <注解引用>] show [<对象>]"

#: builtin/notes.c
msgid ""
"git notes [--ref <notes-ref>] merge [-v | -q] [-s <strategy>] <notes-ref>"
msgstr "git notes [--ref <注解引用>] merge [-v | -q] [-s <策略> ] <注解引用>"

#: builtin/notes.c
msgid "git notes [--ref <notes-ref>] remove [<object>...]"
msgstr "git notes [--ref <注解引用>] remove [<对象>...]"

#: builtin/notes.c
msgid "git notes [--ref <notes-ref>] prune [-n] [-v]"
msgstr "git notes [--ref <注解引用>] prune [-n] [-v]"

#: builtin/notes.c
msgid "git notes [--ref <notes-ref>] get-ref"
msgstr "git notes [--ref <注解引用>] get-ref"

#: builtin/notes.c
msgid "git notes [list [<object>]]"
msgstr "git notes [list [<对象>]]"

#: builtin/notes.c
msgid "git notes add [<options>] [<object>]"
msgstr "git notes add [<选项>] [<对象>]"

#: builtin/notes.c
msgid "git notes copy [<options>] <from-object> <to-object>"
msgstr "git notes copy [<选项>] <源对象> <目标对象>"

#: builtin/notes.c
msgid "git notes copy --stdin [<from-object> <to-object>]..."
msgstr "git notes copy --stdin [<源对象> <目标对象>]..."

#: builtin/notes.c
msgid "git notes append [<options>] [<object>]"
msgstr "git notes append [<选项>] [<对象>]"

#: builtin/notes.c
msgid "git notes edit [<object>]"
msgstr "git notes edit [<对象>]"

#: builtin/notes.c
msgid "git notes show [<object>]"
msgstr "git notes show [<对象>]"

#: builtin/notes.c
msgid "git notes merge [<options>] <notes-ref>"
msgstr "git notes merge [<选项>] <注解引用>"

#: builtin/notes.c
msgid "git notes merge --commit [<options>]"
msgstr "git notes merge --commit [<选项>]"

#: builtin/notes.c
msgid "git notes merge --abort [<options>]"
msgstr "git notes merge --abort [<选项>]"

#: builtin/notes.c
msgid "git notes remove [<object>]"
msgstr "git notes remove [<对象>]"

#: builtin/notes.c
msgid "git notes prune [<options>]"
msgstr "git notes prune [<选项>]"

#: builtin/notes.c
msgid "Write/edit the notes for the following object:"
msgstr "为下面的对象写/编辑说明："

#: builtin/notes.c
msgid "could not read 'show' output"
msgstr "不能读取 'show' 的输出"

#: builtin/notes.c
#, c-format
msgid "failed to finish 'show' for object '%s'"
msgstr "无法为对象 '%s' 完成 'show'"

#: builtin/notes.c
msgid "please supply the note contents using either -m or -F option"
msgstr "请通过 -m 或 -F 选项为注解提供内容"

#: builtin/notes.c
msgid "unable to write note object"
msgstr "不能写注解对象"

#: builtin/notes.c
#, c-format
msgid "the note contents have been left in %s"
msgstr "注解内容被留在 %s 中"

#: builtin/notes.c builtin/tag.c
#, c-format
msgid "could not open or read '%s'"
msgstr "不能打开或读取 '%s'"

#: builtin/notes.c
#, c-format
msgid "failed to resolve '%s' as a valid ref."
msgstr "无法解析 '%s' 为一个有效引用。"

#: builtin/notes.c
#, c-format
msgid "failed to read object '%s'."
msgstr "无法读取对象 '%s'。"

#: builtin/notes.c
#, c-format
msgid "cannot read note data from non-blob object '%s'."
msgstr "不能从非数据对象 '%s' 中读取注解数据。"

#: builtin/notes.c
#, c-format
msgid "failed to copy notes from '%s' to '%s'"
msgstr "无法把注解从 '%s' 拷贝到 '%s'"

#. TRANSLATORS: the first %s will be replaced by a git
#. notes command: 'add', 'merge', 'remove', etc.
#.
#: builtin/notes.c
#, c-format
msgid "refusing to %s notes in %s (outside of refs/notes/)"
msgstr "拒绝向 %2$s（在 refs/notes/ 之外）%1$s注解"

#: builtin/notes.c
#, c-format
msgid "no note found for object %s."
msgstr "未发现对象 %s 的注解。"

#: builtin/notes.c
msgid "note contents as a string"
msgstr "注解内容作为一个字符串"

#: builtin/notes.c
msgid "note contents in a file"
msgstr "注解内容到一个文件中"

#: builtin/notes.c
msgid "reuse and edit specified note object"
msgstr "重用和编辑指定的注解对象"

#: builtin/notes.c
msgid "edit note message in editor"
msgstr "在编辑器中编辑注释说明"

#: builtin/notes.c
msgid "reuse specified note object"
msgstr "重用指定的注解对象"

#: builtin/notes.c
msgid "allow storing empty note"
msgstr "允许保存空白注释"

#: builtin/notes.c
msgid "replace existing notes"
msgstr "替换已存在的注解"

#: builtin/notes.c
msgid "<paragraph-break>"
msgstr "<分段符>"

#: builtin/notes.c
msgid "insert <paragraph-break> between paragraphs"
msgstr "在段落之间插入<分段符>"

#: builtin/notes.c
msgid "remove unnecessary whitespace"
msgstr "删除不必要的空白字符"

#: builtin/notes.c
#, c-format
msgid ""
"Cannot add notes. Found existing notes for object %s. Use '-f' to overwrite "
"existing notes"
msgstr "不能添加注解。发现对象 %s 已存在注解。使用 '-f' 覆盖现存注解"

#: builtin/notes.c
#, c-format
msgid "Overwriting existing notes for object %s\n"
msgstr "覆盖对象 %s 现存注解\n"

#: builtin/notes.c
#, c-format
msgid "Removing note for object %s\n"
msgstr "删除对象 %s 的注解\n"

#: builtin/notes.c
msgid "read objects from stdin"
msgstr "从标准输入读取对象"

#: builtin/notes.c
msgid "load rewriting config for <command> (implies --stdin)"
msgstr "重新加载 <命令> 的配置（隐含 --stdin）"

#: builtin/notes.c
msgid "too few arguments"
msgstr "参数太少"

#: builtin/notes.c
#, c-format
msgid ""
"Cannot copy notes. Found existing notes for object %s. Use '-f' to overwrite "
"existing notes"
msgstr "不能拷贝注解。发现对象 %s 已存在注解。使用 '-f' 覆盖现存注解"

#: builtin/notes.c
#, c-format
msgid "missing notes on source object %s. Cannot copy."
msgstr "源对象 %s 缺少注解。不能拷贝。"

#: builtin/notes.c
#, c-format
msgid ""
"The -m/-F/-c/-C options have been deprecated for the 'edit' subcommand.\n"
"Please use 'git notes add -f -m/-F/-c/-C' instead.\n"
msgstr ""
"子命令 'edit' 的选项 -m/-F/-c/-C 已弃用。\n"
"请换用 'git notes add -f -m/-F/-c/-C'。\n"

#: builtin/notes.c
msgid "failed to delete ref NOTES_MERGE_PARTIAL"
msgstr "无法删除引用 NOTES_MERGE_PARTIAL"

#: builtin/notes.c
msgid "failed to delete ref NOTES_MERGE_REF"
msgstr "无法删除引用 NOTES_MERGE_REF"

#: builtin/notes.c
msgid "failed to remove 'git notes merge' worktree"
msgstr "无法删除 'git notes merge' 工作区"

#: builtin/notes.c
msgid "failed to read ref NOTES_MERGE_PARTIAL"
msgstr "无法读取引用 NOTES_MERGE_PARTIAL"

#: builtin/notes.c
msgid "could not find commit from NOTES_MERGE_PARTIAL."
msgstr "无法从 NOTES_MERGE_PARTIAL 中找到提交。"

#: builtin/notes.c
msgid "could not parse commit from NOTES_MERGE_PARTIAL."
msgstr "无法从 NOTES_MERGE_PARTIAL 中解析提交。"

#: builtin/notes.c
msgid "failed to resolve NOTES_MERGE_REF"
msgstr "无法解析 NOTES_MERGE_REF"

#: builtin/notes.c
msgid "failed to finalize notes merge"
msgstr "无法完成注解合并"

#: builtin/notes.c
#, c-format
msgid "unknown notes merge strategy %s"
msgstr "未知的注解合并策略 %s"

#: builtin/notes.c
msgid "General options"
msgstr "通用选项"

#: builtin/notes.c
msgid "Merge options"
msgstr "合并选项"

#: builtin/notes.c
msgid ""
"resolve notes conflicts using the given strategy (manual/ours/theirs/union/"
"cat_sort_uniq)"
msgstr "使用指定的策略解决注解冲突 (manual/ours/theirs/union/cat_sort_uniq)"

#: builtin/notes.c
msgid "Committing unmerged notes"
msgstr "提交未合并的注解"

#: builtin/notes.c
msgid "finalize notes merge by committing unmerged notes"
msgstr "通过提交未合并的注解来完成注解合并"

#: builtin/notes.c
msgid "Aborting notes merge resolution"
msgstr "中止注解合并的方案"

#: builtin/notes.c
msgid "abort notes merge"
msgstr "中止注解合并"

#: builtin/notes.c
msgid "cannot mix --commit, --abort or -s/--strategy"
msgstr "不能混用 --commit、--abort 或 -s/--strategy"

#: builtin/notes.c
msgid "must specify a notes ref to merge"
msgstr "必须指定一个注解引用来合并"

#: builtin/notes.c
#, c-format
msgid "unknown -s/--strategy: %s"
msgstr "未知的 -s/--strategy：%s"

#: builtin/notes.c
#, c-format
msgid "a notes merge into %s is already in-progress at %s"
msgstr "位于 %2$s 的一个到 %1$s 中的注解合并正在执行中"

#: builtin/notes.c
#, c-format
msgid "failed to store link to current notes ref (%s)"
msgstr "无法存储链接到当前的注解引用（%s）"

#: builtin/notes.c
#, c-format
msgid ""
"Automatic notes merge failed. Fix conflicts in %s and commit the result with "
"'git notes merge --commit', or abort the merge with 'git notes merge --"
"abort'.\n"
msgstr ""
"自动合并说明失败。修改 %s 中的冲突并且使用命令 'git notes merge --commit' 提"
"交结果，或者使用命令 'git notes merge --abort' 终止合并。\n"

#: builtin/notes.c builtin/tag.c
#, c-format
msgid "Failed to resolve '%s' as a valid ref."
msgstr "无法解析 '%s' 为一个有效引用。"

#: builtin/notes.c
#, c-format
msgid "Object %s has no note\n"
msgstr "对象 %s 没有注解\n"

#: builtin/notes.c
msgid "attempt to remove non-existent note is not an error"
msgstr "尝试删除不存在的注解不是一个错误"

#: builtin/notes.c
msgid "read object names from the standard input"
msgstr "从标准输入读取对象名称"

#: builtin/notes.c builtin/prune.c builtin/worktree.c
msgid "do not remove, show only"
msgstr "不删除，只显示"

#: builtin/notes.c
msgid "report pruned notes"
msgstr "报告清除的注解"

#: builtin/notes.c
msgid "notes-ref"
msgstr "注解引用"

#: builtin/notes.c
msgid "use notes from <notes-ref>"
msgstr "从 <注解引用> 使用注解"

#: builtin/notes.c builtin/remote.c parse-options.c
#, c-format
msgid "unknown subcommand: `%s'"
msgstr "未知子命令：`%s'"

#: builtin/pack-objects.c
msgid "git pack-objects --stdout [<options>] [< <ref-list> | < <object-list>]"
msgstr "git pack-objects --stdout [<选项>] [< <引用列表> | < <对象列表>]"

#: builtin/pack-objects.c
msgid ""
"git pack-objects [<options>] <base-name> [< <ref-list> | < <object-list>]"
msgstr "git pack-objects [<选项>] <前缀名称> [< <引用列表> | < <对象列表>]"

#: builtin/pack-objects.c
#, c-format
msgid "invalid --name-hash-version option: %d"
msgstr "无效的 --name-hash-version 选项：%d"

#: builtin/pack-objects.c
msgid "currently, --write-bitmap-index requires --name-hash-version=1"
msgstr "当前，--write-bitmap-index 要求 --name-hash-version=1"

#: builtin/pack-objects.c
#, c-format
msgid ""
"write_reuse_object: could not locate %s, expected at offset %<PRIuMAX> in "
"pack %s"
msgstr ""
"write_reuse_object：无法定位 %1$s，预期在包 %3$s 中的偏移量 %2$<PRIuMAX> 上"

#: builtin/pack-objects.c
#, c-format
msgid "bad packed object CRC for %s"
msgstr "%s 错的包对象 CRC"

#: builtin/pack-objects.c
#, c-format
msgid "corrupt packed object for %s"
msgstr "%s 损坏的包对象"

#: builtin/pack-objects.c
#, c-format
msgid "recursive delta detected for object %s"
msgstr "发现对象 %s 递归 delta"

#: builtin/pack-objects.c
#, c-format
msgid "ordered %u objects, expected %<PRIu32>"
msgstr "排序了 %u 个对象，预期 %<PRIu32> 个"

#: builtin/pack-objects.c
#, c-format
msgid "expected object at offset %<PRIuMAX> in pack %s"
msgstr "预期对象在包文件 %2$s 的偏移量 %1$<PRIuMAX> 上"

#: builtin/pack-objects.c
msgid "disabling bitmap writing, packs are split due to pack.packSizeLimit"
msgstr "禁用 bitmap 写入，因为 pack.packSizeLimit 设置使得包被切分为多个"

#: builtin/pack-objects.c
msgid "Writing objects"
msgstr "写入对象中"

#: builtin/pack-objects.c builtin/update-index.c
#, c-format
msgid "failed to stat %s"
msgstr "无法对 %s 调用 stat"

#: builtin/pack-objects.c object-file.c
#, c-format
msgid "failed utime() on %s"
msgstr "在 %s 上调用 utime() 失败"

#: builtin/pack-objects.c
msgid "failed to write bitmap index"
msgstr "无法写入位图索引"

#: builtin/pack-objects.c
#, c-format
msgid "wrote %<PRIu32> objects while expecting %<PRIu32>"
msgstr "写入 %<PRIu32> 个对象而预期 %<PRIu32> 个"

#: builtin/pack-objects.c builtin/repack.c
msgid "disabling bitmap writing, as some objects are not being packed"
msgstr "禁用 bitmap 写入，因为一些对象将不会被打包"

#: builtin/pack-objects.c
#, c-format
msgid "delta base offset overflow in pack for %s"
msgstr "%s 压缩中 delta 基准偏移越界"

#: builtin/pack-objects.c
#, c-format
msgid "delta base offset out of bound for %s"
msgstr "%s 的 delta 基准偏移越界"

#: builtin/pack-objects.c
msgid "Counting objects"
msgstr "对象计数中"

#: builtin/pack-objects.c pack-bitmap.c
#, c-format
msgid "unable to get size of %s"
msgstr "无法得到 %s 的大小"

#: builtin/pack-objects.c
#, c-format
msgid "unable to parse object header of %s"
msgstr "无法解析对象 %s 头信息"

#: builtin/pack-objects.c
#, c-format
msgid "object %s cannot be read"
msgstr "对象 %s 无法读取"

#: builtin/pack-objects.c
#, c-format
msgid "object %s inconsistent object length (%<PRIuMAX> vs %<PRIuMAX>)"
msgstr "对象 %s 不一致的对象长度（%<PRIuMAX> vs %<PRIuMAX>）"

#: builtin/pack-objects.c
msgid "suboptimal pack - out of memory"
msgstr "次优（suboptimal）打包 - 内存不足"

#: builtin/pack-objects.c
#, c-format
msgid "Delta compression using up to %d threads"
msgstr "使用 %d 个线程进行压缩"

#: builtin/pack-objects.c
#, c-format
msgid "unable to pack objects reachable from tag %s"
msgstr "无法为标签 %s 压缩对象"

#: builtin/pack-objects.c commit-graph.c
#, c-format
msgid "unable to get type of object %s"
msgstr "无法获得对象 %s 类型"

#: builtin/pack-objects.c
msgid "Compressing objects"
msgstr "压缩对象中"

#: builtin/pack-objects.c
msgid "inconsistency with delta count"
msgstr "不一致的差异计数"

#: builtin/pack-objects.c
#, c-format
msgid "invalid pack.allowPackReuse value: '%s'"
msgstr "无效的 pack.allowPackReuse 值：'%s'"

#: builtin/pack-objects.c
#, c-format
msgid ""
"value of uploadpack.blobpackfileuri must be of the form '<object-hash> <pack-"
"hash> <uri>' (got '%s')"
msgstr ""
"uploadpack.blobpackfileuri 的取值必须是 '<object-hash> <pack-hash> <uri>' 格"
"式（得到 '%s'）"

#: builtin/pack-objects.c
#, c-format
msgid ""
"object already configured in another uploadpack.blobpackfileuri (got '%s')"
msgstr "对象已经在另外的 uploadpack.blobpackfileuri 中配置（得到 '%s'）"

#: builtin/pack-objects.c
#, c-format
msgid "could not get type of object %s in pack %s"
msgstr "无法获得包 %2$s 中对象 %1$s 的类型"

#: builtin/pack-objects.c
#, c-format
msgid "could not find pack '%s'"
msgstr "不能找到包 '%s'"

#: builtin/pack-objects.c
#, c-format
msgid "packfile %s cannot be accessed"
msgstr "无法访问包文件 %s"

#: builtin/pack-objects.c
msgid "Enumerating cruft objects"
msgstr "枚举废弃对象中"

#: builtin/pack-objects.c
msgid "unable to add cruft objects"
msgstr "无法添加废弃对象"

#: builtin/pack-objects.c
msgid "Traversing cruft objects"
msgstr "遍历废弃对象中"

#: builtin/pack-objects.c
#, c-format
msgid ""
"expected edge object ID, got garbage:\n"
" %s"
msgstr ""
"预期边界对象（edge object）ID，却得到垃圾数据：\n"
" %s"

#: builtin/pack-objects.c
#, c-format
msgid ""
"expected object ID, got garbage:\n"
" %s"
msgstr ""
"预期对象 ID，却得到垃圾数据：\n"
" %s"

#: builtin/pack-objects.c reachable.c
msgid "could not load cruft pack .mtimes"
msgstr "不能载入废弃包 .mtimes"

#: builtin/pack-objects.c
msgid "cannot open pack index"
msgstr "无法打开包文件索引"

#: builtin/pack-objects.c
#, c-format
msgid "loose object at %s could not be examined"
msgstr "无法检查 %s 处的松散对象"

#: builtin/pack-objects.c
msgid "unable to force loose object"
msgstr "无法强制松散对象"

#: builtin/pack-objects.c
#, c-format
msgid "not a rev '%s'"
msgstr "不是一个版本 '%s'"

#: builtin/pack-objects.c builtin/rev-parse.c
#, c-format
msgid "bad revision '%s'"
msgstr "坏的版本 '%s'"

#: builtin/pack-objects.c
msgid "unable to add recent objects"
msgstr "无法添加最近的对象"

#: builtin/pack-objects.c
#, c-format
msgid "unsupported index version %s"
msgstr "不支持的索引版本 %s"

#: builtin/pack-objects.c
#, c-format
msgid "bad index version '%s'"
msgstr "坏的索引版本 '%s'"

#: builtin/pack-objects.c
msgid "show progress meter during object writing phase"
msgstr "在对象写入阶段显示进度表"

#: builtin/pack-objects.c
msgid "similar to --all-progress when progress meter is shown"
msgstr "当进度表显示时类似于 --all-progress"

#: builtin/pack-objects.c
msgid "<version>[,<offset>]"
msgstr "<版本>[,<偏移>]"

#: builtin/pack-objects.c
msgid "write the pack index file in the specified idx format version"
msgstr "用指定的 idx 格式版本来写包索引文件"

#: builtin/pack-objects.c
msgid "maximum size of each output pack file"
msgstr "每个输出包的最大尺寸"

#: builtin/pack-objects.c
msgid "ignore borrowed objects from alternate object store"
msgstr "忽略从备用对象存储里借用对象"

#: builtin/pack-objects.c
msgid "ignore packed objects"
msgstr "忽略包对象"

#: builtin/pack-objects.c
msgid "limit pack window by objects"
msgstr "限制打包窗口的对象数"

#: builtin/pack-objects.c
msgid "limit pack window by memory in addition to object limit"
msgstr "除对象数量限制外设置打包窗口的内存限制"

#: builtin/pack-objects.c
msgid "maximum length of delta chain allowed in the resulting pack"
msgstr "打包允许的 delta 链的最大长度"

#: builtin/pack-objects.c
msgid "reuse existing deltas"
msgstr "重用已存在的 deltas"

#: builtin/pack-objects.c
msgid "reuse existing objects"
msgstr "重用已存在的对象"

#: builtin/pack-objects.c
msgid "use OFS_DELTA objects"
msgstr "使用 OFS_DELTA 对象"

#: builtin/pack-objects.c
msgid "use threads when searching for best delta matches"
msgstr "使用线程查询最佳 delta 匹配"

#: builtin/pack-objects.c
msgid "do not create an empty pack output"
msgstr "不创建空的包输出"

#: builtin/pack-objects.c
msgid "read revision arguments from standard input"
msgstr "从标准输入读取版本号参数"

#: builtin/pack-objects.c
msgid "limit the objects to those that are not yet packed"
msgstr "限制那些尚未打包的对象"

#: builtin/pack-objects.c
msgid "include objects reachable from any reference"
msgstr "包括可以从任何引用访问到的对象"

#: builtin/pack-objects.c
msgid "include objects referred by reflog entries"
msgstr "包括被引用日志引用到的对象"

#: builtin/pack-objects.c
msgid "include objects referred to by the index"
msgstr "包括被索引引用到的对象"

#: builtin/pack-objects.c
msgid "read packs from stdin"
msgstr "从标准输入读取包"

#: builtin/pack-objects.c
msgid "output pack to stdout"
msgstr "输出包到标准输出"

#: builtin/pack-objects.c
msgid "include tag objects that refer to objects to be packed"
msgstr "包括那些引用了待打包对象的标签对象"

#: builtin/pack-objects.c
msgid "keep unreachable objects"
msgstr "维持不可达的对象"

#: builtin/pack-objects.c
msgid "pack loose unreachable objects"
msgstr "打包松散的不可达对象"

#: builtin/pack-objects.c
msgid "unpack unreachable objects newer than <time>"
msgstr "将比给定 <时间> 新的无法访问的对象解包"

#: builtin/pack-objects.c
msgid "create a cruft pack"
msgstr "创建废弃包"

#: builtin/pack-objects.c
msgid "expire cruft objects older than <time>"
msgstr "使早于给定 <时间> 的废弃对象过期"

#: builtin/pack-objects.c
msgid "use the sparse reachability algorithm"
msgstr "使用稀疏可达性算法"

#: builtin/pack-objects.c
msgid "create thin packs"
msgstr "创建精简包"

#: builtin/pack-objects.c
msgid "create packs suitable for shallow fetches"
msgstr "创建适合浅克隆仓库获取的包"

#: builtin/pack-objects.c
msgid "ignore packs that have companion .keep file"
msgstr "忽略配有 .keep 文件的包"

#: builtin/pack-objects.c
msgid "ignore this pack"
msgstr "忽略该 pack"

#: builtin/pack-objects.c
msgid "pack compression level"
msgstr "打包压缩级别"

#: builtin/pack-objects.c
msgid "do not hide commits by grafts"
msgstr "显示被移植隐藏的提交"

#: builtin/pack-objects.c
msgid "use a bitmap index if available to speed up counting objects"
msgstr "使用 bitmap 索引（如果有的话）以提高对象计数时的速度"

#: builtin/pack-objects.c
msgid "write a bitmap index together with the pack index"
msgstr "在建立包索引的同时创建 bitmap 索引"

#: builtin/pack-objects.c
msgid "write a bitmap index if possible"
msgstr "如果可能，写 bitmap 索引"

#: builtin/pack-objects.c
msgid "handling for missing objects"
msgstr "处理丢失的对象"

#: builtin/pack-objects.c
msgid "do not pack objects in promisor packfiles"
msgstr "不要打包 promisor 包文件中的对象"

#: builtin/pack-objects.c
msgid "implies --missing=allow-any"
msgstr "暗含 --missing=allow-any"

#: builtin/pack-objects.c
msgid "respect islands during delta compression"
msgstr "在增量压缩时参考数据岛"

#: builtin/pack-objects.c
msgid "protocol"
msgstr "协议"

#: builtin/pack-objects.c
msgid "exclude any configured uploadpack.blobpackfileuri with this protocol"
msgstr "排除掉采用该协议的 uploadpack.blobpackfileuri 配置项"

#: builtin/pack-objects.c
msgid "use the specified name-hash function to group similar objects"
msgstr "使用指定的名称哈希函数对相似的对象进行分组"

#: builtin/pack-objects.c
#, c-format
msgid "delta chain depth %d is too deep, forcing %d"
msgstr "增量链深度 %d 太深了，强制为 %d"

#: builtin/pack-objects.c
#, c-format
msgid "pack.deltaCacheLimit is too high, forcing %d"
msgstr "配置 pack.deltaCacheLimit 太高了，强制为 %d"

#: builtin/pack-objects.c config.c
#, c-format
msgid "bad pack compression level %d"
msgstr "错误的打包压缩级别 %d"

#: builtin/pack-objects.c
msgid "--max-pack-size cannot be used to build a pack for transfer"
msgstr "不能使用 --max-pack-size 来构建传输用的包文件"

#: builtin/pack-objects.c
msgid "minimum pack size limit is 1 MiB"
msgstr "最小的包文件大小是 1 MiB"

#: builtin/pack-objects.c
msgid "--thin cannot be used to build an indexable pack"
msgstr "--thin 不能用于创建一个可索引包"

#: builtin/pack-objects.c
msgid "cannot use --filter with --stdin-packs"
msgstr "不能同时使用 --filter 和 --stdin-packs"

#: builtin/pack-objects.c
msgid "cannot use internal rev list with --stdin-packs"
msgstr "不能同时使用内部版本列表和 --stdin-packs"

#: builtin/pack-objects.c
msgid "cannot use internal rev list with --cruft"
msgstr "不能同时使用内部版本列表和 --cruft"

#: builtin/pack-objects.c
msgid "cannot use --stdin-packs with --cruft"
msgstr "不能将 --stdin-packs 和 --cruft 同时使用"

#: builtin/pack-objects.c
msgid "Enumerating objects"
msgstr "枚举对象中"

#: builtin/pack-objects.c
#, c-format
msgid ""
"Total %<PRIu32> (delta %<PRIu32>), reused %<PRIu32> (delta %<PRIu32>), pack-"
"reused %<PRIu32> (from %<PRIuMAX>)"
msgstr ""
"总共 %<PRIu32>（差异 %<PRIu32>），复用 %<PRIu32>（差异 %<PRIu32>），包复用 "
"%<PRIu32>（来自  %<PRIuMAX> 个包）"

#: builtin/pack-redundant.c
msgid ""
"'git pack-redundant' is nominated for removal.\n"
"If you still use this command, please add an extra\n"
"option, '--i-still-use-this', on the command line\n"
"and let us know you still use it by sending an e-mail\n"
"to <git@vger.kernel.org>.  Thanks.\n"
msgstr ""
"准备移除 'git pack-redundant' 命令。如果您仍旧使用这个\n"
"命令，请在命令行中添加额外参数：'--i-still-use-this'，\n"
"并通过发送邮件到 <git@vger.kernel.org> 让我们知道您仍旧\n"
"使用它。 谢谢。\n"

#: builtin/pack-redundant.c
msgid "refusing to run without --i-still-use-this"
msgstr "拒绝在未指定 --i-still-use-this 选项时运行"

#: builtin/pack-refs.c
msgid ""
"git pack-refs [--all] [--no-prune] [--auto] [--include <pattern>] [--exclude "
"<pattern>]"
msgstr ""
"git pack-refs [--all] [--no-prune] [--auto] [--include <模式>] [--exclude <模"
"式>]"

#: builtin/pack-refs.c
msgid "pack everything"
msgstr "打包一切"

#: builtin/pack-refs.c
msgid "prune loose refs (default)"
msgstr "清除松散的引用（默认）"

#: builtin/pack-refs.c
msgid "auto-pack refs as needed"
msgstr "按需对引用自动打包"

#: builtin/pack-refs.c
msgid "references to include"
msgstr "需包含的引用"

#: builtin/pack-refs.c
msgid "references to exclude"
msgstr "需排除的引用"

#: builtin/patch-id.c
msgid "git patch-id [--stable | --unstable | --verbatim]"
msgstr "git patch-id [--stable | --unstable | --verbatim]"

#: builtin/patch-id.c
msgid "use the unstable patch-id algorithm"
msgstr "使用不稳定的 patch-id 算法"

#: builtin/patch-id.c
msgid "use the stable patch-id algorithm"
msgstr "使用稳定的 patch-id 算法"

#: builtin/patch-id.c
msgid "don't strip whitespace from the patch"
msgstr "不要从补丁中删除空白字符"

#: builtin/prune.c
msgid "git prune [-n] [-v] [--progress] [--expire <time>] [--] [<head>...]"
msgstr "git prune [-n] [-v] [--progress] [--expire <时间>] [--] [<head>...]"

#: builtin/prune.c
msgid "report pruned objects"
msgstr "报告清除的对象"

#: builtin/prune.c
msgid "expire objects older than <time>"
msgstr "使早于给定时间的对象过期"

#: builtin/prune.c
msgid "limit traversal to objects outside promisor packfiles"
msgstr "限制遍历 promisor 包以外的对象"

#: builtin/prune.c
msgid "cannot prune in a precious-objects repo"
msgstr "不能在珍品仓库中执行清理操作"

#: builtin/pull.c
msgid "git pull [<options>] [<repository> [<refspec>...]]"
msgstr "git pull [<选项>] [<仓库> [<引用规格>...]]"

#: builtin/pull.c
msgid "control for recursive fetching of submodules"
msgstr "控制子模组的递归获取"

#: builtin/pull.c
msgid "Options related to merging"
msgstr "和合并相关的选项"

#: builtin/pull.c
msgid "incorporate changes by rebasing rather than merging"
msgstr "使用变基操作取代合并操作以合入修改"

#: builtin/pull.c builtin/revert.c
msgid "allow fast-forward"
msgstr "允许快进式"

#: builtin/pull.c
msgid "control use of pre-merge-commit and commit-msg hooks"
msgstr "控制 pre-merge-commit 和 commit-msg 钩子的使用"

#: builtin/pull.c parse-options.h
msgid "automatically stash/stash pop before and after"
msgstr "在操作前后执行自动贮藏和弹出贮藏"

#: builtin/pull.c
msgid "Options related to fetching"
msgstr "和获取相关的参数"

#: builtin/pull.c
msgid "force overwrite of local branch"
msgstr "强制覆盖本地分支"

#: builtin/pull.c
msgid "number of submodules pulled in parallel"
msgstr "并发拉取的子模组的数量"

#: builtin/pull.c parse-options.h
msgid "use IPv4 addresses only"
msgstr "只使用 IPv4 地址"

#: builtin/pull.c parse-options.h
msgid "use IPv6 addresses only"
msgstr "只使用 IPv6 地址"

#: builtin/pull.c
msgid ""
"There is no candidate for rebasing against among the refs that you just "
"fetched."
msgstr "在您刚刚获取到的引用中没有变基操作的候选。"

#: builtin/pull.c
msgid ""
"There are no candidates for merging among the refs that you just fetched."
msgstr "在您刚刚获取到的引用中没有合并操作的候选。"

#: builtin/pull.c
msgid ""
"Generally this means that you provided a wildcard refspec which had no\n"
"matches on the remote end."
msgstr "通常这意味着您提供了一个通配符引用规格但未能和远端匹配。"

#: builtin/pull.c
#, c-format
msgid ""
"You asked to pull from the remote '%s', but did not specify\n"
"a branch. Because this is not the default configured remote\n"
"for your current branch, you must specify a branch on the command line."
msgstr ""
"您要求从远程 '%s' 拉取，但是未指定一个分支。因为这不是当前\n"
"分支默认的远程仓库，您必须在命令行中指定一个分支名。"

#: builtin/pull.c builtin/rebase.c
msgid "You are not currently on a branch."
msgstr "您当前不在一个分支上。"

#: builtin/pull.c
msgid "Please specify which branch you want to rebase against."
msgstr "请指定您要变基到哪一个分支。"

#: builtin/pull.c
msgid "Please specify which branch you want to merge with."
msgstr "请指定您要合并哪一个分支。"

#: builtin/pull.c
msgid "See git-pull(1) for details."
msgstr "详见 git-pull(1)。"

#: builtin/pull.c builtin/rebase.c
msgid "<remote>"
msgstr "<远程>"

#: builtin/pull.c scalar.c
msgid "<branch>"
msgstr "<分支>"

#: builtin/pull.c builtin/rebase.c
msgid "There is no tracking information for the current branch."
msgstr "当前分支没有跟踪信息。"

#: builtin/pull.c
msgid ""
"If you wish to set tracking information for this branch you can do so with:"
msgstr "如果您想要为此分支创建跟踪信息，您可以执行："

#: builtin/pull.c
#, c-format
msgid ""
"Your configuration specifies to merge with the ref '%s'\n"
"from the remote, but no such ref was fetched."
msgstr ""
"您的配置中指定要合并远程的引用 '%s'，\n"
"但是没有获取到这个引用。"

#: builtin/pull.c
#, c-format
msgid "unable to access commit %s"
msgstr "无法访问提交 %s"

#: builtin/pull.c
msgid "ignoring --verify-signatures for rebase"
msgstr "为变基操作忽略 --verify-signatures"

#: builtin/pull.c
msgid ""
"You have divergent branches and need to specify how to reconcile them.\n"
"You can do so by running one of the following commands sometime before\n"
"your next pull:\n"
"\n"
"  git config pull.rebase false  # merge\n"
"  git config pull.rebase true   # rebase\n"
"  git config pull.ff only       # fast-forward only\n"
"\n"
"You can replace \"git config\" with \"git config --global\" to set a "
"default\n"
"preference for all repositories. You can also pass --rebase, --no-rebase,\n"
"or --ff-only on the command line to override the configured default per\n"
"invocation.\n"
msgstr ""
"您有偏离的分支，需要指定如何调和它们。您可以在执行下一次\n"
"pull 操作之前执行下面一条命令来抑制本消息：\n"
"\n"
"  git config pull.rebase false  # 合并\n"
"  git config pull.rebase true   # 变基\n"
"  git config pull.ff only       # 仅快进\n"
"\n"
"您可以将 \"git config\" 替换为 \"git config --global\" 以便为所有仓库设置\n"
"缺省的配置项。您也可以在每次执行 pull 命令时添加 --rebase、--no-rebase，\n"
"或者 --ff-only 参数覆盖缺省设置。\n"

#: builtin/pull.c
msgid "Updating an unborn branch with changes added to the index."
msgstr "更新尚未诞生的分支，变更添加至索引。"

#: builtin/pull.c
msgid "pull with rebase"
msgstr "变基式拉取"

#: builtin/pull.c builtin/rebase.c
msgid "Please commit or stash them."
msgstr "请提交或贮藏修改。"

#: builtin/pull.c
#, c-format
msgid ""
"fetch updated the current branch head.\n"
"fast-forwarding your working tree from\n"
"commit %s."
msgstr ""
"fetch 更新了当前的分支。快进您的工作区\n"
"至提交 %s。"

#: builtin/pull.c
#, c-format
msgid ""
"Cannot fast-forward your working tree.\n"
"After making sure that you saved anything precious from\n"
"$ git diff %s\n"
"output, run\n"
"$ git reset --hard\n"
"to recover."
msgstr ""
"您当前的工作区无法执行快进操作。\n"
"首先执行如下命令：\n"
"$ git diff %s\n"
"以确认所有有用的数据均已保存。然后执行下面的命令\n"
"$ git reset --hard\n"
"恢复之前的状态。"

#: builtin/pull.c
msgid "Cannot merge multiple branches into empty head."
msgstr "无法将多个分支合并到空分支。"

#: builtin/pull.c
msgid "Cannot rebase onto multiple branches."
msgstr "无法变基到多个分支。"

#: builtin/pull.c
msgid "Cannot fast-forward to multiple branches."
msgstr "无法快进到多个分支。"

#: builtin/pull.c
msgid "Need to specify how to reconcile divergent branches."
msgstr "需要指定如何调和偏离的分支。"

#: builtin/pull.c
msgid "cannot rebase with locally recorded submodule modifications"
msgstr "本地子模组中有修改，无法变基"

#: builtin/push.c
msgid "git push [<options>] [<repository> [<refspec>...]]"
msgstr "git push [<选项>] [<仓库> [<引用规格>...]]"

#: builtin/push.c
msgid "tag shorthand without <tag>"
msgstr "标签后面未提供 <标签> 参数"

#: builtin/push.c
msgid "--delete only accepts plain target ref names"
msgstr "--delete 只接受简单的目标引用名"

#: builtin/push.c
msgid ""
"\n"
"To choose either option permanently, see push.default in 'git help config'.\n"
msgstr ""
"\n"
"为了永久地选择任一选项，参见 'git help config' 中的 push.default。\n"

#: builtin/push.c
msgid ""
"\n"
"To avoid automatically configuring an upstream branch when its name\n"
"won't match the local branch, see option 'simple' of branch.autoSetupMerge\n"
"in 'git help config'.\n"
msgstr ""
"\n"
"为了避免在与本地分支名字不匹配时自动设置上游分支，参见 'git help config'\n"
"中 branch.autoSetupMerge 的 'simple' 选项。\n"

#: builtin/push.c
#, c-format
msgid ""
"The upstream branch of your current branch does not match\n"
"the name of your current branch.  To push to the upstream branch\n"
"on the remote, use\n"
"\n"
"    git push %s HEAD:%s\n"
"\n"
"To push to the branch of the same name on the remote, use\n"
"\n"
"    git push %s HEAD\n"
"%s%s"
msgstr ""
"您当前分支的上游分支和您当前分支名不匹配，为推送到远程的上游分支，\n"
"使用\n"
"\n"
"    git push %s HEAD:%s\n"
"\n"
"为推送至远程同名分支，使用\n"
"\n"
"    git push %s HEAD\n"
"%s%s"

#: builtin/push.c
#, c-format
msgid ""
"You are not currently on a branch.\n"
"To push the history leading to the current (detached HEAD)\n"
"state now, use\n"
"\n"
"    git push %s HEAD:<name-of-remote-branch>\n"
msgstr ""
"您当前不在一个分支上。\n"
"现在为推送当前（分离头指针）的历史，使用\n"
"\n"
"    git push %s HEAD:<远程分支名字>\n"

#: builtin/push.c
msgid ""
"\n"
"To have this happen automatically for branches without a tracking\n"
"upstream, see 'push.autoSetupRemote' in 'git help config'.\n"
msgstr ""
"\n"
"为了让没有追踪上游的分支自动配置，参见 'git help config' 中的 "
"push.autoSetupRemote。\n"

#: builtin/push.c
#, c-format
msgid ""
"The current branch %s has no upstream branch.\n"
"To push the current branch and set the remote as upstream, use\n"
"\n"
"    git push --set-upstream %s %s\n"
"%s"
msgstr ""
"当前分支 %s 没有对应的上游分支。\n"
"为推送当前分支并建立与远程上游的跟踪，使用\n"
"\n"
"    git push --set-upstream %s %s\n"
"%s"

#: builtin/push.c
#, c-format
msgid "The current branch %s has multiple upstream branches, refusing to push."
msgstr "当前分支 %s 有多个上游分支，拒绝推送。"

#: builtin/push.c
msgid ""
"You didn't specify any refspecs to push, and push.default is \"nothing\"."
msgstr "您没有为推送指定任何引用规格，并且 push.default 为 \"nothing\"。"

#: builtin/push.c
#, c-format
msgid ""
"You are pushing to remote '%s', which is not the upstream of\n"
"your current branch '%s', without telling me what to push\n"
"to update which remote branch."
msgstr ""
"您正推送至远程 '%s'（其并非当前分支 '%s' 的上游），\n"
"而没有告诉我要推送什么、更新哪个远程分支。"

#: builtin/push.c
msgid ""
"Updates were rejected because the tip of your current branch is behind\n"
"its remote counterpart. If you want to integrate the remote changes,\n"
"use 'git pull' before pushing again.\n"
"See the 'Note about fast-forwards' in 'git push --help' for details."
msgstr ""
"更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。\n"
"如果您希望先与远程变更合并，请在推送前执行 'git pull'。\n"
"详见 'git push --help' 中的 'Note about fast-forwards' 小节。"

#: builtin/push.c
msgid ""
"Updates were rejected because a pushed branch tip is behind its remote\n"
"counterpart. If you want to integrate the remote changes, use 'git pull'\n"
"before pushing again.\n"
"See the 'Note about fast-forwards' in 'git push --help' for details."
msgstr ""
"更新被拒绝，因为推送的一个分支的最新提交落后于其对应的远程分支。\n"
"如果您希望先与远程变更合并，请在推送前执行 'git pull'。\n"
"详见 'git push --help' 中的 'Note about fast-forwards' 小节。"

#: builtin/push.c
msgid ""
"Updates were rejected because the remote contains work that you do not\n"
"have locally. This is usually caused by another repository pushing to\n"
"the same ref. If you want to integrate the remote changes, use\n"
"'git pull' before pushing again.\n"
"See the 'Note about fast-forwards' in 'git push --help' for details."
msgstr ""
"更新被拒绝，因为远程仓库包含您本地尚不存在的提交。这通常是因为另外\n"
"一个仓库已向该引用进行了推送。如果您希望先与远程变更合并，请在推送\n"
"前执行 'git pull'。\n"
"详见 'git push --help' 中的 'Note about fast-forwards' 小节。"

#: builtin/push.c
msgid "Updates were rejected because the tag already exists in the remote."
msgstr "更新被拒绝，因为该标签在远程已经存在。"

#: builtin/push.c
msgid ""
"You cannot update a remote ref that points at a non-commit object,\n"
"or update a remote ref to make it point at a non-commit object,\n"
"without using the '--force' option.\n"
msgstr ""
"如果不使用 '--force' 参数，您不能更新一个指向非提交对象的远程引用，\n"
"也不能更新远程引用让其指向一个非提交对象。\n"

#: builtin/push.c
msgid ""
"Updates were rejected because the tip of the remote-tracking branch has\n"
"been updated since the last checkout. If you want to integrate the\n"
"remote changes, use 'git pull' before pushing again.\n"
"See the 'Note about fast-forwards' in 'git push --help' for details."
msgstr ""
"更新被拒绝，因为远程跟踪分支的最新提交自从上次检出之后已被更新。\n"
"如果您希望先与远程变更合并，请在推送前执行 'git pull'。\n"
"详见 'git push --help' 中的 'Note about fast-forwards' 小节。"

#: builtin/push.c
#, c-format
msgid "Pushing to %s\n"
msgstr "推送到 %s\n"

#: builtin/push.c
#, c-format
msgid "failed to push some refs to '%s'"
msgstr "无法推送一些引用到 '%s'"

#: builtin/push.c
msgid ""
"recursing into submodule with push.recurseSubmodules=only; using on-demand "
"instead"
msgstr ""
"在 push.recurseSubmodules=only 时递归进入子模组；取而代之使用 on-demand"

#: builtin/push.c builtin/send-pack.c submodule-config.c
#, c-format
msgid "invalid value for '%s'"
msgstr "'%s' 的值无效"

#: builtin/push.c builtin/submodule--helper.c
msgid "repository"
msgstr "仓库"

#: builtin/push.c
msgid "push all branches"
msgstr "推送所有分支"

#: builtin/push.c builtin/send-pack.c
msgid "mirror all refs"
msgstr "镜像所有引用"

#: builtin/push.c
msgid "delete refs"
msgstr "删除引用"

#: builtin/push.c
msgid "push tags (can't be used with --all or --branches or --mirror)"
msgstr "推送标签（不能使用 --all or --branches or --mirror）"

#: builtin/push.c builtin/send-pack.c
msgid "force updates"
msgstr "强制更新"

#: builtin/push.c builtin/send-pack.c
msgid "<refname>:<expect>"
msgstr "<引用名>:<期望值>"

#: builtin/push.c builtin/send-pack.c
msgid "require old value of ref to be at this value"
msgstr "要求引用旧的取值为设定值"

#: builtin/push.c builtin/send-pack.c
msgid "require remote updates to be integrated locally"
msgstr "要求远程更新在本地被整合"

#: builtin/push.c
msgid "control recursive pushing of submodules"
msgstr "控制子模组的递归推送"

#: builtin/push.c builtin/send-pack.c
msgid "use thin pack"
msgstr "使用精简打包"

#: builtin/push.c builtin/send-pack.c
msgid "receive pack program"
msgstr "接收包程序"

#: builtin/push.c
msgid "set upstream for git pull/status"
msgstr "设置 git pull/status 的上游"

#: builtin/push.c
msgid "prune locally removed refs"
msgstr "清除本地删除的引用"

#: builtin/push.c
msgid "bypass pre-push hook"
msgstr "绕过 pre-push 钩子"

#: builtin/push.c
msgid "push missing but relevant tags"
msgstr "推送缺失但有关的标签"

#: builtin/push.c builtin/send-pack.c
msgid "GPG sign the push"
msgstr "用 GPG 为推送签名"

#: builtin/push.c builtin/send-pack.c
msgid "request atomic transaction on remote side"
msgstr "需要远端支持原子事务"

#: builtin/push.c
msgid "--delete doesn't make sense without any refs"
msgstr "--delete 未接任何引用没有意义"

#: builtin/push.c t/helper/test-bundle-uri.c
#, c-format
msgid "bad repository '%s'"
msgstr "坏的仓库 '%s'"

#: builtin/push.c
msgid ""
"No configured push destination.\n"
"Either specify the URL from the command-line or configure a remote "
"repository using\n"
"\n"
"    git remote add <name> <url>\n"
"\n"
"and then push using the remote name\n"
"\n"
"    git push <name>\n"
msgstr ""
"没有配置推送目标。\n"
"或通过命令行指定 URL，或用下面命令配置一个远程仓库\n"
"\n"
"    git remote add <名称> <地址>\n"
"\n"
"然后使用该远程仓库名执行推送\n"
"\n"
"    git push <名称>\n"

#: builtin/push.c
msgid "--all can't be combined with refspecs"
msgstr "--all 不能和引用规格同时使用"

#: builtin/push.c
msgid "--mirror can't be combined with refspecs"
msgstr "--mirror 不能和引用规格同时使用"

#: builtin/push.c
msgid "push options must not have new line characters"
msgstr "推送选项不能有换行符"

#: builtin/range-diff.c
msgid "git range-diff [<options>] <old-base>..<old-tip> <new-base>..<new-tip>"
msgstr "git range-diff [<选项>] <old-base>..<old-tip> <new-base>..<new-tip>"

#: builtin/range-diff.c
msgid "git range-diff [<options>] <old-tip>...<new-tip>"
msgstr "git range-diff [<选项>] <old-tip>...<new-tip>"

#: builtin/range-diff.c
msgid "git range-diff [<options>] <base> <old-tip> <new-tip>"
msgstr "git range-diff [<选项>] <base> <old-tip> <new-tip>"

#: builtin/range-diff.c
msgid "use simple diff colors"
msgstr "使用简单差异颜色"

#: builtin/range-diff.c
msgid "notes"
msgstr "注解"

#: builtin/range-diff.c
msgid "passed to 'git log'"
msgstr "传递给 'git log'"

#: builtin/range-diff.c
msgid "only emit output related to the first range"
msgstr "仅显示与第一个范围有关的输出"

#: builtin/range-diff.c
msgid "only emit output related to the second range"
msgstr "仅显示与第二个范围有关的输出"

#: builtin/range-diff.c
#, c-format
msgid "not a revision: '%s'"
msgstr "不是版本：'%s'"

#: builtin/range-diff.c
#, c-format
msgid "not a commit range: '%s'"
msgstr "不是提交范围：'%s'"

#: builtin/range-diff.c
#, c-format
msgid "not a symmetric range: '%s'"
msgstr "不是对称的范围：'%s'"

#: builtin/range-diff.c
msgid "need two commit ranges"
msgstr "需要两个提交范围"

#: builtin/read-tree.c
msgid ""
"git read-tree [(-m [--trivial] [--aggressive] | --reset | --"
"prefix=<prefix>)\n"
"              [-u | -i]] [--index-output=<file>] [--no-sparse-checkout]\n"
"              (--empty | <tree-ish1> [<tree-ish2> [<tree-ish3>]])"
msgstr ""
"git read-tree [(-m [--trivial] [--aggressive] | --reset | --prefix=<前缀>)\n"
"              [-u | -i]] [--index-output=<文件>] [--no-sparse-checkout]\n"
"              (--empty | <树对象一> [<树对象二> [<树对象三>]])"

#: builtin/read-tree.c
msgid "write resulting index to <file>"
msgstr "将索引结果写入 <文件>"

#: builtin/read-tree.c
msgid "only empty the index"
msgstr "只是清空索引"

#: builtin/read-tree.c
msgid "Merging"
msgstr "合并"

#: builtin/read-tree.c
msgid "perform a merge in addition to a read"
msgstr "读取之余再执行一个合并"

#: builtin/read-tree.c
msgid "3-way merge if no file level merging required"
msgstr "如果没有文件级合并需要，执行三方合并"

#: builtin/read-tree.c
msgid "3-way merge in presence of adds and removes"
msgstr "存在添加和删除时，也执行三方合并"

#: builtin/read-tree.c
msgid "same as -m, but discard unmerged entries"
msgstr "类似于 -m，但丢弃未合并的条目"

#: builtin/read-tree.c
msgid "<subdirectory>/"
msgstr "<子目录>/"

#: builtin/read-tree.c
msgid "read the tree into the index under <subdirectory>/"
msgstr "读取树对象到索引的 <子目录>/ 下"

#: builtin/read-tree.c
msgid "update working tree with merge result"
msgstr "用合并的结果更新工作区"

#: builtin/read-tree.c
msgid "gitignore"
msgstr "gitignore"

#: builtin/read-tree.c
msgid "allow explicitly ignored files to be overwritten"
msgstr "允许忽略文件中设定的文件可以被覆盖"

#: builtin/read-tree.c
msgid "don't check the working tree after merging"
msgstr "合并后不检查工作区"

#: builtin/read-tree.c
msgid "don't update the index or the work tree"
msgstr "不更新索引区和工作区"

#: builtin/read-tree.c
msgid "skip applying sparse checkout filter"
msgstr "跳过应用稀疏检出过滤器"

#: builtin/read-tree.c
msgid "debug unpack-trees"
msgstr "调试 unpack-trees"

#: builtin/read-tree.c
msgid "suppress feedback messages"
msgstr "抑制反馈信息"

#: builtin/read-tree.c
msgid "You need to resolve your current index first"
msgstr "您需要先解决当前索引的冲突"

#: builtin/rebase.c
msgid ""
"git rebase [-i] [options] [--exec <cmd>] [--onto <newbase> | --keep-base] "
"[<upstream> [<branch>]]"
msgstr ""
"git rebase [-i] [options] [--exec <命令>] [--onto <新基线> | --keep-base] [<"
"上游> [<分支>]]"

#: builtin/rebase.c
msgid ""
"git rebase [-i] [options] [--exec <cmd>] [--onto <newbase>] --root [<branch>]"
msgstr ""
"git rebase [-i] [选项] [--exec <命令>] [--onto <新基线>] --root [<分支>]"

#: builtin/rebase.c sequencer.c
#, c-format
msgid "could not read '%s'."
msgstr "不能读取 '%s'。"

#: builtin/rebase.c
#, c-format
msgid "could not create temporary %s"
msgstr "无法创建临时的 %s"

#: builtin/rebase.c
msgid "could not mark as interactive"
msgstr "无法标记为交互式"

#: builtin/rebase.c
msgid "could not generate todo list"
msgstr "无法生成待办列表"

#: builtin/rebase.c
msgid "a base commit must be provided with --upstream or --onto"
msgstr "使用 --upstream 或 --onto 必须提供一个基线提交"

#: builtin/rebase.c
#, c-format
msgid "%s requires the merge backend"
msgstr "%s 需要合并后端"

#: builtin/rebase.c
#, c-format
msgid "invalid onto: '%s'"
msgstr "无效新基线：'%s'"

#: builtin/rebase.c
#, c-format
msgid "invalid orig-head: '%s'"
msgstr "无效的原始 head：'%s'"

#: builtin/rebase.c
#, c-format
msgid "ignoring invalid allow_rerere_autoupdate: '%s'"
msgstr "忽略无效的 allow_rerere_autoupdate：'%s'"

#: builtin/rebase.c builtin/rm.c sequencer.c
#, c-format
msgid "could not remove '%s'"
msgstr "无法删除 '%s'"

#: builtin/rebase.c
#, c-format
msgid ""
"\n"
"git encountered an error while preparing the patches to replay\n"
"these revisions:\n"
"\n"
"    %s\n"
"\n"
"As a result, git cannot rebase them."
msgstr ""
"\n"
"在为重放这些版本而准备补丁时，git 遇到了一个错误：\n"
"\n"
"    %s\n"
"\n"
"因此 git 无法对其变基。"

#: builtin/rebase.c
#, c-format
msgid "Unknown rebase-merges mode: %s"
msgstr "未知的变基合并模式：%s"

#: builtin/rebase.c
#, c-format
msgid "could not switch to %s"
msgstr "无法切换到 %s"

#: builtin/rebase.c
msgid "apply options and merge options cannot be used together"
msgstr "应用选项和合并选项不能同时使用"

#: builtin/rebase.c
msgid "--empty=ask is deprecated; use '--empty=stop' instead."
msgstr "--empty=ask 已弃用；请使用 '--empty=stop'。"

#: builtin/rebase.c
#, c-format
msgid ""
"unrecognized empty type '%s'; valid values are \"drop\", \"keep\", and "
"\"stop\"."
msgstr "无法识别的空类型 '%s'；有效值有 \"drop\"、\"keep\" 和 \"stop\"。"

#: builtin/rebase.c
msgid ""
"--rebase-merges with an empty string argument is deprecated and will stop "
"working in a future version of Git. Use --rebase-merges without an argument "
"instead, which does the same thing."
msgstr ""
"为 --rebase-merges 指定空值参数的方式已经被废弃并且在 Git 未来\n"
"的版本中将不再支持。 支持使用无参数 --rebase-merges 的方式进行替\n"
"代，它们具有相同的作用。"

#: builtin/rebase.c
#, c-format
msgid ""
"%s\n"
"Please specify which branch you want to rebase against.\n"
"See git-rebase(1) for details.\n"
"\n"
"    git rebase '<branch>'\n"
"\n"
msgstr ""
"%s\n"
"请指定您要变基到哪个分支。\n"
"详见 git-rebase(1)。\n"
"\n"
"    git rebase '<branch>'\n"
"\n"

#: builtin/rebase.c
#, c-format
msgid ""
"If you wish to set tracking information for this branch you can do so with:\n"
"\n"
"    git branch --set-upstream-to=%s/<branch> %s\n"
"\n"
msgstr ""
"如果您想要为此分支创建跟踪信息，您可以执行：\n"
"\n"
"    git branch --set-upstream-to=%s/<branch> %s\n"
"\n"

#: builtin/rebase.c
msgid "exec commands cannot contain newlines"
msgstr "exec 命令不能包含换行符"

#: builtin/rebase.c
msgid "empty exec command"
msgstr "空的 exec 命令"

#: builtin/rebase.c
msgid "rebase onto given branch instead of upstream"
msgstr "变基到给定的分支而非上游"

#: builtin/rebase.c
msgid "use the merge-base of upstream and branch as the current base"
msgstr "使用上游和分支的合并基线做为当前基线"

#: builtin/rebase.c
msgid "allow pre-rebase hook to run"
msgstr "允许执行 pre-rebase 钩子"

#: builtin/rebase.c
msgid "be quiet. implies --no-stat"
msgstr "安静。暗示 --no-stat"

#: builtin/rebase.c
msgid "display a diffstat of what changed upstream"
msgstr "显示上游变化的差异统计"

#: builtin/rebase.c
msgid "do not show diffstat of what changed upstream"
msgstr "不显示上游变化的差异统计"

#: builtin/rebase.c
msgid "add a Signed-off-by trailer to each commit"
msgstr "为每一个提交添加 Signed-off-by 尾注"

#: builtin/rebase.c
msgid "make committer date match author date"
msgstr "使提交者日期和作者日期一致"

#: builtin/rebase.c
msgid "ignore author date and use current date"
msgstr "忽略作者日期，使用当前日期"

#: builtin/rebase.c
msgid "synonym of --reset-author-date"
msgstr "--reset-author-date 的同义词"

#: builtin/rebase.c
msgid "passed to 'git apply'"
msgstr "传递给 'git apply'"

#: builtin/rebase.c
msgid "ignore changes in whitespace"
msgstr "忽略空白字符的变更"

#: builtin/rebase.c
msgid "cherry-pick all commits, even if unchanged"
msgstr "拣选所有提交，即使未修改"

#: builtin/rebase.c
msgid "continue"
msgstr "继续"

#: builtin/rebase.c
msgid "skip current patch and continue"
msgstr "跳过当前补丁并继续"

#: builtin/rebase.c
msgid "abort and check out the original branch"
msgstr "终止并检出原有分支"

#: builtin/rebase.c
msgid "abort but keep HEAD where it is"
msgstr "终止但保持 HEAD 不变"

#: builtin/rebase.c
msgid "edit the todo list during an interactive rebase"
msgstr "在交互式变基中编辑待办列表"

#: builtin/rebase.c
msgid "show the patch file being applied or merged"
msgstr "显示正在应用或合并的补丁文件"

#: builtin/rebase.c
msgid "use apply strategies to rebase"
msgstr "使用应用策略进行变基"

#: builtin/rebase.c
msgid "use merging strategies to rebase"
msgstr "使用合并策略进行变基"

#: builtin/rebase.c
msgid "let the user edit the list of commits to rebase"
msgstr "让用户编辑要变基的提交列表"

#: builtin/rebase.c
msgid "(REMOVED) was: try to recreate merges instead of ignoring them"
msgstr "（已删除）曾是：尝试重建合并提交而非忽略它们"

#: builtin/rebase.c builtin/revert.c
msgid "how to handle commits that become empty"
msgstr "如何处理成为空提交的提交"

#: builtin/rebase.c
msgid "keep commits which start empty"
msgstr "保留初始为空的提交"

#: builtin/rebase.c
msgid "move commits that begin with squash!/fixup! under -i"
msgstr "在 -i 交互模式下，移动以 squash!/fixup! 开头的提交"

#: builtin/rebase.c
msgid "update branches that point to commits that are being rebased"
msgstr "更新指向正在被变基的提交的分支"

#: builtin/rebase.c
msgid "add exec lines after each commit of the editable list"
msgstr "可编辑列表的每一个提交下面增加一行 exec"

#: builtin/rebase.c
msgid "allow rebasing commits with empty messages"
msgstr "允许针对空提交说明的提交变基"

#: builtin/rebase.c
msgid "try to rebase merges instead of skipping them"
msgstr "尝试对合并提交变基而不是忽略它们"

#: builtin/rebase.c
msgid "use 'merge-base --fork-point' to refine upstream"
msgstr "使用 'merge-base --fork-point' 来优化上游"

#: builtin/rebase.c
msgid "use the given merge strategy"
msgstr "使用给定的合并策略"

#: builtin/rebase.c builtin/revert.c
msgid "option"
msgstr "选项"

#: builtin/rebase.c
msgid "pass the argument through to the merge strategy"
msgstr "将参数传递给合并策略"

#: builtin/rebase.c
msgid "rebase all reachable commits up to the root(s)"
msgstr "将所有可达的提交变基到根提交"

#: builtin/rebase.c
msgid "automatically re-schedule any `exec` that fails"
msgstr "自动重新安排任何失败的 `exec`"

#: builtin/rebase.c
msgid "apply all changes, even those already present upstream"
msgstr "应用所有更改，甚至那些已在上游存在的"

#: builtin/rebase.c
msgid "It looks like 'git am' is in progress. Cannot rebase."
msgstr "看起来 'git am' 正在执行中。无法变基。"

#: builtin/rebase.c
msgid ""
"`rebase --preserve-merges` (-p) is no longer supported.\n"
"Use `git rebase --abort` to terminate current rebase.\n"
"Or downgrade to v2.33, or earlier, to complete the rebase."
msgstr ""
"`rebase --preserve-merges` (-p) 不再被支持。\n"
"使用 `git rebase --abort` 来终止当前的变基。\n"
"或者降级至 v2.33 或更早的版本来完成此次变基。"

#: builtin/rebase.c
msgid ""
"--preserve-merges was replaced by --rebase-merges\n"
"Note: Your `pull.rebase` configuration may also be set to 'preserve',\n"
"which is no longer supported; use 'merges' instead"
msgstr ""
"--preserve-merges 被 --rebase-merges 取代\n"
"提示：你的 `pull.rebase` 配置可能是不再被支持的 'preserve' 选项；\n"
"取而代之请使用 'merges'"

#: builtin/rebase.c
msgid "no rebase in progress"
msgstr "没有正在进行的变基"

#: builtin/rebase.c
msgid "The --edit-todo action can only be used during interactive rebase."
msgstr "动作 --edit-todo 只能用在交互式变基过程中。"

#: builtin/rebase.c
msgid "Cannot read HEAD"
msgstr "不能读取 HEAD"

#: builtin/rebase.c
msgid ""
"You must edit all merge conflicts and then\n"
"mark them as resolved using git add"
msgstr ""
"您必须编辑所有的合并冲突，然后通过 git add\n"
"命令将它们标记为已解决"

#: builtin/rebase.c
msgid "could not discard worktree changes"
msgstr "无法丢弃工作区变更"

#: builtin/rebase.c
#, c-format
msgid "could not move back to %s"
msgstr "无法移回 %s"

#: builtin/rebase.c
#, c-format
msgid ""
"It seems that there is already a %s directory, and\n"
"I wonder if you are in the middle of another rebase.  If that is the\n"
"case, please try\n"
"\t%s\n"
"If that is not the case, please\n"
"\t%s\n"
"and run me again.  I am stopping in case you still have something\n"
"valuable there.\n"
msgstr ""
"似乎已有一个 %s 目录，我怀疑您正处于另外一个变基操作过程中。\n"
"如果是这样，请执行\n"
"\t%s\n"
"如果不是这样，请执行\n"
"\t%s\n"
"然后再重新执行。 为避免丢失重要数据，我已经停止当前操作。\n"

#: builtin/rebase.c
msgid "switch `C' expects a numerical value"
msgstr "开关 `C' 期望一个数字值"

#: builtin/rebase.c
msgid ""
"apply options are incompatible with rebase.rebaseMerges.  Consider adding --"
"no-rebase-merges"
msgstr "应用的选项与 rebase.rebaseMerges 不兼容。考虑加上 --no-rebase-merges"

#: builtin/rebase.c
msgid ""
"apply options are incompatible with rebase.updateRefs.  Consider adding --no-"
"update-refs"
msgstr "应用的选项与 rebase.updateRefs 不兼容。考虑加上 --no-update-refs"

#: builtin/rebase.c
#, c-format
msgid "Unknown rebase backend: %s"
msgstr "未知的变基后端：%s"

#: builtin/rebase.c
msgid "--reschedule-failed-exec requires --exec or --interactive"
msgstr "--reschedule-failed-exec 需要 --exec 或 --interactive"

#: builtin/rebase.c
#, c-format
msgid "invalid upstream '%s'"
msgstr "无效的上游 '%s'"

#: builtin/rebase.c
msgid "Could not create new root commit"
msgstr "不能创建新的根提交"

#: builtin/rebase.c
#, c-format
msgid "no such branch/commit '%s'"
msgstr "无此分支/提交 '%s'"

#: builtin/rebase.c builtin/submodule--helper.c
#, c-format
msgid "No such ref: %s"
msgstr "没有这样的引用：%s"

#: builtin/rebase.c
msgid "Could not resolve HEAD to a commit"
msgstr "不能解析 HEAD 至一个提交"

#: builtin/rebase.c
#, c-format
msgid "'%s': need exactly one merge base with branch"
msgstr "'%s'：只需要与分支的一个合并基线"

#: builtin/rebase.c
#, c-format
msgid "'%s': need exactly one merge base"
msgstr "'%s'：只需要一个合并基线"

#: builtin/rebase.c
#, c-format
msgid "Does not point to a valid commit '%s'"
msgstr "没有指向一个有效的提交 '%s'"

#: builtin/rebase.c
msgid "HEAD is up to date."
msgstr "HEAD 是最新的。"

#: builtin/rebase.c
#, c-format
msgid "Current branch %s is up to date.\n"
msgstr "当前分支 %s 是最新的。\n"

#: builtin/rebase.c
msgid "HEAD is up to date, rebase forced."
msgstr "HEAD 是最新的，强制变基。"

#: builtin/rebase.c
#, c-format
msgid "Current branch %s is up to date, rebase forced.\n"
msgstr "当前分支 %s 是最新的，强制变基。\n"

#: builtin/rebase.c
msgid "The pre-rebase hook refused to rebase."
msgstr "pre-rebase 钩子拒绝了变基操作。"

#: builtin/rebase.c
#, c-format
msgid "Changes to %s:\n"
msgstr "到 %s 的变更：\n"

#: builtin/rebase.c
#, c-format
msgid "Changes from %s to %s:\n"
msgstr "从 %s 到 %s 的变更：\n"

#: builtin/rebase.c
#, c-format
msgid "First, rewinding head to replay your work on top of it...\n"
msgstr "首先，回退头指针以便在其上重放您的工作...\n"

#: builtin/rebase.c
msgid "Could not detach HEAD"
msgstr "无法分离头指针"

#: builtin/rebase.c
#, c-format
msgid "Fast-forwarded %s to %s.\n"
msgstr "快进 %s 到 %s。\n"

#: builtin/receive-pack.c
msgid "git receive-pack <git-dir>"
msgstr "git receive-pack <仓库目录>"

#: builtin/receive-pack.c
msgid ""
"By default, updating the current branch in a non-bare repository\n"
"is denied, because it will make the index and work tree inconsistent\n"
"with what you pushed, and will require 'git reset --hard' to match\n"
"the work tree to HEAD.\n"
"\n"
"You can set the 'receive.denyCurrentBranch' configuration variable\n"
"to 'ignore' or 'warn' in the remote repository to allow pushing into\n"
"its current branch; however, this is not recommended unless you\n"
"arranged to update its work tree to match what you pushed in some\n"
"other way.\n"
"\n"
"To squelch this message and still keep the default behaviour, set\n"
"'receive.denyCurrentBranch' configuration variable to 'refuse'."
msgstr ""
"默认禁止更新非纯仓库的当前分支，因为您推送的内容将导致索引和工作区\n"
"不一致，并且将需要执行 'git reset --hard' 将工作区匹配到 HEAD。\n"
"\n"
"您可以在远程仓库中设置 'receive.denyCurrentBranch' 配置变量为\n"
"'ignore' 或 'warn' 以允许推送到当前分支。然而不推荐这么做，除非您\n"
"用某种方式将其工作区更新至您推送的状态。\n"
"\n"
"若要屏蔽此信息且保持默认行为，设置 'receive.denyCurrentBranch'\n"
"配置变量为 'refuse'。"

#: builtin/receive-pack.c
msgid ""
"By default, deleting the current branch is denied, because the next\n"
"'git clone' won't result in any file checked out, causing confusion.\n"
"\n"
"You can set 'receive.denyDeleteCurrent' configuration variable to\n"
"'warn' or 'ignore' in the remote repository to allow deleting the\n"
"current branch, with or without a warning message.\n"
"\n"
"To squelch this message, you can set it to 'refuse'."
msgstr ""
"默认禁止删除当前分支，因为下一次 'git clone' 将不会检出任何文件，\n"
"导致困惑。\n"
"\n"
"您可以在远程仓库中设置 'receive.denyDeleteCurrent' 配置变量为\n"
"'warn'（显示警告信息）或 'ignore'（忽略警告信息）以允许删除当前分支。\n"
"\n"
"若要屏蔽此信息，您可以设置它为 'refuse'。"

#: builtin/receive-pack.c
msgid "quiet"
msgstr "静默模式"

#: builtin/receive-pack.c
msgid "you must specify a directory"
msgstr "您必须指定一个目录"

#: builtin/reflog.c
msgid "git reflog [show] [<log-options>] [<ref>]"
msgstr "git reflog [show] [<log 选项>] [<引用>]"

#: builtin/reflog.c
msgid "git reflog list"
msgstr "git reflog list"

#: builtin/reflog.c
msgid ""
"git reflog expire [--expire=<time>] [--expire-unreachable=<time>]\n"
"                  [--rewrite] [--updateref] [--stale-fix]\n"
"                  [--dry-run | -n] [--verbose] [--all [--single-worktree] | "
"<refs>...]"
msgstr ""
"git reflog expire [--expire=<时间>] [--expire-unreachable=<时间>]\n"
"                  [--rewrite] [--updateref] [--stale-fix]\n"
"                  [--dry-run | -n] [--verbose] [--all [--single-worktree] | <"
"引用>...]"

#: builtin/reflog.c
msgid ""
"git reflog delete [--rewrite] [--updateref]\n"
"                  [--dry-run | -n] [--verbose] <ref>@{<specifier>}..."
msgstr ""
"git reflog delete [--rewrite] [--updateref]\n"
"                  [--dry-run | -n] [--verbose] <引用>@{<指定符>}..."

#: builtin/reflog.c
msgid "git reflog exists <ref>"
msgstr "git reflog exists <引用>"

#: builtin/reflog.c
#, c-format
msgid "invalid timestamp '%s' given to '--%s'"
msgstr "给 '--%2$s' 的时间戳 '%1$s' 无效"

#: builtin/reflog.c sequencer.c
#, c-format
msgid "%s does not accept arguments: '%s'"
msgstr "%s 不接受参数：'%s'"

#: builtin/reflog.c
msgid "do not actually prune any entries"
msgstr "不要实际清除任何条目"

#: builtin/reflog.c
msgid ""
"rewrite the old SHA1 with the new SHA1 of the entry that now precedes it"
msgstr "用现在前继条目的 SHA1 来重写旧的 SHA1"

#: builtin/reflog.c
msgid "update the reference to the value of the top reflog entry"
msgstr "更新引用至引用日志顶部的条目"

#: builtin/reflog.c
msgid "print extra information on screen"
msgstr "在屏幕上打印额外信息"

#: builtin/reflog.c
msgid "timestamp"
msgstr "时间戳"

#: builtin/reflog.c
msgid "prune entries older than the specified time"
msgstr "清除早于指定时间之前的条目"

#: builtin/reflog.c
msgid ""
"prune entries older than <time> that are not reachable from the current tip "
"of the branch"
msgstr "清除早于 <时间> 且自当前分支顶部不可达的条目"

#: builtin/reflog.c
msgid "prune any reflog entries that point to broken commits"
msgstr "清除指向损坏提交的引用条目"

#: builtin/reflog.c
msgid "process the reflogs of all references"
msgstr "处理所有引用的引用日志"

#: builtin/reflog.c
msgid "limits processing to reflogs from the current worktree only"
msgstr "仅处理当前工作树的引用日志"

#: builtin/reflog.c
#, c-format
msgid "Marking reachable objects..."
msgstr "正在标记可达对象..."

#: builtin/reflog.c
#, c-format
msgid "%s points nowhere!"
msgstr "%s 指向不存在！"

#: builtin/reflog.c
msgid "no reflog specified to delete"
msgstr "未指定要删除的引用日志"

#: builtin/reflog.c
#, c-format
msgid "invalid ref format: %s"
msgstr "无效的引用格式：%s"

#: builtin/refs.c
msgid "git refs migrate --ref-format=<format> [--no-reflog] [--dry-run]"
msgstr "git refs migrate --ref-format=<格式> [--no-reflog] [--dry-run]"

#: builtin/refs.c
msgid "git refs verify [--strict] [--verbose]"
msgstr "git refs verify [--strict] [--verbose]"

#: builtin/refs.c
msgid "specify the reference format to convert to"
msgstr "指定要转换的引用格式"

#: builtin/refs.c
msgid "perform a non-destructive dry-run"
msgstr "进行非破坏性的试运行（dry-run）"

#: builtin/refs.c
msgid "drop reflogs entirely during the migration"
msgstr "在迁移期间丢弃引用日志"

#: builtin/refs.c
msgid "missing --ref-format=<format>"
msgstr "缺少 --ref-format=<格式>"

#: builtin/refs.c
#, c-format
msgid "repository already uses '%s' format"
msgstr "仓库已使用 '%s' 格式"

#: builtin/refs.c
msgid "enable strict checking"
msgstr "启用严格的检查"

#: builtin/refs.c
msgid "'git refs verify' takes no arguments"
msgstr "'git refs verify' 不接受任何参数"

#: builtin/remote.c
msgid ""
"git remote add [-t <branch>] [-m <master>] [-f] [--tags | --no-tags] [--"
"mirror=<fetch|push>] <name> <url>"
msgstr ""
"git remote add [-t <分支>] [-m <master>] [-f] [--tags | --no-tags] [--"
"mirror=<fetch|push>] <名称> <地址>"

#: builtin/remote.c
msgid "git remote rename [--[no-]progress] <old> <new>"
msgstr "git remote rename [--[no-]progress] <旧> <新>"

#: builtin/remote.c
msgid "git remote remove <name>"
msgstr "git remote remove <名称>"

#: builtin/remote.c
msgid "git remote set-head <name> (-a | --auto | -d | --delete | <branch>)"
msgstr "git remote set-head <名称> (-a | --auto | -d | --delete | <分支>)"

#: builtin/remote.c
msgid "git remote [-v | --verbose] show [-n] <name>"
msgstr "git remote [-v | --verbose] show [-n] <名称>"

#: builtin/remote.c
msgid "git remote prune [-n | --dry-run] <name>"
msgstr "git remote prune [-n | --dry-run] <名称>"

#: builtin/remote.c
msgid ""
"git remote [-v | --verbose] update [-p | --prune] [(<group> | <remote>)...]"
msgstr "git remote [-v | --verbose] update [-p | --prune] [(<组> | <远程>)...]"

#: builtin/remote.c
msgid "git remote set-branches [--add] <name> <branch>..."
msgstr "git remote set-branches [--add] <名称> <分支>..."

#: builtin/remote.c
msgid "git remote get-url [--push] [--all] <name>"
msgstr "git remote get-url [--push] [--all] <名称>"

#: builtin/remote.c
msgid "git remote set-url [--push] <name> <newurl> [<oldurl>]"
msgstr "git remote set-url [--push] <名称> <新的地址> [<旧的地址>]"

#: builtin/remote.c
msgid "git remote set-url --add <name> <newurl>"
msgstr "git remote set-url --add <名称> <新的地址>"

#: builtin/remote.c
msgid "git remote set-url --delete <name> <url>"
msgstr "git remote set-url --delete <名称> <地址>"

#: builtin/remote.c
msgid "git remote add [<options>] <name> <url>"
msgstr "git remote add [<选项>] <名称> <地址>"

#: builtin/remote.c
msgid "git remote set-branches <name> <branch>..."
msgstr "git remote set-branches <名称> <分支>..."

#: builtin/remote.c
msgid "git remote set-branches --add <name> <branch>..."
msgstr "git remote set-branches --add <名称> <分支>..."

#: builtin/remote.c
msgid "git remote show [<options>] <name>"
msgstr "git remote show [<选项>] <名称>"

#: builtin/remote.c
msgid "git remote prune [<options>] <name>"
msgstr "git remote prune [<选项>] <名称>"

#: builtin/remote.c
msgid "git remote update [<options>] [<group> | <remote>]..."
msgstr "git remote update [<选项>] [<组> | <远程>]..."

#: builtin/remote.c
#, c-format
msgid "Updating %s"
msgstr "更新 %s 中"

#: builtin/remote.c
#, c-format
msgid "Could not fetch %s"
msgstr "不能获取 %s"

#: builtin/remote.c
msgid ""
"--mirror is dangerous and deprecated; please\n"
"\t use --mirror=fetch or --mirror=push instead"
msgstr ""
"--mirror 选项危险且过时，请使用 --mirror=fetch\n"
"\t 或 --mirror=push"

#: builtin/remote.c
#, c-format
msgid "unknown --mirror argument: %s"
msgstr "未知的 --mirror 参数：%s"

#: builtin/remote.c
msgid "fetch the remote branches"
msgstr "抓取远程的分支"

#: builtin/remote.c
msgid ""
"import all tags and associated objects when fetching\n"
"or do not fetch any tag at all (--no-tags)"
msgstr "抓取时导入所有的标签和关联对象，或不抓取任何标签（--no-tags）"

#: builtin/remote.c
msgid "branch(es) to track"
msgstr "跟踪的分支"

#: builtin/remote.c
msgid "master branch"
msgstr "主线分支"

#: builtin/remote.c
msgid "set up remote as a mirror to push to or fetch from"
msgstr "把远程设置为用以推送或抓取的镜像"

#: builtin/remote.c
msgid "specifying a master branch makes no sense with --mirror"
msgstr "指定一个 master 分支并使用 --mirror 选项没有意义"

#: builtin/remote.c
msgid "specifying branches to track makes sense only with fetch mirrors"
msgstr "指定要跟踪的分支只在与获取镜像同时使用才有意义"

#: builtin/remote.c
#, c-format
msgid "remote %s already exists."
msgstr "远程 %s 已经存在。"

#: builtin/remote.c
#, c-format
msgid "Could not setup master '%s'"
msgstr "无法设置 master '%s'"

#: builtin/remote.c trailer.c
#, c-format
msgid "more than one %s"
msgstr "多于一个 %s"

#: builtin/remote.c
#, c-format
msgid "unhandled branch.%s.rebase=%s; assuming 'true'"
msgstr "未处理的 branch.%s.rebase=%s; 假定为 'true'"

#: builtin/remote.c
#, c-format
msgid "Could not get fetch map for refspec %s"
msgstr "无法得到引用规格 %s 的获取列表"

#: builtin/remote.c
msgid "(matching)"
msgstr "（匹配）"

#: builtin/remote.c
msgid "(delete)"
msgstr "（删除）"

#: builtin/remote.c
#, c-format
msgid "could not set '%s'"
msgstr "不能设置 '%s'"

#: builtin/remote.c config.c
#, c-format
msgid "could not unset '%s'"
msgstr "不能取消设置 '%s'"

#: builtin/remote.c
#, c-format
msgid ""
"The %s configuration remote.pushDefault in:\n"
"\t%s:%d\n"
"now names the non-existent remote '%s'"
msgstr ""
"配置（%s）remote.pushDefault 位于：\n"
"\t%s:%d\n"
"现在在为不存在的远程名 '%s' 命名"

#: builtin/remote.c
#, c-format
msgid "No such remote: '%s'"
msgstr "没有此远程仓库：'%s'"

#: builtin/remote.c
#, c-format
msgid "Could not rename config section '%s' to '%s'"
msgstr "不能重命名配置小节 '%s' 到 '%s'"

#: builtin/remote.c
#, c-format
msgid ""
"Not updating non-default fetch refspec\n"
"\t%s\n"
"\tPlease update the configuration manually if necessary."
msgstr ""
"没有更新非默认的获取引用规格\n"
"\t%s\n"
"\t如果必要请手动更新配置。"

#: builtin/remote.c
msgid "Renaming remote references"
msgstr "正在重命名远程引用"

#: builtin/remote.c
#, c-format
msgid "deleting '%s' failed"
msgstr "删除 '%s' 失败"

#: builtin/remote.c
#, c-format
msgid "creating '%s' failed"
msgstr "创建 '%s' 失败"

#: builtin/remote.c
msgid ""
"Note: A branch outside the refs/remotes/ hierarchy was not removed;\n"
"to delete it, use:"
msgid_plural ""
"Note: Some branches outside the refs/remotes/ hierarchy were not removed;\n"
"to delete them, use:"
msgstr[0] "注意：refs/remotes/ 层级之外的一个分支未被移除。要删除它，使用："
msgstr[1] "注意：refs/remotes/ 层级之外的一些分支未被移除。要删除它们，使用："

#: builtin/remote.c
#, c-format
msgid "Could not remove config section '%s'"
msgstr "不能移除配置小节 '%s'"

#: builtin/remote.c
#, c-format
msgid " new (next fetch will store in remotes/%s)"
msgstr " 新的（下一次获取将存储于 remotes/%s）"

#: builtin/remote.c
msgid " tracked"
msgstr " 已跟踪"

#: builtin/remote.c
msgid " skipped"
msgstr " 已跳过"

#: builtin/remote.c
msgid " stale (use 'git remote prune' to remove)"
msgstr " 已过期（使用 'git remote prune' 来移除）"

#: builtin/remote.c
msgid " ???"
msgstr " ???"

#: builtin/remote.c
#, c-format
msgid "invalid branch.%s.merge; cannot rebase onto > 1 branch"
msgstr "无效的 branch.%s.merge，不能变基到一个以上的分支"

#: builtin/remote.c
#, c-format
msgid "rebases interactively onto remote %s"
msgstr "交互式变基到远程 %s"

#: builtin/remote.c
#, c-format
msgid "rebases interactively (with merges) onto remote %s"
msgstr "交互式变基（含合并提交）到远程 %s"

#: builtin/remote.c
#, c-format
msgid "rebases onto remote %s"
msgstr "变基到远程 %s"

#: builtin/remote.c
#, c-format
msgid " merges with remote %s"
msgstr " 与远程 %s 合并"

#: builtin/remote.c
#, c-format
msgid "merges with remote %s"
msgstr "与远程 %s 合并"

#: builtin/remote.c
#, c-format
msgid "%-*s    and with remote %s\n"
msgstr "%-*s    以及和远程 %s\n"

#: builtin/remote.c
msgid "create"
msgstr "创建"

#: builtin/remote.c
msgid "delete"
msgstr "删除"

#: builtin/remote.c
msgid "up to date"
msgstr "最新"

#: builtin/remote.c
msgid "fast-forwardable"
msgstr "可快进"

#: builtin/remote.c
msgid "local out of date"
msgstr "本地已过时"

#: builtin/remote.c
#, c-format
msgid "    %-*s forces to %-*s (%s)"
msgstr "    %-*s 强制推送至 %-*s (%s)"

#: builtin/remote.c
#, c-format
msgid "    %-*s pushes to %-*s (%s)"
msgstr "    %-*s 推送至 %-*s (%s)"

#: builtin/remote.c
#, c-format
msgid "    %-*s forces to %s"
msgstr "    %-*s 强制推送至 %s"

#: builtin/remote.c
#, c-format
msgid "    %-*s pushes to %s"
msgstr "    %-*s 推送至 %s"

#: builtin/remote.c
msgid "do not query remotes"
msgstr "不查询远程"

#: builtin/remote.c
#, c-format
msgid "* remote %s"
msgstr "* 远程 %s"

#: builtin/remote.c
#, c-format
msgid "  Fetch URL: %s"
msgstr "  获取地址：%s"

#. TRANSLATORS: the colon ':' should align
#. with the one in " Fetch URL: %s"
#. translation.
#.
#: builtin/remote.c
#, c-format
msgid "  Push  URL: %s"
msgstr "  推送地址：%s"

#: builtin/remote.c
msgid "(no URL)"
msgstr "(无 URL)"

#: builtin/remote.c
#, c-format
msgid "  HEAD branch: %s"
msgstr "  HEAD 分支：%s"

#: builtin/remote.c
msgid "(not queried)"
msgstr "（未查询）"

#: builtin/remote.c
msgid "(unknown)"
msgstr "（未知）"

#: builtin/remote.c
#, c-format
msgid ""
"  HEAD branch (remote HEAD is ambiguous, may be one of the following):\n"
msgstr "  HEAD 分支（远程 HEAD 模糊，可能是下列中的一个）：\n"

#: builtin/remote.c
#, c-format
msgid "  Remote branch:%s"
msgid_plural "  Remote branches:%s"
msgstr[0] "  远程分支：%s"
msgstr[1] "  远程分支：%s"

#  译者：中文字符串拼接，可删除前导空格
#: builtin/remote.c
msgid " (status not queried)"
msgstr "（状态未查询）"

#: builtin/remote.c
msgid "  Local branch configured for 'git pull':"
msgid_plural "  Local branches configured for 'git pull':"
msgstr[0] "  为 'git pull' 配置的本地分支："
msgstr[1] "  为 'git pull' 配置的本地分支："

#: builtin/remote.c
msgid "  Local refs will be mirrored by 'git push'"
msgstr "  本地引用将在 'git push' 时被镜像"

#: builtin/remote.c
#, c-format
msgid "  Local ref configured for 'git push'%s:"
msgid_plural "  Local refs configured for 'git push'%s:"
msgstr[0] "  为 'git push' 配置的本地引用%s："
msgstr[1] "  为 'git push' 配置的本地引用%s："

#: builtin/remote.c
#, c-format
msgid "'%s/HEAD' is unchanged and points to '%s'\n"
msgstr "'%s/HEAD' 未改变并指向 '%s'\n"

#: builtin/remote.c
#, c-format
msgid "'%s/HEAD' has changed from '%s' and now points to '%s'\n"
msgstr "'%s/HEAD' 已从 '%s' 更改，现在指向 '%s'\n"

#: builtin/remote.c
#, c-format
msgid "'%s/HEAD' is now created and points to '%s'\n"
msgstr "'%s/HEAD' 现已创建并指向 '%s'\n"

#: builtin/remote.c
#, c-format
msgid "'%s/HEAD' was detached at '%s' and now points to '%s'\n"
msgstr "'%s/HEAD' 在 '%s' 处分离并且现在指向 '%s'\n"

#: builtin/remote.c
#, c-format
msgid ""
"'%s/HEAD' used to point to '%s' (which is not a remote branch), but now "
"points to '%s'\n"
msgstr "'%s/HEAD' 曾指向 '%s'（不是远程分支），但现在指向 '%s'\n"

#: builtin/remote.c
msgid "set refs/remotes/<name>/HEAD according to remote"
msgstr "根据远程设置 refs/remotes/<名称>/HEAD"

#: builtin/remote.c
msgid "delete refs/remotes/<name>/HEAD"
msgstr "删除 refs/remotes/<名称>/HEAD"

#: builtin/remote.c
msgid "Cannot determine remote HEAD"
msgstr "无法确定远程 HEAD"

#: builtin/remote.c
msgid "Multiple remote HEAD branches. Please choose one explicitly with:"
msgstr "多个远程 HEAD 分支。请明确地选择一个用命令："

#: builtin/remote.c
#, c-format
msgid "Could not delete %s"
msgstr "无法删除 %s"

#: builtin/remote.c
#, c-format
msgid "Not a valid ref: %s"
msgstr "不是一个有效引用：%s"

#: builtin/remote.c
#, c-format
msgid "Could not set up %s"
msgstr "不能设置 %s"

#  译者：注意保持前导空格
#: builtin/remote.c
#, c-format
msgid " %s will become dangling!"
msgstr " %s 将成为悬空状态！"

#  译者：注意保持前导空格
#: builtin/remote.c
#, c-format
msgid " %s has become dangling!"
msgstr " %s 已成为悬空状态！"

#: builtin/remote.c
#, c-format
msgid "Pruning %s"
msgstr "修剪 %s"

#: builtin/remote.c
#, c-format
msgid "URL: %s"
msgstr "URL：%s"

#: builtin/remote.c
#, c-format
msgid " * [would prune] %s"
msgstr " * [将删除] %s"

#: builtin/remote.c
#, c-format
msgid " * [pruned] %s"
msgstr " * [已删除] %s"

#: builtin/remote.c
msgid "prune remotes after fetching"
msgstr "抓取后清除远程"

#: builtin/remote.c
#, c-format
msgid "No such remote '%s'"
msgstr "没有此远程 '%s'"

#: builtin/remote.c
msgid "add branch"
msgstr "添加分支"

#: builtin/remote.c
msgid "no remote specified"
msgstr "未指定远程"

#: builtin/remote.c
msgid "query push URLs rather than fetch URLs"
msgstr "查询推送 URL 地址，而非获取 URL 地址"

#: builtin/remote.c
msgid "return all URLs"
msgstr "返回所有 URL 地址"

#: builtin/remote.c
msgid "manipulate push URLs"
msgstr "操作推送 URLS"

#: builtin/remote.c
msgid "add URL"
msgstr "添加 URL"

#: builtin/remote.c
msgid "delete URLs"
msgstr "删除 URLS"

#: builtin/remote.c
msgid "--add --delete doesn't make sense"
msgstr "--add --delete 无意义"

#: builtin/remote.c
#, c-format
msgid "Invalid old URL pattern: %s"
msgstr "无效的旧 URL 匹配模版：%s"

#: builtin/remote.c
#, c-format
msgid "No such URL found: %s"
msgstr "未找到此 URL：%s"

#: builtin/remote.c
msgid "Will not delete all non-push URLs"
msgstr "将不会删除所有非推送 URL 地址"

#: builtin/remote.c
msgid "be verbose; must be placed before a subcommand"
msgstr "冗长输出；必须置于子命令之前"

#: builtin/repack.c
msgid ""
"git repack [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [-m]\n"
"[--window=<n>] [--depth=<n>] [--threads=<n>] [--keep-pack=<pack-name>]\n"
"[--write-midx] [--name-hash-version=<n>]"
msgstr ""
"git repack [-a] [-A] [-d] [-f] [-F] [-l] [-n] [-q] [-b] [-m]\n"
"[--window=<n>] [--depth=<n>] [--threads=<n>] [--keep-pack=<包名>]\n"
"[--write-midx] [--name-hash-version=<n>]"

#: builtin/repack.c
msgid ""
"Incremental repacks are incompatible with bitmap indexes.  Use\n"
"--no-write-bitmap-index or disable the pack.writeBitmaps configuration."
msgstr ""
"增量 repack 和 bitmap 索引不兼容。  使用 --no-write-bitmap-index\n"
"或禁用 pack.writeBitmaps 配置。"

#: builtin/repack.c
msgid "could not start pack-objects to repack promisor objects"
msgstr "无法开始 pack-objects 来重新打包 promisor 对象"

#: builtin/repack.c
msgid "failed to feed promisor objects to pack-objects"
msgstr "无法将承诺者对象提供给 pack-objects"

#: builtin/repack.c
msgid "repack: Expecting full hex object ID lines only from pack-objects."
msgstr "repack：期望来自 pack-objects 的完整十六进制对象 ID。"

#: builtin/repack.c
msgid "could not finish pack-objects to repack promisor objects"
msgstr "无法完成 pack-objects 来重新打包 promisor 对象"

#: builtin/repack.c
#, c-format
msgid "cannot open index for %s"
msgstr "不能打开 %s 的索引"

#: builtin/repack.c
#, c-format
msgid "pack %s too large to consider in geometric progression"
msgstr "包 %s 太大，不在几何级数中考虑"

#: builtin/repack.c
#, c-format
msgid "pack %s too large to roll up"
msgstr "包 %s 太大导致数字溢出"

#: builtin/repack.c
#, c-format
msgid "could not open tempfile %s for writing"
msgstr "无法打开临时文件 %s 进行写入"

#: builtin/repack.c
msgid "could not close refs snapshot tempfile"
msgstr "不能关闭引用快照临时文件"

#: builtin/repack.c
#, c-format
msgid "could not remove stale bitmap: %s"
msgstr "无法删除过期的位图： %s"

#: builtin/repack.c
#, c-format
msgid "pack prefix %s does not begin with objdir %s"
msgstr "包前缀 %s 没有以对象目录 %s 开始"

#: builtin/repack.c
msgid "pack everything in a single pack"
msgstr "所有内容打包到一个包文件中"

#: builtin/repack.c
msgid "same as -a, and turn unreachable objects loose"
msgstr "和 -a 相同，并将不可达的对象设为松散对象"

#: builtin/repack.c
msgid "same as -a, pack unreachable cruft objects separately"
msgstr "和 -a 相同，将不可达的废弃对象分开打包"

#: builtin/repack.c
msgid "approxidate"
msgstr "近似日期"

#: builtin/repack.c
msgid "with --cruft, expire objects older than this"
msgstr "使用 --cruft，使早于给定时间的对象过期"

#: builtin/repack.c
msgid "remove redundant packs, and run git-prune-packed"
msgstr "删除多余的包，运行 git-prune-packed"

#: builtin/repack.c
msgid "pass --no-reuse-delta to git-pack-objects"
msgstr "向 git-pack-objects 传递参数 --no-reuse-delta"

#: builtin/repack.c
msgid "pass --no-reuse-object to git-pack-objects"
msgstr "向 git-pack-objects 传递参数 --no-reuse-object"

#: builtin/repack.c
msgid ""
"specify the name hash version to use for grouping similar objects by path"
msgstr "指定要使用的名称哈希算法，以实现按照路径对相似对象分组"

#: builtin/repack.c
msgid "do not run git-update-server-info"
msgstr "不运行 git-update-server-info"

#: builtin/repack.c
msgid "pass --local to git-pack-objects"
msgstr "向 git-pack-objects 传递参数 --local"

#: builtin/repack.c
msgid "write bitmap index"
msgstr "写 bitmap 索引"

#: builtin/repack.c
msgid "pass --delta-islands to git-pack-objects"
msgstr "向 git-pack-objects 传递参数 --delta-islands"

#: builtin/repack.c
msgid "with -A, do not loosen objects older than this"
msgstr "使用 -A，不要将早于给定时间的对象过期"

#: builtin/repack.c
msgid "with -a, repack unreachable objects"
msgstr "使用 -a ，重新对不可达对象打包"

#: builtin/repack.c
msgid "size of the window used for delta compression"
msgstr "用于增量压缩的窗口值"

#: builtin/repack.c
msgid "bytes"
msgstr "字节"

#: builtin/repack.c
msgid "same as the above, but limit memory size instead of entries count"
msgstr "和上面的相似，但限制内存大小而非条目数"

#: builtin/repack.c
msgid "limits the maximum delta depth"
msgstr "限制最大增量深度"

#: builtin/repack.c
msgid "limits the maximum number of threads"
msgstr "限制最大线程数"

#: builtin/repack.c
msgid "maximum size of each packfile"
msgstr "每个包文件的最大尺寸"

#: builtin/repack.c
msgid "repack objects in packs marked with .keep"
msgstr "对标记为 .keep 的包中的对象重新打包"

#: builtin/repack.c
msgid "do not repack this pack"
msgstr "不要对该包文件重新打包"

#: builtin/repack.c
msgid "find a geometric progression with factor <N>"
msgstr "使用因子 <n> 查找几何级数"

#: builtin/repack.c
msgid "write a multi-pack index of the resulting packs"
msgstr "写入结果包的多包索引"

#: builtin/repack.c
msgid "pack prefix to store a pack containing filtered out objects"
msgstr "储存被过滤的对象的包的前缀"

#: builtin/repack.c
msgid "cannot delete packs in a precious-objects repo"
msgstr "不能删除珍品仓库中的打包文件"

#: builtin/repack.c
#, c-format
msgid "option '%s' can only be used along with '%s'"
msgstr "选项 '%s' 只能和 '%s' 搭配使用"

#: builtin/repack.c
msgid "Nothing new to pack."
msgstr "没有新的要打包。"

#: builtin/repack.c
#, c-format
msgid "renaming pack to '%s' failed"
msgstr "重命名包至 '%s' 失败"

#: builtin/repack.c
#, c-format
msgid "pack-objects did not write a '%s' file for pack %s-%s"
msgstr "pack-objects 未为包 %2$s-%3$s 写入 '%1$s' 文件"

#: builtin/repack.c sequencer.c
#, c-format
msgid "could not unlink: %s"
msgstr "不能删除：%s"

#: builtin/replace.c
msgid "git replace [-f] <object> <replacement>"
msgstr "git replace [-f] <对象> <替换物>"

#: builtin/replace.c
msgid "git replace [-f] --edit <object>"
msgstr "git replace [-f] --edit <对象>"

#: builtin/replace.c
msgid "git replace [-f] --graft <commit> [<parent>...]"
msgstr "git replace [-f] --graft <提交> [<父提交>...]"

#: builtin/replace.c
msgid "git replace -d <object>..."
msgstr "git replace -d <对象>..."

#: builtin/replace.c
msgid "git replace [--format=<format>] [-l [<pattern>]]"
msgstr "git replace [--format=<格式>] [-l [<模式>]]"

#: builtin/replace.c
#, c-format
msgid ""
"invalid replace format '%s'\n"
"valid formats are 'short', 'medium' and 'long'"
msgstr ""
"无效的替换格式 '%s'\n"
"有效的格式有 'short'、'medium' 和 'long'"

#: builtin/replace.c
#, c-format
msgid "replace ref '%s' not found"
msgstr "未发现替换引用 '%s'"

#: builtin/replace.c
#, c-format
msgid "Deleted replace ref '%s'"
msgstr "已删除替换引用 '%s'"

#: builtin/replace.c
#, c-format
msgid "'%s' is not a valid ref name"
msgstr "'%s' 不是一个有效的引用名"

#: builtin/replace.c
#, c-format
msgid "replace ref '%s' already exists"
msgstr "替换引用 '%s' 已经存在"

#: builtin/replace.c
#, c-format
msgid ""
"Objects must be of the same type.\n"
"'%s' points to a replaced object of type '%s'\n"
"while '%s' points to a replacement object of type '%s'."
msgstr ""
"对象必须属于同一类型。\n"
"'%s' 指向 '%s' 类型的替换对象\n"
"而 '%s' 指向 '%s' 类型的替换对象。"

#: builtin/replace.c
#, c-format
msgid "unable to open %s for writing"
msgstr "无法为写入打开 %s"

#: builtin/replace.c
msgid "cat-file reported failure"
msgstr "cat-file 报告失败"

#: builtin/replace.c
#, c-format
msgid "unable to open %s for reading"
msgstr "无法为读取打开 %s"

#: builtin/replace.c
msgid "unable to spawn mktree"
msgstr "无法启动 mktree"

#: builtin/replace.c
msgid "unable to read from mktree"
msgstr "无法从 mktree 读取"

#: builtin/replace.c
msgid "mktree reported failure"
msgstr "mktree 报告失败"

#: builtin/replace.c
msgid "mktree did not return an object name"
msgstr "mktree 没有返回一个对象名"

#: builtin/replace.c
#, c-format
msgid "unable to fstat %s"
msgstr "无法对 %s 执行 fstat"

#: builtin/replace.c
msgid "unable to write object to database"
msgstr "无法向数据库写入对象"

#: builtin/replace.c
#, c-format
msgid "unable to get object type for %s"
msgstr "无法得到 %s 的对象类型"

#: builtin/replace.c
msgid "editing object file failed"
msgstr "编辑对象文件失败"

#: builtin/replace.c
#, c-format
msgid "new object is the same as the old one: '%s'"
msgstr "新对象和旧对象相同：'%s'"

#: builtin/replace.c
#, c-format
msgid "could not parse %s as a commit"
msgstr "无法将 %s 解析为一个提交"

#: builtin/replace.c
#, c-format
msgid "bad mergetag in commit '%s'"
msgstr "提交 '%s' 中含有损坏的合并标签"

#: builtin/replace.c
#, c-format
msgid "malformed mergetag in commit '%s'"
msgstr "提交 '%s' 中含有格式错误的合并标签"

#: builtin/replace.c
#, c-format
msgid ""
"original commit '%s' contains mergetag '%s' that is discarded; use --edit "
"instead of --graft"
msgstr "原始提交 '%s' 包含已经丢弃的合并标签 '%s'，使用 --edit 代替 --graft"

#: builtin/replace.c
#, c-format
msgid "the original commit '%s' has a gpg signature"
msgstr "原始提交 '%s' 中有一个 gpg 签名"

#: builtin/replace.c
msgid "the signature will be removed in the replacement commit!"
msgstr "在替换的提交中签名将被移除！"

#: builtin/replace.c
#, c-format
msgid "could not write replacement commit for: '%s'"
msgstr "不能为 '%s' 写替换提交"

#: builtin/replace.c
#, c-format
msgid "graft for '%s' unnecessary"
msgstr "对 '%s' 移植没有必要"

#: builtin/replace.c
#, c-format
msgid "new commit is the same as the old one: '%s'"
msgstr "新提交和旧的一样：'%s'"

#: builtin/replace.c
#, c-format
msgid ""
"could not convert the following graft(s):\n"
"%s"
msgstr ""
"不能转换下列移植：\n"
"%s"

#: builtin/replace.c
msgid "list replace refs"
msgstr "列出替换的引用"

#: builtin/replace.c
msgid "delete replace refs"
msgstr "删除替换的引用"

#: builtin/replace.c
msgid "edit existing object"
msgstr "编辑现存的对象"

#: builtin/replace.c
msgid "change a commit's parents"
msgstr "修改一个提交的父提交"

#: builtin/replace.c
msgid "convert existing graft file"
msgstr "转换现存的移植文件"

#: builtin/replace.c
msgid "replace the ref if it exists"
msgstr "如果存在则替换引用"

#: builtin/replace.c
msgid "do not pretty-print contents for --edit"
msgstr "不要为 --edit 操作美观显示内容"

#: builtin/replace.c
msgid "use this format"
msgstr "使用此格式"

#: builtin/replace.c
msgid "--format cannot be used when not listing"
msgstr "不列出时不能使用 --format"

#: builtin/replace.c
msgid "-f only makes sense when writing a replacement"
msgstr "只有写一个替换时 -f 才有意义"

#: builtin/replace.c
msgid "--raw only makes sense with --edit"
msgstr "--raw 只有和 --edit 共用才有意义"

#: builtin/replace.c
msgid "-d needs at least one argument"
msgstr "-d 需要至少一个参数"

#: builtin/replace.c
msgid "bad number of arguments"
msgstr "错误的参数个数"

#: builtin/replace.c
msgid "-e needs exactly one argument"
msgstr "-e 需要且仅需要一个参数"

#: builtin/replace.c
msgid "-g needs at least one argument"
msgstr "-g 需要至少一个参数"

#: builtin/replace.c
msgid "--convert-graft-file takes no argument"
msgstr "--convert-graft-file 不带参数"

#: builtin/replace.c
msgid "only one pattern can be given with -l"
msgstr "只能为 -l 提供一个模式"

#: builtin/replay.c
msgid "need some commits to replay"
msgstr "需要一些提交来重放"

#: builtin/replay.c
msgid "all positive revisions given must be references"
msgstr "提供的所有正向版本必须为引用"

#: builtin/replay.c
msgid "argument to --advance must be a reference"
msgstr "--advance 的参数必须是引用"

#: builtin/replay.c
msgid ""
"cannot advance target with multiple sources because ordering would be ill-"
"defined"
msgstr "不能使用多个源推进目标，因为无法明确如何排序"

#: builtin/replay.c
msgid ""
"cannot implicitly determine whether this is an --advance or --onto operation"
msgstr "不能隐式地确定这是 --advance 还是 --onto 的操作"

#: builtin/replay.c
msgid ""
"cannot advance target with multiple source branches because ordering would "
"be ill-defined"
msgstr "不能使用多个源分支推进目标，因为无法明确如何排序"

#: builtin/replay.c
msgid "cannot implicitly determine correct base for --onto"
msgstr "不能隐式地确定 --onto 正确的基线"

#: builtin/replay.c
msgid ""
"(EXPERIMENTAL!) git replay ([--contained] --onto <newbase> | --advance "
"<branch>) <revision-range>..."
msgstr ""
"（试验中！）git replay ([--contained] --onto <新基线> | --advance <分支>) <版"
"本范围>..."

#: builtin/replay.c
msgid "make replay advance given branch"
msgstr "重放时演进给定的分支"

#: builtin/replay.c
msgid "replay onto given commit"
msgstr "重放到给定提交"

#: builtin/replay.c
msgid "advance all branches contained in revision-range"
msgstr "演进版本范围中包含的所有分支"

#: builtin/replay.c
msgid "option --onto or --advance is mandatory"
msgstr "选项 --onto 或 --advance 必须指定其一"

#: builtin/replay.c
#, c-format
msgid ""
"some rev walking options will be overridden as '%s' bit in 'struct rev_info' "
"will be forced"
msgstr ""
"一些版本遍历选项将被覆盖，如 'struct rev_info' 中的 '%s' 位将被强制设定"

#: builtin/replay.c
msgid "error preparing revisions"
msgstr "准备版本时错误"

#: builtin/replay.c
msgid "replaying down to root commit is not supported yet!"
msgstr "目前还不支持重放到根提交！"

#: builtin/replay.c
msgid "replaying merge commits is not supported yet!"
msgstr "目前还不支持重放到合并提交！"

#: builtin/rerere.c
msgid ""
"git rerere [clear | forget <pathspec>... | diff | status | remaining | gc]"
msgstr ""
"git rerere [clear | forget <路径规格>... | diff | status | remaining | gc]"

#: builtin/rerere.c
msgid "register clean resolutions in index"
msgstr "在索引中注册干净的解决方案"

#: builtin/rerere.c
msgid "'git rerere forget' without paths is deprecated"
msgstr "没有路径的 'git rerere forget' 已经过时"

#: builtin/rerere.c
#, c-format
msgid "unable to generate diff for '%s'"
msgstr "无法为 '%s' 生成差异"

#: builtin/reset.c
msgid ""
"git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [<commit>]"
msgstr "git reset [--mixed | --soft | --hard | --merge | --keep] [-q] [<提交>]"

#: builtin/reset.c
msgid "git reset [-q] [<tree-ish>] [--] <pathspec>..."
msgstr "git reset [-q] [<树对象>] [--] <路径表达式>..."

#: builtin/reset.c
msgid ""
"git reset [-q] [--pathspec-from-file [--pathspec-file-nul]] [<tree-ish>]"
msgstr "git reset [-q] [--pathspec-from-file [--pathspec-file-nul]] [<树对象>]"

#: builtin/reset.c
msgid "git reset --patch [<tree-ish>] [--] [<pathspec>...]"
msgstr "git reset --patch [<树对象>] [--] [<路径表达式>...]"

#: builtin/reset.c
msgid "mixed"
msgstr "混杂"

#: builtin/reset.c
msgid "soft"
msgstr "软性"

#: builtin/reset.c
msgid "hard"
msgstr "硬性"

#: builtin/reset.c
msgid "merge"
msgstr "合并"

#: builtin/reset.c
msgid "keep"
msgstr "保持"

#: builtin/reset.c
msgid "You do not have a valid HEAD."
msgstr "您没有一个有效的 HEAD。"

#: builtin/reset.c
msgid "Failed to find tree of HEAD."
msgstr "无法找到 HEAD 指向的树。"

#: builtin/reset.c
#, c-format
msgid "Failed to find tree of %s."
msgstr "无法找到 %s 指向的树。"

#: builtin/reset.c
#, c-format
msgid "HEAD is now at %s"
msgstr "HEAD 现在位于 %s"

#  译者：汉字之间无空格，故删除%s前后空格
#: builtin/reset.c
#, c-format
msgid "Cannot do a %s reset in the middle of a merge."
msgstr "在合并过程中不能做%s重置操作。"

#: builtin/reset.c builtin/stash.c
msgid "be quiet, only report errors"
msgstr "安静模式，只报告错误"

#: builtin/reset.c
msgid "skip refreshing the index after reset"
msgstr "重置后跳过刷新索引"

#: builtin/reset.c
msgid "reset HEAD and index"
msgstr "重置 HEAD 和索引"

#: builtin/reset.c
msgid "reset only HEAD"
msgstr "只重置 HEAD"

#: builtin/reset.c
msgid "reset HEAD, index and working tree"
msgstr "重置 HEAD、索引和工作区"

#: builtin/reset.c
msgid "reset HEAD but keep local changes"
msgstr "重置 HEAD 但保存本地变更"

#: builtin/reset.c
msgid "record only the fact that removed paths will be added later"
msgstr "将删除的路径标记为稍后添加"

#: builtin/reset.c
#, c-format
msgid "Failed to resolve '%s' as a valid revision."
msgstr "无法将 '%s' 解析为一个有效的版本。"

#: builtin/reset.c
#, c-format
msgid "Failed to resolve '%s' as a valid tree."
msgstr "无法将 '%s' 解析为一个有效的树对象。"

#: builtin/reset.c
msgid "--mixed with paths is deprecated; use 'git reset -- <paths>' instead."
msgstr "--mixed 带路径已弃用，而是用 'git reset -- <路径>'。"

#  译者：汉字之间无空格，故删除%s前后空格
#: builtin/reset.c
#, c-format
msgid "Cannot do %s reset with paths."
msgstr "不能带路径进行%s重置。"

#  译者：汉字之间无空格，故删除%s前后空格
#: builtin/reset.c
#, c-format
msgid "%s reset is not allowed in a bare repository"
msgstr "不能对纯仓库进行%s重置"

#: builtin/reset.c
msgid "Unstaged changes after reset:"
msgstr "重置后取消暂存的变更："

#: builtin/reset.c
#, c-format
msgid ""
"It took %.2f seconds to refresh the index after reset.  You can use\n"
"'--no-refresh' to avoid this."
msgstr "在重置后花了 %.2f 秒来刷新索引。使用 '--no-refresh' 以避免之。"

#: builtin/reset.c
#, c-format
msgid "Could not reset index file to revision '%s'."
msgstr "不能重置索引文件至版本 '%s'。"

#: builtin/reset.c
msgid "Could not write new index file."
msgstr "不能写入新的索引文件。"

#: builtin/rev-list.c
#, c-format
msgid "unable to get disk usage of %s"
msgstr "无法得到 %s 的磁盘使用量"

#: builtin/rev-list.c
#, c-format
msgid "invalid value for '%s': '%s', the only allowed format is '%s'"
msgstr "'%s' 的值无效：'%s'，唯一允许的格式是 '%s'"

#: builtin/rev-list.c
msgid "rev-list does not support display of notes"
msgstr "rev-list 不支持显示注解"

#: builtin/rev-list.c
#, c-format
msgid "marked counting and '%s' cannot be used together"
msgstr "标记计数和 '%s' 不能同时使用"

#: builtin/rev-parse.c
msgid "git rev-parse --parseopt [<options>] -- [<args>...]"
msgstr "git rev-parse --parseopt [<选项>] -- [<参数>...]"

#: builtin/rev-parse.c
msgid "keep the `--` passed as an arg"
msgstr "保持 `--` 作为一个参数传递"

#: builtin/rev-parse.c
msgid "stop parsing after the first non-option argument"
msgstr "遇到第一个非选项参数后停止解析"

#: builtin/rev-parse.c
msgid "output in stuck long form"
msgstr "以固定长格式输出"

#: builtin/rev-parse.c
msgid "premature end of input"
msgstr "输入过早结束"

#: builtin/rev-parse.c
msgid "no usage string given before the `--' separator"
msgstr "在 `--' 分隔符之前没有给出使用方法字符串"

#: builtin/rev-parse.c
msgid "missing opt-spec before option flags"
msgstr "选项参数之前缺少选项规格"

#: builtin/rev-parse.c
msgid "Needed a single revision"
msgstr "需要一个单独的版本"

#: builtin/rev-parse.c
msgid ""
"git rev-parse --parseopt [<options>] -- [<args>...]\n"
"   or: git rev-parse --sq-quote [<arg>...]\n"
"   or: git rev-parse [<options>] [<arg>...]\n"
"\n"
"Run \"git rev-parse --parseopt -h\" for more information on the first usage."
msgstr ""
"git rev-parse --parseopt [<选项>] -- [<参数>...]\n"
"   或者：git rev-parse --sq-quote [<参数>...]\n"
"   或者：git rev-parse [<选项>] [<参数>...]\n"
"\n"
"初次使用时执行 \"git rev-parse --parseopt -h\" 来获得更多信息。"

#: builtin/rev-parse.c
msgid "--resolve-git-dir requires an argument"
msgstr "--resolve-git-dir 需要一个参数"

#: builtin/rev-parse.c
#, c-format
msgid "not a gitdir '%s'"
msgstr "不是一个git目录 '%s'"

#: builtin/rev-parse.c
msgid "--git-path requires an argument"
msgstr "--git-path 需要一个参数"

#: builtin/rev-parse.c
msgid "-n requires an argument"
msgstr "-n 需要一个参数"

#: builtin/rev-parse.c
msgid "--path-format requires an argument"
msgstr "--path-format 需要一个参数"

#: builtin/rev-parse.c
#, c-format
msgid "unknown argument to --path-format: %s"
msgstr "未知的 --path-format 参数：%s"

#: builtin/rev-parse.c
msgid "--default requires an argument"
msgstr "--default 需要一个参数"

#: builtin/rev-parse.c
msgid "--prefix requires an argument"
msgstr "--prefix 需要一个参数"

#: builtin/rev-parse.c
msgid "no object format specified"
msgstr "未指定对象格式"

#: builtin/rev-parse.c
#, c-format
msgid "unsupported object format: %s"
msgstr "不支持的对象格式：'%s'"

#: builtin/rev-parse.c
#, c-format
msgid "unknown mode for --abbrev-ref: %s"
msgstr "未知的 --abbrev-ref 模式：%s"

#: builtin/rev-parse.c setup.c
msgid "this operation must be run in a work tree"
msgstr "该操作必须在一个工作区中运行"

#: builtin/rev-parse.c
msgid "Could not read the index"
msgstr "不能读取索引"

#: builtin/rev-parse.c
#, c-format
msgid "unknown mode for --show-object-format: %s"
msgstr "未知的 --show-object-format 模式：%s"

#: builtin/revert.c
msgid ""
"git revert [--[no-]edit] [-n] [-m <parent-number>] [-s] [-S[<keyid>]] "
"<commit>..."
msgstr ""
"git revert [--[no-]edit] [-n] [-m <父编号>] [-s] [-S[<私钥 ID>]] <提交>..."

#: builtin/revert.c
msgid "git revert (--continue | --skip | --abort | --quit)"
msgstr "git revert (--continue | --skip | --abort | --quit)"

#: builtin/revert.c
msgid ""
"git cherry-pick [--edit] [-n] [-m <parent-number>] [-s] [-x] [--ff]\n"
"                [-S[<keyid>]] <commit>..."
msgstr ""
"git cherry-pick [--edit] [-n] [-m <父编号>] [-s] [-x] [--ff]\n"
"                [-S[<私钥 ID>]] <提交>..."

#: builtin/revert.c
msgid "git cherry-pick (--continue | --skip | --abort | --quit)"
msgstr "git cherry-pick (--continue | --skip | --abort | --quit)"

#: builtin/revert.c
#, c-format
msgid "option `%s' expects a number greater than zero"
msgstr "选项 `%s' 期望一个大于零的数字"

#: builtin/revert.c
#, c-format
msgid "%s: %s cannot be used with %s"
msgstr "%s：%s 不能和 %s 同时使用"

#: builtin/revert.c
msgid "end revert or cherry-pick sequence"
msgstr "终止反转或拣选操作"

#: builtin/revert.c
msgid "resume revert or cherry-pick sequence"
msgstr "继续反转或拣选操作"

#: builtin/revert.c
msgid "cancel revert or cherry-pick sequence"
msgstr "取消反转或拣选操作"

#: builtin/revert.c
msgid "skip current commit and continue"
msgstr "跳过当前提交并继续"

#: builtin/revert.c
msgid "don't automatically commit"
msgstr "不要自动提交"

#: builtin/revert.c
msgid "edit the commit message"
msgstr "编辑提交说明"

#: builtin/revert.c
msgid "parent-number"
msgstr "父编号"

#: builtin/revert.c
msgid "select mainline parent"
msgstr "选择主干父提交编号"

#: builtin/revert.c
msgid "merge strategy"
msgstr "合并策略"

#: builtin/revert.c
msgid "option for merge strategy"
msgstr "合并策略的选项"

#: builtin/revert.c
msgid "append commit name"
msgstr "追加提交名称"

#: builtin/revert.c
msgid "preserve initially empty commits"
msgstr "保留初始化的空提交"

#: builtin/revert.c
msgid "allow commits with empty messages"
msgstr "允许提交说明为空"

#: builtin/revert.c
msgid "deprecated: use --empty=keep instead"
msgstr "已弃用：取而代之使用 --empty=keep"

#: builtin/revert.c
msgid "use the 'reference' format to refer to commits"
msgstr "使用 'reference' 格式来指向提交"

#: builtin/revert.c
msgid "revert failed"
msgstr "还原失败"

#: builtin/revert.c
msgid "cherry-pick failed"
msgstr "拣选失败"

#: builtin/rm.c
msgid ""
"git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]\n"
"       [--quiet] [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"       [--] [<pathspec>...]"
msgstr ""
"git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch]\n"
"       [--quiet] [--pathspec-from-file=<文件> [--pathspec-file-nul]]\n"
"       [--] [<路径规格>...]"

#: builtin/rm.c
msgid ""
"the following file has staged content different from both the\n"
"file and the HEAD:"
msgid_plural ""
"the following files have staged content different from both the\n"
"file and the HEAD:"
msgstr[0] "如下文件其暂存的内容和工作区及 HEAD 中的都不一样："
msgstr[1] "如下文件其暂存的内容和工作区及 HEAD 中的都不一样："

#: builtin/rm.c
msgid ""
"\n"
"(use -f to force removal)"
msgstr ""
"\n"
"（使用 -f 强制删除）"

#: builtin/rm.c
msgid "the following file has changes staged in the index:"
msgid_plural "the following files have changes staged in the index:"
msgstr[0] "下列文件索引中有变更"
msgstr[1] "下列文件索引中有变更"

#: builtin/rm.c
msgid ""
"\n"
"(use --cached to keep the file, or -f to force removal)"
msgstr ""
"\n"
"（使用 --cached 保留本地文件，或用 -f 强制删除）"

#: builtin/rm.c
msgid "the following file has local modifications:"
msgid_plural "the following files have local modifications:"
msgstr[0] "如下文件有本地修改："
msgstr[1] "如下文件有本地修改："

#: builtin/rm.c
msgid "do not list removed files"
msgstr "不列出删除的文件"

#: builtin/rm.c
msgid "only remove from the index"
msgstr "只从索引区删除"

#: builtin/rm.c
msgid "override the up-to-date check"
msgstr "忽略文件更新状态检查"

#: builtin/rm.c
msgid "allow recursive removal"
msgstr "允许递归删除"

#: builtin/rm.c
msgid "exit with a zero status even if nothing matched"
msgstr "即使没有匹配，也以零状态退出"

#: builtin/rm.c
msgid "No pathspec was given. Which files should I remove?"
msgstr "没有提供路径规格。我应该删除哪些文件？"

#: builtin/rm.c
msgid "please stage your changes to .gitmodules or stash them to proceed"
msgstr "请将您的修改暂存到 .gitmodules 中或贮藏后再继续"

#: builtin/rm.c
#, c-format
msgid "not removing '%s' recursively without -r"
msgstr "未提供 -r 选项不会递归删除 '%s'"

#: builtin/rm.c
#, c-format
msgid "git rm: unable to remove %s"
msgstr "git rm：不能删除 %s"

#: builtin/send-pack.c
msgid ""
"git send-pack [--mirror] [--dry-run] [--force]\n"
"              [--receive-pack=<git-receive-pack>]\n"
"              [--verbose] [--thin] [--atomic]\n"
"              [--[no-]signed | --signed=(true|false|if-asked)]\n"
"              [<host>:]<directory> (--all | <ref>...)"
msgstr ""
"git send-pack [--mirror] [--dry-run] [--force]\n"
"              [--receive-pack=<git-receive-pack>]\n"
"              [--verbose] [--thin] [--atomic]\n"
"              [--[no-]signed | --signed=(true|false|if-asked)]\n"
"              [<主机>:]<目录> (--all | <引用>...)"

#: builtin/send-pack.c
msgid "remote name"
msgstr "远程名称"

#: builtin/send-pack.c
msgid "push all refs"
msgstr "推送所有引用"

#: builtin/send-pack.c
msgid "use stateless RPC protocol"
msgstr "使用无状态的 RPC 协议"

#: builtin/send-pack.c
msgid "read refs from stdin"
msgstr "从标准输入读取引用"

#: builtin/send-pack.c
msgid "print status from remote helper"
msgstr "打印来自远程 helper 的状态"

#: builtin/shortlog.c
msgid "git shortlog [<options>] [<revision-range>] [[--] <path>...]"
msgstr "git shortlog [<选项>] [<版本范围>] [[--] <路径>...]"

#: builtin/shortlog.c
msgid "git log --pretty=short | git shortlog [<options>]"
msgstr "git log --pretty=short | git shortlog [<选项>]"

#: builtin/shortlog.c
msgid "using multiple --group options with stdin is not supported"
msgstr "不支持和标准输入一起使用多个 --group 选项"

#: builtin/shortlog.c
#, c-format
msgid "using %s with stdin is not supported"
msgstr "不支持对 %s 使用标准输入"

#: builtin/shortlog.c
#, c-format
msgid "unknown group type: %s"
msgstr "未知分组类型：%s"

#: builtin/shortlog.c
msgid "group by committer rather than author"
msgstr "按照提交者而不是作者分组"

#: builtin/shortlog.c
msgid "sort output according to the number of commits per author"
msgstr "根据每个作者的提交数量排序"

#: builtin/shortlog.c
msgid "suppress commit descriptions, only provides commit count"
msgstr "抑制提交描述，只提供提交数量"

#: builtin/shortlog.c
msgid "show the email address of each author"
msgstr "显示每个作者的电子邮件地址"

#: builtin/shortlog.c
msgid "<w>[,<i1>[,<i2>]]"
msgstr "<w>[,<i1>[,<i2>]]"

#: builtin/shortlog.c
msgid "linewrap output"
msgstr "折行输出"

#: builtin/shortlog.c
msgid "field"
msgstr "字段"

#: builtin/shortlog.c
msgid "group by field"
msgstr "按字段分组"

#: builtin/shortlog.c
msgid "too many arguments given outside repository"
msgstr "仓库外执行提供了太多的参数"

#: builtin/show-branch.c
msgid ""
"git show-branch [-a | --all] [-r | --remotes] [--topo-order | --date-order]\n"
"                [--current] [--color[=<when>] | --no-color] [--sparse]\n"
"                [--more=<n> | --list | --independent | --merge-base]\n"
"                [--no-name | --sha1-name] [--topics]\n"
"                [(<rev> | <glob>)...]"
msgstr ""
"git show-branch [-a | --all] [-r | --remotes] [--topo-order | --date-order]\n"
"                [--current] [--color[=<何时>] | --no-color] [--sparse]\n"
"                [--more=<n> | --list | --independent | --merge-base]\n"
"                [--no-name | --sha1-name] [--topics]\n"
"                [(<版本> | <通配符>)...]"

#: builtin/show-branch.c
msgid "git show-branch (-g | --reflog)[=<n>[,<base>]] [--list] [<ref>]"
msgstr "git show-branch (-g | --reflog)[=<n>[,<起始点>]] [--list] [<引用>]"

#: builtin/show-branch.c
#, c-format
msgid "ignoring %s; cannot handle more than %d ref"
msgid_plural "ignoring %s; cannot handle more than %d refs"
msgstr[0] "忽略 %s，无法处理 %d 个以上的引用"
msgstr[1] "忽略 %s，无法处理 %d 个以上的引用"

#: builtin/show-branch.c
#, c-format
msgid "no matching refs with %s"
msgstr "没有和 %s 匹配的引用"

#: builtin/show-branch.c
msgid "show remote-tracking and local branches"
msgstr "显示远程跟踪的和本地的分支"

#: builtin/show-branch.c
msgid "show remote-tracking branches"
msgstr "显示远程跟踪的分支"

#: builtin/show-branch.c
msgid "color '*!+-' corresponding to the branch"
msgstr "着色 '*!+-' 到相应的分支"

#: builtin/show-branch.c
msgid "show <n> more commits after the common ancestor"
msgstr "显示共同祖先后的 <n> 个提交"

#: builtin/show-branch.c
msgid "synonym to more=-1"
msgstr "和 more=-1 同义"

#: builtin/show-branch.c
msgid "suppress naming strings"
msgstr "不显示字符串命名"

#: builtin/show-branch.c
msgid "include the current branch"
msgstr "包括当前分支"

#: builtin/show-branch.c
msgid "name commits with their object names"
msgstr "以对象名字命名提交"

#: builtin/show-branch.c
msgid "show possible merge bases"
msgstr "显示可能合并的基线"

#: builtin/show-branch.c
msgid "show refs unreachable from any other ref"
msgstr "显示没有任何引用的的引用"

#: builtin/show-branch.c
msgid "show commits in topological order"
msgstr "以拓扑顺序显示提交"

#: builtin/show-branch.c
msgid "show only commits not on the first branch"
msgstr "只显示不在第一个分支上的提交"

#: builtin/show-branch.c
msgid "show merges reachable from only one tip"
msgstr "显示仅一个分支可访问的合并提交"

#: builtin/show-branch.c
msgid "topologically sort, maintaining date order where possible"
msgstr "拓扑方式排序，并尽可能地保持日期顺序"

#: builtin/show-branch.c
msgid "<n>[,<base>]"
msgstr "<n>[,<base>]"

#: builtin/show-branch.c
msgid "show <n> most recent ref-log entries starting at base"
msgstr "显示从起始点开始的 <n> 条最近的引用日志记录"

#: builtin/show-branch.c
msgid "no branches given, and HEAD is not valid"
msgstr "未提供分支，且 HEAD 无效"

#: builtin/show-branch.c
msgid "--reflog option needs one branch name"
msgstr "选项 --reflog 需要一个分支名"

#: builtin/show-branch.c
#, c-format
msgid "only %d entry can be shown at one time."
msgid_plural "only %d entries can be shown at one time."
msgstr[0] "一次只能显示 %d 个条目。"
msgstr[1] "一次只能显示 %d 个条目。"

#: builtin/show-branch.c
#, c-format
msgid "no such ref %s"
msgstr "无此引用 %s"

#: builtin/show-branch.c
#, c-format
msgid "cannot handle more than %d rev."
msgid_plural "cannot handle more than %d revs."
msgstr[0] "不能处理 %d 个以上的版本。"
msgstr[1] "不能处理 %d 个以上的版本。"

#: builtin/show-branch.c
#, c-format
msgid "'%s' is not a valid ref."
msgstr "'%s' 不是一个有效的引用。"

#: builtin/show-branch.c
#, c-format
msgid "cannot find commit %s (%s)"
msgstr "不能找到提交 %s（%s）"

#: builtin/show-index.c
msgid "hash-algorithm"
msgstr "哈希算法"

#: builtin/show-index.c
msgid "Unknown hash algorithm"
msgstr "未知的哈希算法"

#: builtin/show-ref.c
msgid ""
"git show-ref [--head] [-d | --dereference]\n"
"             [-s | --hash[=<n>]] [--abbrev[=<n>]] [--branches] [--tags]\n"
"             [--] [<pattern>...]"
msgstr ""
"git show-ref [--head] [-d | --dereference]\n"
"             [-s | --hash[=<n>]] [--abbrev[=<n>]] [--branches] [--tags]\n"
"             [--] [<模式>...]"

#: builtin/show-ref.c
msgid ""
"git show-ref --verify [-q | --quiet] [-d | --dereference]\n"
"             [-s | --hash[=<n>]] [--abbrev[=<n>]]\n"
"             [--] [<ref>...]"
msgstr ""
"git show-ref --verify [-q | --quiet] [-d | --dereference]\n"
"             [-s | --hash[=<n>]] [--abbrev[=<n>]]\n"
"             [--] [<引用>...]"

#: builtin/show-ref.c
msgid "git show-ref --exclude-existing[=<pattern>]"
msgstr "git show-ref --exclude-existing[=<模式>]"

#: builtin/show-ref.c
msgid "git show-ref --exists <ref>"
msgstr "git show-ref --exists <引用>"

#: builtin/show-ref.c
msgid "reference does not exist"
msgstr "引用不存在"

#: builtin/show-ref.c
msgid "failed to look up reference"
msgstr "无法找到引用"

#: builtin/show-ref.c
msgid "only show tags (can be combined with --branches)"
msgstr "仅显示标签（可与 --branches 组合使用）"

#: builtin/show-ref.c
msgid "only show branches (can be combined with --tags)"
msgstr "仅显示分支（可与 --tags 组合使用）"

#: builtin/show-ref.c
msgid "check for reference existence without resolving"
msgstr "检查引用是否存在但不解析"

#: builtin/show-ref.c
msgid "stricter reference checking, requires exact ref path"
msgstr "更严格的引用检测，需要精确的引用路径"

#: builtin/show-ref.c
msgid "show the HEAD reference, even if it would be filtered out"
msgstr "显示 HEAD 引用，即使被过滤掉"

#: builtin/show-ref.c
msgid "dereference tags into object IDs"
msgstr "转换标签到对象 ID"

#: builtin/show-ref.c
msgid "only show SHA1 hash using <n> digits"
msgstr "只显示使用 <n> 个数字的 SHA1 哈希"

#: builtin/show-ref.c
msgid "do not print results to stdout (useful with --verify)"
msgstr "不打印结果到标准输出（例如与 --verify 参数共用）"

#: builtin/show-ref.c
msgid "show refs from stdin that aren't in local repository"
msgstr "显示从标准输入中读入的不在本地仓库中的引用"

#: builtin/sparse-checkout.c
msgid ""
"git sparse-checkout (init | list | set | add | reapply | disable | check-"
"rules) [<options>]"
msgstr ""
"git sparse-checkout (init | list | set | add | reapply | disable | check\n"
"-rules) [<选项>]"

#: builtin/sparse-checkout.c
msgid "this worktree is not sparse"
msgstr "这个工作区不是稀疏的"

#: builtin/sparse-checkout.c
msgid "this worktree is not sparse (sparse-checkout file may not exist)"
msgstr "本工作区不是稀疏模式（稀疏检出文件可能不存在）"

#: builtin/sparse-checkout.c
#, c-format
msgid ""
"directory '%s' contains untracked files, but is not in the sparse-checkout "
"cone"
msgstr "目录 '%s' 包括了未跟踪文件，但不在稀疏检出锥中"

#: builtin/sparse-checkout.c
#, c-format
msgid "failed to remove directory '%s'"
msgstr "无法删除目录 '%s'"

#: builtin/sparse-checkout.c
msgid "failed to create directory for sparse-checkout file"
msgstr "无法为稀疏检出文件创建目录"

#: builtin/sparse-checkout.c
#, c-format
msgid "unable to fdopen %s"
msgstr "不能 fdopen %s"

#: builtin/sparse-checkout.c
msgid "failed to initialize worktree config"
msgstr "无法初始化工作树配置"

#: builtin/sparse-checkout.c
msgid "failed to modify sparse-index config"
msgstr "无法修改 sparse-index 配置"

#: builtin/sparse-checkout.c
msgid "initialize the sparse-checkout in cone mode"
msgstr "初始化稀疏检出为锥形模式"

#: builtin/sparse-checkout.c
msgid "toggle the use of a sparse index"
msgstr "切换稀疏索引的使用"

#: builtin/sparse-checkout.c commit-graph.c midx-write.c sequencer.c
#, c-format
msgid "unable to create leading directories of %s"
msgstr "不能为 %s 创建先导目录"

#: builtin/sparse-checkout.c
#, c-format
msgid "failed to open '%s'"
msgstr "无法打开 '%s'"

#: builtin/sparse-checkout.c
#, c-format
msgid "could not normalize path %s"
msgstr "无法规范化路径 %s"

#: builtin/sparse-checkout.c
#, c-format
msgid "unable to unquote C-style string '%s'"
msgstr "无法为 C 语言风格的字符串 '%s' 去引号"

#: builtin/sparse-checkout.c
msgid "unable to load existing sparse-checkout patterns"
msgstr "无法加载现存的稀疏检出模式"

#: builtin/sparse-checkout.c
msgid "existing sparse-checkout patterns do not use cone mode"
msgstr "已有的稀疏检出模式不使用锥形模式"

#: builtin/sparse-checkout.c
msgid "please run from the toplevel directory in non-cone mode"
msgstr "请在非锥形模式的顶级目录中运行"

#: builtin/sparse-checkout.c
msgid "specify directories rather than patterns (no leading slash)"
msgstr "指定目录而不是模式（无前导斜线）"

#: builtin/sparse-checkout.c
msgid ""
"specify directories rather than patterns.  If your directory starts with a "
"'!', pass --skip-checks"
msgstr "指定目录而不是模式。若你的目录以 '!' 开头，传入 --skip-checks"

#: builtin/sparse-checkout.c
msgid ""
"specify directories rather than patterns.  If your directory really has any "
"of '*?[]\\' in it, pass --skip-checks"
msgstr ""
"指定目录而不是模式。若你的目录真的包含 '*?[]\\' 中的字符，传入 --skip-checks"

#: builtin/sparse-checkout.c
#, c-format
msgid ""
"'%s' is not a directory; to treat it as a directory anyway, rerun with --"
"skip-checks"
msgstr "'%s' 不是目录；若无论如何都要将它当作目录，使用 --skip-checks 重新运行"

#: builtin/sparse-checkout.c
#, c-format
msgid ""
"pass a leading slash before paths such as '%s' if you want a single file "
"(see NON-CONE PROBLEMS in the git-sparse-checkout manual)."
msgstr ""
"如果您想要单独一个文件，在类似于 '%s' 的路径前传入前置斜线 （参见 git-sparse-"
"checkout 手册中的 NON-CONE PROBLEMS）。"

#: builtin/sparse-checkout.c
msgid "git sparse-checkout add [--skip-checks] (--stdin | <patterns>)"
msgstr "git sparse-checkout add [--skip-checks] (--stdin | <模式>)"

#: builtin/sparse-checkout.c
msgid ""
"skip some sanity checks on the given paths that might give false positives"
msgstr "跳过可能对一些目录产生假阳性错误的合理性检查"

#: builtin/sparse-checkout.c
msgid "read patterns from standard in"
msgstr "从标准输入读取模式"

#: builtin/sparse-checkout.c
msgid "no sparse-checkout to add to"
msgstr "没有可以添加到的稀疏检出"

#: builtin/sparse-checkout.c
msgid ""
"git sparse-checkout set [--[no-]cone] [--[no-]sparse-index] [--skip-checks] "
"(--stdin | <patterns>)"
msgstr ""
"git sparse-checkout set [--[no-]cone] [--[no-]sparse-index] [--skip-checks] "
"(--stdin | <模式>)"

#: builtin/sparse-checkout.c
msgid "must be in a sparse-checkout to reapply sparsity patterns"
msgstr "必须在稀疏检出中重应用稀疏模式"

#: builtin/sparse-checkout.c
msgid "error while refreshing working directory"
msgstr "刷新工作目录时出错"

#: builtin/sparse-checkout.c
msgid ""
"git sparse-checkout check-rules [-z] [--skip-checks][--[no-]cone] [--rules-"
"file <file>]"
msgstr ""
"git sparse-checkout check-rules [-z] [--skip-checks][--[no-]cone] [--rules-"
"file <文件>]"

#: builtin/sparse-checkout.c
msgid "terminate input and output files by a NUL character"
msgstr "输入和输出的文件使用 NUL 字符终结"

#: builtin/sparse-checkout.c
msgid "when used with --rules-file interpret patterns as cone mode patterns"
msgstr "通过 --rules-file 选项传递的模型将被作为锥形（稀疏检出模型）进行解析"

#: builtin/sparse-checkout.c
msgid "use patterns in <file> instead of the current ones."
msgstr "从 <文件> 参数中读取模式，而不是从标准输入"

#: builtin/stash.c
msgid "git stash list [<log-options>]"
msgstr "git stash list [<日志选项>]"

#: builtin/stash.c
msgid ""
"git stash show [-u | --include-untracked | --only-untracked] [<diff-"
"options>] [<stash>]"
msgstr ""
"git stash show [-u | --include-untracked | --only-untracked] [<差异选项>] [<"
"贮存>]"

#: builtin/stash.c
msgid "git stash drop [-q | --quiet] [<stash>]"
msgstr "git stash drop [-q | --quiet] [<贮存>]"

#: builtin/stash.c
msgid "git stash pop [--index] [-q | --quiet] [<stash>]"
msgstr "git stash pop [--index] [-q | --quiet] [<贮存>]"

#: builtin/stash.c
msgid "git stash apply [--index] [-q | --quiet] [<stash>]"
msgstr "git stash apply [--index] [-q | --quiet] [<贮存>]"

#: builtin/stash.c
msgid "git stash branch <branchname> [<stash>]"
msgstr "git stash branch <分支名> [<stash>]"

#: builtin/stash.c
msgid "git stash store [(-m | --message) <message>] [-q | --quiet] <commit>"
msgstr "git stash store [(-m | --message) <消息>] [-q | --quiet] <提交>"

#: builtin/stash.c
msgid ""
"git stash [push [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q "
"| --quiet]\n"
"          [-u | --include-untracked] [-a | --all] [(-m | --message) "
"<message>]\n"
"          [--pathspec-from-file=<file> [--pathspec-file-nul]]\n"
"          [--] [<pathspec>...]]"
msgstr ""
"git stash [push [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q "
"| --quiet]\n"
"          [-u | --include-untracked] [-a | --all] [(-m | --message <消息>]\n"
"          [--pathspec-from-file=<文件> [--pathspec-file-nul]]\n"
"          [--] [<路径规格>...]]"

#: builtin/stash.c
msgid ""
"git stash save [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | "
"--quiet]\n"
"          [-u | --include-untracked] [-a | --all] [<message>]"
msgstr ""
"git stash save [-p | --patch] [-S | --staged] [-k | --[no-]keep-index] [-q | "
"--quiet]\n"
"          [-u | --include-untracked] [-a | --all] [<消息>]"

#: builtin/stash.c
msgid "git stash create [<message>]"
msgstr "git stash create [<消息>]"

#: builtin/stash.c
#, c-format
msgid "'%s' is not a stash-like commit"
msgstr "'%s' 不像是一个贮藏提交"

#: builtin/stash.c
#, c-format
msgid "Too many revisions specified:%s"
msgstr "指定了太多的版本：%s"

#: builtin/stash.c
msgid "No stash entries found."
msgstr "未发现贮藏条目。"

#: builtin/stash.c
#, c-format
msgid "%s is not a valid reference"
msgstr "%s 不是一个有效的引用名"

#: builtin/stash.c
msgid "git stash clear with arguments is unimplemented"
msgstr "git stash clear 不支持参数"

#: builtin/stash.c
#, c-format
msgid ""
"WARNING: Untracked file in way of tracked file!  Renaming\n"
"            %s -> %s\n"
"         to make room.\n"
msgstr ""
"警告：未跟踪文件出现在跟踪文件的路径上！重命名\n"
"            %s -> %s\n"
"         以腾出空间。\n"

#: builtin/stash.c
msgid "cannot apply a stash in the middle of a merge"
msgstr "无法在合并过程中应用贮藏"

#: builtin/stash.c
#, c-format
msgid "could not generate diff %s^!."
msgstr "无法生成差异 %s^!."

#: builtin/stash.c
msgid "conflicts in index. Try without --index."
msgstr "索引中有冲突。尝试不用 --index。"

#: builtin/stash.c
msgid "could not save index tree"
msgstr "不能保存索引树"

#: builtin/stash.c
#, c-format
msgid "Merging %s with %s"
msgstr "正在合并 %s 和 %s"

#: builtin/stash.c
msgid "Index was not unstashed."
msgstr "索引未从贮藏中恢复。"

#: builtin/stash.c
msgid "could not restore untracked files from stash"
msgstr "无法从贮藏条目中恢复未跟踪文件"

#: builtin/stash.c
msgid "attempt to recreate the index"
msgstr "尝试重建索引"

#: builtin/stash.c
#, c-format
msgid "Dropped %s (%s)"
msgstr "丢弃了 %s（%s）"

#: builtin/stash.c
#, c-format
msgid "%s: Could not drop stash entry"
msgstr "%s：无法丢弃贮藏条目"

#: builtin/stash.c
#, c-format
msgid "'%s' is not a stash reference"
msgstr "'%s' 不是一个贮藏引用"

#: builtin/stash.c
msgid "The stash entry is kept in case you need it again."
msgstr "贮藏条目被保留以备您再次需要。"

#: builtin/stash.c
msgid "No branch name specified"
msgstr "未指定分支名"

#: builtin/stash.c
msgid "failed to parse tree"
msgstr "无法解析树"

#: builtin/stash.c
msgid "failed to unpack trees"
msgstr "无法解包目录树"

#: builtin/stash.c
msgid "include untracked files in the stash"
msgstr "在贮藏中包含未跟踪文件"

#: builtin/stash.c
msgid "only show untracked files in the stash"
msgstr "仅显示贮藏中的未跟踪文件"

#: builtin/stash.c
#, c-format
msgid "Cannot update %s with %s"
msgstr "无法用 %2$s 更新 %1$s"

#: builtin/stash.c
msgid "stash message"
msgstr "贮藏说明"

#: builtin/stash.c
msgid "\"git stash store\" requires one <commit> argument"
msgstr "\"git stash store\" 需要一个 <提交> 参数"

#: builtin/stash.c
msgid "No staged changes"
msgstr "没有暂存的修改"

#: builtin/stash.c
msgid "No changes selected"
msgstr "没有选择变更"

#: builtin/stash.c
msgid "You do not have the initial commit yet"
msgstr "您尚未建立初始提交"

#: builtin/stash.c
msgid "Cannot save the current index state"
msgstr "无法保存当前索引状态"

#: builtin/stash.c
msgid "Cannot save the untracked files"
msgstr "无法保存未跟踪文件"

#: builtin/stash.c
msgid "Cannot save the current worktree state"
msgstr "无法保存当前工作区状态"

#: builtin/stash.c
msgid "Cannot save the current staged state"
msgstr "无法保存当前暂存状态"

#: builtin/stash.c
msgid "Cannot record working tree state"
msgstr "不能记录工作区状态"

#: builtin/stash.c
msgid "Can't use --patch and --include-untracked or --all at the same time"
msgstr "不能同时使用参数 --patch 和 --include-untracked 或 --all"

#: builtin/stash.c
msgid "Can't use --staged and --include-untracked or --all at the same time"
msgstr "不能同时使用参数 --staged 和 --include-untracked 或 --all"

#: builtin/stash.c
msgid "Did you forget to 'git add'?"
msgstr "您是否忘了执行 'git add'？"

#: builtin/stash.c
msgid "No local changes to save"
msgstr "没有要保存的本地修改"

#: builtin/stash.c
msgid "Cannot initialize stash"
msgstr "无法初始化贮藏"

#: builtin/stash.c
msgid "Cannot save the current status"
msgstr "无法保存当前状态"

#: builtin/stash.c
#, c-format
msgid "Saved working directory and index state %s"
msgstr "保存工作目录和索引状态 %s"

#: builtin/stash.c
msgid "Cannot remove worktree changes"
msgstr "无法删除工作区变更"

#: builtin/stash.c
msgid "keep index"
msgstr "保持索引"

#: builtin/stash.c
msgid "stash staged changes only"
msgstr "只贮藏暂存的变更"

#: builtin/stash.c
msgid "stash in patch mode"
msgstr "以补丁模式贮藏"

#: builtin/stash.c
msgid "quiet mode"
msgstr "静默模式"

#: builtin/stash.c
msgid "include untracked files in stash"
msgstr "贮藏中包含未跟踪文件"

#: builtin/stash.c
msgid "include ignore files"
msgstr "包含忽略的文件"

#: builtin/stripspace.c
msgid "skip and remove all lines starting with comment character"
msgstr "跳过和移除所有的注释行"

#: builtin/stripspace.c
msgid "prepend comment character and space to each line"
msgstr "为每一行的行首添加注释符和空格"

#: builtin/submodule--helper.c
#, c-format
msgid "Expecting a full ref name, got %s"
msgstr "期望一个完整的引用名称，却得到 %s"

#: builtin/submodule--helper.c
#, c-format
msgid "could not get a repository handle for submodule '%s'"
msgstr "无法获得子模组 '%s' 的仓库句柄"

#: builtin/submodule--helper.c
#, c-format
msgid ""
"could not look up configuration '%s'. Assuming this repository is its own "
"authoritative upstream."
msgstr "无法找到配置 '%s'。假定这个仓库是其自身的官方上游。"

#: builtin/submodule--helper.c
#, c-format
msgid "No url found for submodule path '%s' in .gitmodules"
msgstr "在 .gitmodules 中未找到子模组路径 '%s' 的 url"

#: builtin/submodule--helper.c
#, c-format
msgid "Entering '%s'\n"
msgstr "进入 '%s'\n"

#: builtin/submodule--helper.c
#, c-format
msgid ""
"run_command returned non-zero status for %s\n"
"."
msgstr ""
"对 %s 执行 run_command 返回非零值。\n"
"."

#: builtin/submodule--helper.c
#, c-format
msgid ""
"run_command returned non-zero status while recursing in the nested "
"submodules of %s\n"
"."
msgstr ""
"在递归 %s 的子模组执行 run_command 时返回非零值。\n"
"."

#: builtin/submodule--helper.c
msgid "suppress output of entering each submodule command"
msgstr "抑制进入每一个子模组命令的输出"

#: builtin/submodule--helper.c
msgid "recurse into nested submodules"
msgstr "递归进入嵌套子模组中"

#: builtin/submodule--helper.c
msgid "git submodule foreach [--quiet] [--recursive] [--] <command>"
msgstr "git submodule foreach [--quiet] [--recursive] [--] <命令>"

#: builtin/submodule--helper.c
#, c-format
msgid "Failed to register url for submodule path '%s'"
msgstr "无法为子模组路径 '%s' 注册 url"

#: builtin/submodule--helper.c
#, c-format
msgid "Submodule '%s' (%s) registered for path '%s'\n"
msgstr "子模组 '%s'（%s）已对路径 '%s' 注册\n"

#: builtin/submodule--helper.c
#, c-format
msgid "warning: command update mode suggested for submodule '%s'\n"
msgstr "警告：建议子模组 '%s' 使用命令更新模式\n"

#: builtin/submodule--helper.c
#, c-format
msgid "Failed to register update mode for submodule path '%s'"
msgstr "无法为子模组路径 '%s' 注册更新模式"

#: builtin/submodule--helper.c
msgid "suppress output for initializing a submodule"
msgstr "抑制子模组初始化的输出"

#: builtin/submodule--helper.c
msgid "git submodule init [<options>] [<path>]"
msgstr "git submodule init [<选项>] [<路径>]"

#: builtin/submodule--helper.c
#, c-format
msgid "no submodule mapping found in .gitmodules for path '%s'"
msgstr "在 .gitmodules 中没有发现路径 '%s' 的子模组映射"

#: builtin/submodule--helper.c
#, c-format
msgid "could not resolve HEAD ref inside the submodule '%s'"
msgstr "无法解析子模组 '%s' 的 HEAD 引用"

#: builtin/submodule--helper.c
#, c-format
msgid "failed to recurse into submodule '%s'"
msgstr "无法递归进入子模组 '%s'"

#: builtin/submodule--helper.c
msgid "suppress submodule status output"
msgstr "抑制子模组状态输出"

#: builtin/submodule--helper.c
msgid ""
"use commit stored in the index instead of the one stored in the submodule "
"HEAD"
msgstr "使用存储在索引中的提交，而非存储在子模组 HEAD 中的提交"

#: builtin/submodule--helper.c
msgid "git submodule status [--quiet] [--cached] [--recursive] [<path>...]"
msgstr "git submodule status [--quiet] [--cached] [--recursive] [<路径>...]"

#: builtin/submodule--helper.c
#, c-format
msgid "* %s %s(blob)->%s(submodule)"
msgstr "* %s %s（数据对象）->%s（子模组）"

#: builtin/submodule--helper.c
#, c-format
msgid "* %s %s(submodule)->%s(blob)"
msgstr "* %s %s（子模组）->%s（数据对象）"

#: builtin/submodule--helper.c
#, c-format
msgid "%s"
msgstr "%s"

#: builtin/submodule--helper.c
#, c-format
msgid "couldn't hash object from '%s'"
msgstr "不能从 '%s' 创建哈希对象"

#: builtin/submodule--helper.c
#, c-format
msgid "unexpected mode %o"
msgstr "意外的模式 %o"

#: builtin/submodule--helper.c
msgid "use the commit stored in the index instead of the submodule HEAD"
msgstr "使用存储在索引中的提交，而非存储在子模组 HEAD 中的提交"

#: builtin/submodule--helper.c
msgid "compare the commit in the index with that in the submodule HEAD"
msgstr "比较存储在索引和子模组 HEAD 中的提交"

#: builtin/submodule--helper.c
msgid "skip submodules with 'ignore_config' value set to 'all'"
msgstr "跳过设置了 'ignore_config' 为 'all' 的子模组"

#: builtin/submodule--helper.c
msgid "limit the summary size"
msgstr "限制总结的大小"

#: builtin/submodule--helper.c
msgid "git submodule summary [<options>] [<commit>] [--] [<path>]"
msgstr "git submodule summary [<选项>] [<提交>] [--] [<路径>]"

#: builtin/submodule--helper.c
msgid "could not fetch a revision for HEAD"
msgstr "不能为 HEAD 获取一个版本"

#: builtin/submodule--helper.c
#, c-format
msgid "Synchronizing submodule url for '%s'\n"
msgstr "为 '%s' 同步子模组 url\n"

#: builtin/submodule--helper.c
#, c-format
msgid "failed to register url for submodule path '%s'"
msgstr "无法为子模组路径 '%s' 注册 url"

#: builtin/submodule--helper.c
#, c-format
msgid "failed to update remote for submodule '%s'"
msgstr "无法为子模组 '%s' 更新远程关联"

#: builtin/submodule--helper.c
msgid "suppress output of synchronizing submodule url"
msgstr "抑制子模组 URL 同步的输出"

#: builtin/submodule--helper.c
msgid "git submodule sync [--quiet] [--recursive] [<path>]"
msgstr "git submodule sync [--quiet] [--recursive] [<路径>]"

#: builtin/submodule--helper.c
#, c-format
msgid ""
"Submodule work tree '%s' contains a .git directory. This will be replaced "
"with a .git file by using absorbgitdirs."
msgstr ""
"子模组工作区 '%s' 包含一个 .git 目录。这将会用 absorbgitdirs 子命令替换成一"
"个 .git 文件。"

#: builtin/submodule--helper.c
#, c-format
msgid ""
"Submodule work tree '%s' contains local modifications; use '-f' to discard "
"them"
msgstr "子模组工作区 '%s' 包含本地修改；使用 '-f' 丢弃它们"

#: builtin/submodule--helper.c
#, c-format
msgid "Cleared directory '%s'\n"
msgstr "已清除目录 '%s'\n"

#: builtin/submodule--helper.c
#, c-format
msgid "Could not remove submodule work tree '%s'\n"
msgstr "无法移除子模组工作区 '%s'\n"

#: builtin/submodule--helper.c
#, c-format
msgid "could not create empty submodule directory %s"
msgstr "不能创建空的子模组目录 %s"

#: builtin/submodule--helper.c
#, c-format
msgid "Submodule '%s' (%s) unregistered for path '%s'\n"
msgstr "子模组 '%s'（%s）未对路径 '%s' 注册\n"

#: builtin/submodule--helper.c
msgid "remove submodule working trees even if they contain local changes"
msgstr "删除子模组工作区，即使包含本地修改"

#: builtin/submodule--helper.c
msgid "unregister all submodules"
msgstr "将所有子模组取消注册"

#: builtin/submodule--helper.c
msgid ""
"git submodule deinit [--quiet] [-f | --force] [--all | [--] [<path>...]]"
msgstr ""
"git submodule deinit [--quiet] [-f | --force] [--all | [--] [<路径>...]]"

#: builtin/submodule--helper.c
msgid "Use '--all' if you really want to deinitialize all submodules"
msgstr "如果您确实想要对所有子模组执行取消初始化，请使用 '--all'"

#: builtin/submodule--helper.c
msgid ""
"An alternate computed from a superproject's alternate is invalid.\n"
"To allow Git to clone without an alternate in such a case, set\n"
"submodule.alternateErrorStrategy to 'info' or, equivalently, clone with\n"
"'--reference-if-able' instead of '--reference'."
msgstr ""
"从一个父项目的备用仓库中计算出的备用仓库无效。\n"
"此场景下，设置 submodule.alternateErrorStrategy 为 'info'，以允许\n"
"Git 不使用备用仓库克隆，或者等效地使用 '--reference-if-able' 而非\n"
"'--reference' 来克隆。"

#: builtin/submodule--helper.c
#, c-format
msgid "could not get a repository handle for gitdir '%s'"
msgstr "无法获得 git 目录 '%s' 的仓库句柄"

#: builtin/submodule--helper.c
#, c-format
msgid "submodule '%s' cannot add alternate: %s"
msgstr "子模组 '%s' 不能添加仓库备选：%s"

#: builtin/submodule--helper.c
#, c-format
msgid "Value '%s' for submodule.alternateErrorStrategy is not recognized"
msgstr "不能识别 submodule.alternateErrorStrategy 的取值 '%s'"

#: builtin/submodule--helper.c
#, c-format
msgid "Value '%s' for submodule.alternateLocation is not recognized"
msgstr "不能识别 submodule.alternateLocation 的取值 '%s'"

#: builtin/submodule--helper.c submodule.c
#, c-format
msgid "refusing to create/use '%s' in another submodule's git dir"
msgstr "拒绝在另一个子模组的 git 目录中创建/使用 '%s'"

#: builtin/submodule--helper.c
#, c-format
msgid "directory not empty: '%s'"
msgstr "目录非空：'%s'"

#: builtin/submodule--helper.c
#, c-format
msgid "clone of '%s' into submodule path '%s' failed"
msgstr "无法克隆 '%s' 到子模组路径 '%s'"

#: builtin/submodule--helper.c
#, c-format
msgid "could not get submodule directory for '%s'"
msgstr "无法得到 '%s' 的子模组目录"

#: builtin/submodule--helper.c
msgid "alternative anchor for relative paths"
msgstr "相对路径的替代锚记（anchor）"

#: builtin/submodule--helper.c
msgid "where the new submodule will be cloned to"
msgstr "新的子模组将要克隆的路径"

#: builtin/submodule--helper.c
msgid "name of the new submodule"
msgstr "新子模组的名称"

#: builtin/submodule--helper.c
msgid "url where to clone the submodule from"
msgstr "克隆子模组的 url 地址"

#: builtin/submodule--helper.c
msgid "depth for shallow clones"
msgstr "浅克隆的深度"

#: builtin/submodule--helper.c
msgid "force cloning progress"
msgstr "强制显示克隆进度"

#: builtin/submodule--helper.c
msgid "disallow cloning into non-empty directory"
msgstr "不允许克隆到一个非空目录"

#: builtin/submodule--helper.c
msgid ""
"git submodule--helper clone [--prefix=<path>] [--quiet] [--reference "
"<repository>] [--name <name>] [--depth <depth>] [--single-branch] [--filter "
"<filter-spec>] --url <url> --path <path>"
msgstr ""
"git submodule--helper clone [--prefix=<路径>] [--quiet] [--reference <仓库>] "
"[--name <名字>] [--depth <深度>] [--single-branch] [--filter <过滤器规格>] --"
"url <url> --path <路径>"

#: builtin/submodule--helper.c
#, c-format
msgid "Invalid update mode '%s' configured for submodule path '%s'"
msgstr "为子模组路径 '%2$s' 配置的更新模式 '%1$s' 无效"

#: builtin/submodule--helper.c
#, c-format
msgid "Submodule path '%s' not initialized"
msgstr "子模组路径 '%s' 尚未初始化"

#: builtin/submodule--helper.c
msgid "Maybe you want to use 'update --init'?"
msgstr "也许您想要执行 'update --init'？"

#: builtin/submodule--helper.c
#, c-format
msgid "Skipping unmerged submodule %s"
msgstr "略过未合并的子模组 %s"

#: builtin/submodule--helper.c
#, c-format
msgid "Skipping submodule '%s'"
msgstr "略过子模组 '%s'"

#: builtin/submodule--helper.c
#, c-format
msgid "cannot clone submodule '%s' without a URL"
msgstr "无法在不提供 URL 时克隆子模组 '%s'"

#: builtin/submodule--helper.c
#, c-format
msgid "Failed to clone '%s'. Retry scheduled"
msgstr "克隆 '%s' 失败。按计划重试"

#: builtin/submodule--helper.c
#, c-format
msgid "Failed to clone '%s' a second time, aborting"
msgstr "第二次尝试克隆 '%s' 失败，退出"

#: builtin/submodule--helper.c
#, c-format
msgid "Unable to checkout '%s' in submodule path '%s'"
msgstr "无法在子模组路径 '%2$s' 中检出 '%1$s'"

#: builtin/submodule--helper.c
#, c-format
msgid "Unable to rebase '%s' in submodule path '%s'"
msgstr "无法在子模组路径 '%2$s' 中变基 '%1$s'"

#: builtin/submodule--helper.c
#, c-format
msgid "Unable to merge '%s' in submodule path '%s'"
msgstr "无法在子模组路径 '%2$s' 中合并 '%1$s'"

#: builtin/submodule--helper.c
#, c-format
msgid "Execution of '%s %s' failed in submodule path '%s'"
msgstr "在子模组路径 '%3$s' 中执行 '%1$s %2$s' 失败"

#: builtin/submodule--helper.c
#, c-format
msgid "Submodule path '%s': checked out '%s'\n"
msgstr "子模组路径 '%s'：检出 '%s'\n"

#: builtin/submodule--helper.c
#, c-format
msgid "Submodule path '%s': rebased into '%s'\n"
msgstr "子模组路径 '%s'：变基至 '%s'\n"

#: builtin/submodule--helper.c
#, c-format
msgid "Submodule path '%s': merged in '%s'\n"
msgstr "子模组路径 '%s'：合并入 '%s'\n"

#: builtin/submodule--helper.c
#, c-format
msgid "Submodule path '%s': '%s %s'\n"
msgstr "子模组路径 '%s'：'%s %s'\n"

#: builtin/submodule--helper.c
#, c-format
msgid "Unable to fetch in submodule path '%s'; trying to directly fetch %s:"
msgstr "无法在子模组路径 '%s' 中获取；尝试直接获取 %s："

#: builtin/submodule--helper.c
#, c-format
msgid ""
"Fetched in submodule path '%s', but it did not contain %s. Direct fetching "
"of that commit failed."
msgstr "获取了子模组路径 '%s'，但是它没有包含 %s。直接获取该提交失败。"

#: builtin/submodule--helper.c
#, c-format
msgid "could not initialize submodule at path '%s'"
msgstr "无法在路径 '%s' 初始化子模组"

#: builtin/submodule--helper.c
#, c-format
msgid ""
"Submodule (%s) branch configured to inherit branch from superproject, but "
"the superproject is not on any branch"
msgstr "子模组（%s）的分支配置为继承上级项目的分支，但是上级项目不在任何分支上"

#: builtin/submodule--helper.c
#, c-format
msgid "Unable to find current revision in submodule path '%s'"
msgstr "无法在子模组路径 '%s' 中找到当前版本"

#: builtin/submodule--helper.c
#, c-format
msgid "Unable to fetch in submodule path '%s'"
msgstr "无法在子模组路径 '%s' 中获取"

#: builtin/submodule--helper.c
#, c-format
msgid "Unable to find %s revision in submodule path '%s'"
msgstr "无法在子模组路径 '%2$s' 中找到当前版本 %1$s"

#: builtin/submodule--helper.c
#, c-format
msgid "Failed to recurse into submodule path '%s'"
msgstr "无法递归进入子模组路径 '%s'"

#: builtin/submodule--helper.c
msgid "force checkout updates"
msgstr "强制检出更新"

#: builtin/submodule--helper.c
msgid "initialize uninitialized submodules before update"
msgstr "在更新前初始化尚未初始化的子模组"

#: builtin/submodule--helper.c
msgid "use SHA-1 of submodule's remote tracking branch"
msgstr "使用子模组远程追踪分支的 SHA-1"

#: builtin/submodule--helper.c
msgid "traverse submodules recursively"
msgstr "递归遍历子模组"

#: builtin/submodule--helper.c
msgid "don't fetch new objects from the remote site"
msgstr "不要从远程地址获取新对象"

#: builtin/submodule--helper.c
msgid "use the 'checkout' update strategy (default)"
msgstr "使用 'checkout' 更新策略（默认）"

#: builtin/submodule--helper.c
msgid "use the 'merge' update strategy"
msgstr "使用 'merge' 更新策略"

#: builtin/submodule--helper.c
msgid "use the 'rebase' update strategy"
msgstr "使用 'rebase' 更新策略"

#: builtin/submodule--helper.c
msgid "create a shallow clone truncated to the specified number of revisions"
msgstr "创建一个指定深度的浅克隆"

#: builtin/submodule--helper.c
msgid "parallel jobs"
msgstr "并发任务"

#: builtin/submodule--helper.c
msgid "whether the initial clone should follow the shallow recommendation"
msgstr "初始克隆是否应该遵守推荐的浅克隆选项"

#: builtin/submodule--helper.c
msgid "don't print cloning progress"
msgstr "不要输出克隆进度"

#: builtin/submodule--helper.c
msgid "disallow cloning into non-empty directory, implies --init"
msgstr "不允许克隆到一个非空目录，暗含 --init"

#: builtin/submodule--helper.c
msgid ""
"git submodule [--quiet] update [--init [--filter=<filter-spec>]] [--remote] "
"[-N|--no-fetch] [-f|--force] [--checkout|--merge|--rebase] [--[no-]recommend-"
"shallow] [--reference <repository>] [--recursive] [--[no-]single-branch] "
"[--] [<path>...]"
msgstr ""
"git submodule [--quiet] update [--init [--filter=<过滤器规格>]] [--remote] [-"
"N|--no-fetch] [-f|--force] [--checkout|--merge|--rebase] [--[no-]recommend-"
"shallow] [--reference <仓库>] [--recursive] [--[no-]single-branch] [--] [<路"
"径>...]"

#: builtin/submodule--helper.c submodule.c
msgid "Failed to resolve HEAD as a valid ref."
msgstr "无法将 HEAD 解析为有效引用。"

#: builtin/submodule--helper.c
msgid "git submodule absorbgitdirs [<options>] [<path>...]"
msgstr "git submodule absorbgitdirs [<选项>] [<路径>...]"

#: builtin/submodule--helper.c
msgid "suppress output for setting url of a submodule"
msgstr "抑制设置子模组 URL 的输出"

#: builtin/submodule--helper.c
msgid "git submodule set-url [--quiet] <path> <newurl>"
msgstr "git submodule set-url [--quiet] <路径> <新地址>"

#: builtin/submodule--helper.c
msgid "set the default tracking branch to master"
msgstr "设置默认跟踪分支为 master"

#: builtin/submodule--helper.c
msgid "set the default tracking branch"
msgstr "设置默认跟踪分支"

#: builtin/submodule--helper.c
msgid "git submodule set-branch [-q|--quiet] (-d|--default) <path>"
msgstr "git submodule set-branch [-q|--quiet] (-d|--default) <路径>"

#: builtin/submodule--helper.c
msgid "git submodule set-branch [-q|--quiet] (-b|--branch) <branch> <path>"
msgstr "git submodule set-branch [-q|--quiet] (-b|--branch) <分支> <路径>"

#: builtin/submodule--helper.c
msgid "--branch or --default required"
msgstr "需要 --branch 或 --default"

#: builtin/submodule--helper.c
msgid "print only error messages"
msgstr "只打印错误消息"

#: builtin/submodule--helper.c
msgid "force creation"
msgstr "强制创建"

#: builtin/submodule--helper.c
msgid "show whether the branch would be created"
msgstr "显示是否将要创建分支"

#: builtin/submodule--helper.c
msgid ""
"git submodule--helper create-branch [-f|--force] [--create-reflog] [-q|--"
"quiet] [-t|--track] [-n|--dry-run] <name> <start-oid> <start-name>"
msgstr ""
"git submodule--helper create-branch [-f|--force] [--create-reflog] [-q|--"
"quiet] [-t|--track] [-n|--dry-run] <名称> <起始对象 ID> <起始名称>"

#: builtin/submodule--helper.c
#, c-format
msgid "creating branch '%s'"
msgstr "正在创建分支 '%s'"

#: builtin/submodule--helper.c
#, c-format
msgid "Adding existing repo at '%s' to the index\n"
msgstr "向索引中添加位于 '%s' 的已存在的仓库\n"

#: builtin/submodule--helper.c
#, c-format
msgid "'%s' already exists and is not a valid git repo"
msgstr "'%s' 已存在并且不是一个有效的 git 仓库"

#: builtin/submodule--helper.c
#, c-format
msgid "A git directory for '%s' is found locally with remote(s):\n"
msgstr "发现一个本地 git 目录 '%s' 及其远程仓库：\n"

#: builtin/submodule--helper.c
#, c-format
msgid ""
"If you want to reuse this local git directory instead of cloning again from\n"
"  %s\n"
"use the '--force' option. If the local git directory is not the correct "
"repo\n"
"or you are unsure what this means choose another name with the '--name' "
"option."
msgstr ""
"如果您想要重用这个本地 git 目录而非重新克隆自\n"
"  %s\n"
"使用 '--force' 选项。如果本地 git 目录不是正确的仓库，或者如果您不确定这里\n"
"的含义，使用 '--name' 选项指定另外的名称。"

#: builtin/submodule--helper.c
#, c-format
msgid "Reactivating local git directory for submodule '%s'\n"
msgstr "为子模组 '%s' 重新激活本地 git 目录\n"

#: builtin/submodule--helper.c
#, c-format
msgid "unable to checkout submodule '%s'"
msgstr "无法检出子模组 '%s'"

#: builtin/submodule--helper.c
msgid "please make sure that the .gitmodules file is in the working tree"
msgstr "请确认 .gitmodules 文件在工作区里"

#: builtin/submodule--helper.c
#, c-format
msgid "Failed to add submodule '%s'"
msgstr "无法添加子模组 '%s'"

#: builtin/submodule--helper.c
#, c-format
msgid "Failed to register submodule '%s'"
msgstr "无法注册子模组 '%s'"

#: builtin/submodule--helper.c
#, c-format
msgid "'%s' already exists in the index"
msgstr "'%s' 已经存在于索引中"

#: builtin/submodule--helper.c
#, c-format
msgid "'%s' already exists in the index and is not a submodule"
msgstr "'%s' 已经存在于索引中且不是一个子模组"

#: builtin/submodule--helper.c read-cache.c
#, c-format
msgid "'%s' does not have a commit checked out"
msgstr "'%s' 没有检出一个提交"

#: builtin/submodule--helper.c
msgid "branch of repository to add as submodule"
msgstr "要添加为子模组的仓库的分支"

#: builtin/submodule--helper.c
msgid "allow adding an otherwise ignored submodule path"
msgstr "允许添加一个被忽略的子模组路径"

#: builtin/submodule--helper.c
msgid "borrow the objects from reference repositories"
msgstr "从引用仓库中借用对象"

#: builtin/submodule--helper.c
msgid ""
"sets the submodule's name to the given string instead of defaulting to its "
"path"
msgstr "将子模组的名称设置为给定的字符串，而非默认为其路径"

#: builtin/submodule--helper.c
msgid "git submodule add [<options>] [--] <repository> [<path>]"
msgstr "git submodule add [<选项>] [--] <仓库> [<路径>]"

#: builtin/submodule--helper.c
msgid "Relative path can only be used from the toplevel of the working tree"
msgstr "只能在工作区的顶级目录中使用相对路径"

#: builtin/submodule--helper.c
#, c-format
msgid "repo URL: '%s' must be absolute or begin with ./|../"
msgstr "仓库 URL：'%s' 必须是绝对路径或以 ./|../ 起始"

#: builtin/submodule--helper.c
#, c-format
msgid "'%s' is not a valid submodule name"
msgstr "'%s' 不是一个有效的子模组名称"

#: builtin/submodule--helper.c
msgid "git submodule--helper <command>"
msgstr "git submodule--helper <命令>"

#: builtin/symbolic-ref.c
msgid "git symbolic-ref [-m <reason>] <name> <ref>"
msgstr "git symbolic-ref [-m <理由>] <名称> <引用>"

#: builtin/symbolic-ref.c
msgid "git symbolic-ref [-q] [--short] [--no-recurse] <name>"
msgstr "git symbolic-ref [-q] [--short] [--no-recurse] <名称>"

#: builtin/symbolic-ref.c
msgid "git symbolic-ref --delete [-q] <name>"
msgstr "git symbolic-ref --delete [-q] <名称>"

#: builtin/symbolic-ref.c
msgid "suppress error message for non-symbolic (detached) refs"
msgstr "不显示非符号（分离的）引用的错误信息"

#: builtin/symbolic-ref.c
msgid "delete symbolic ref"
msgstr "删除符号引用"

#: builtin/symbolic-ref.c
msgid "shorten ref output"
msgstr "缩短引用输出"

#: builtin/symbolic-ref.c
msgid "recursively dereference (default)"
msgstr "递归解引用（默认）"

#: builtin/symbolic-ref.c builtin/update-ref.c
msgid "reason"
msgstr "原因"

#: builtin/symbolic-ref.c builtin/update-ref.c
msgid "reason of the update"
msgstr "更新的原因"

#: builtin/tag.c
msgid ""
"git tag [-a | -s | -u <key-id>] [-f] [-m <msg> | -F <file>] [-e]\n"
"        [(--trailer <token>[(=|:)<value>])...]\n"
"        <tagname> [<commit> | <object>]"
msgstr ""
"git tag [-a | -s | -u <私钥 id>] [-f] [-m <消息> | -F <文件>] [-e]\n"
"        [(--trailer <令牌>[(=|:)<值>])...]\n"
"        <标签名> [<提交> | <对象>]"

#: builtin/tag.c
msgid "git tag -d <tagname>..."
msgstr "git tag -d <标签名>..."

#: builtin/tag.c
msgid ""
"git tag [-n[<num>]] -l [--contains <commit>] [--no-contains <commit>]\n"
"        [--points-at <object>] [--column[=<options>] | --no-column]\n"
"        [--create-reflog] [--sort=<key>] [--format=<format>]\n"
"        [--merged <commit>] [--no-merged <commit>] [<pattern>...]"
msgstr ""
"git tag [-n[<数字>]] -l [--contains <提交>] [--no-contains <提交>]\n"
"        [--points-at <对象>] [--column[=<选项>] | --no-column]\n"
"        [--create-reflog] [--sort=<键>] [--format=<格式>]\n"
"        [--merged <提交>] [--no-merged <提交>] [<模式>...]"

#: builtin/tag.c
msgid "git tag -v [--format=<format>] <tagname>..."
msgstr "git tag -v [--format=<格式>] <标签名>..."

#: builtin/tag.c
#, c-format
msgid "tag '%s' not found."
msgstr "未发现标签 '%s'。"

#: builtin/tag.c
#, c-format
msgid "Deleted tag '%s' (was %s)\n"
msgstr "已删除标签 '%s'（曾为 %s）\n"

#: builtin/tag.c
#, c-format
msgid ""
"\n"
"Write a message for tag:\n"
"  %s\n"
"Lines starting with '%s' will be ignored.\n"
msgstr ""
"\n"
"输入一个标签说明：\n"
"  %s\n"
"以 '%s' 开头的行将被忽略。\n"

#: builtin/tag.c
#, c-format
msgid ""
"\n"
"Write a message for tag:\n"
"  %s\n"
"Lines starting with '%s' will be kept; you may remove them yourself if you "
"want to.\n"
msgstr ""
"\n"
"输入一个标签说明：\n"
"  %s\n"
"以 '%s' 开头的行将被保留，如果您愿意也可以删除它们。\n"

#: builtin/tag.c
msgid "unable to sign the tag"
msgstr "无法签署标签"

#: builtin/tag.c
#, c-format
msgid ""
"You have created a nested tag. The object referred to by your new tag is\n"
"already a tag. If you meant to tag the object that it points to, use:\n"
"\n"
"\tgit tag -f %s %s^{}"
msgstr ""
"您创建了一个嵌套的标签。您的新标签指向的对象已经是一个标签。如果您想要\n"
"对其指向的目标创建标签，使用：\n"
"\n"
"\tgit tag -f %s %s^{}"

#: builtin/tag.c
msgid "bad object type."
msgstr "坏的对象类型。"

#: builtin/tag.c
msgid "no tag message?"
msgstr "无标签说明？"

#: builtin/tag.c
#, c-format
msgid "The tag message has been left in %s\n"
msgstr "标签说明被保留在 %s\n"

#: builtin/tag.c
msgid "list tag names"
msgstr "列出标签名称"

#: builtin/tag.c
msgid "print <n> lines of each tag message"
msgstr "每个标签信息打印 <n> 行"

#: builtin/tag.c
msgid "delete tags"
msgstr "删除标签"

#: builtin/tag.c
msgid "verify tags"
msgstr "验证标签"

#: builtin/tag.c
msgid "Tag creation options"
msgstr "标签创建选项"

#: builtin/tag.c
msgid "annotated tag, needs a message"
msgstr "附注标签，需要一个说明"

#: builtin/tag.c
msgid "tag message"
msgstr "标签说明"

#: builtin/tag.c
msgid "force edit of tag message"
msgstr "强制编辑标签说明"

#: builtin/tag.c
msgid "annotated and GPG-signed tag"
msgstr "附注并附加 GPG 签名的标签"

#: builtin/tag.c
msgid "use another key to sign the tag"
msgstr "使用另外的私钥签名该标签"

#: builtin/tag.c
msgid "replace the tag if exists"
msgstr "如果存在，替换现有的标签"

#: builtin/tag.c builtin/update-ref.c
msgid "create a reflog"
msgstr "创建引用日志"

#: builtin/tag.c
msgid "Tag listing options"
msgstr "标签列表选项"

#: builtin/tag.c
msgid "show tag list in columns"
msgstr "以列的方式显示标签列表"

#: builtin/tag.c
msgid "print only tags that contain the commit"
msgstr "只打印包含该提交的标签"

#: builtin/tag.c
msgid "print only tags that don't contain the commit"
msgstr "只打印不包含该提交的标签"

#: builtin/tag.c
msgid "print only tags that are merged"
msgstr "只打印已经合并的标签"

#: builtin/tag.c
msgid "print only tags that are not merged"
msgstr "只打印尚未合并的标签"

#: builtin/tag.c
msgid "print only tags of the object"
msgstr "只打印指向该对象的标签"

#: builtin/tag.c
msgid "could not start 'git column'"
msgstr "无法启动 'git column'"

#: builtin/tag.c
#, c-format
msgid "the '%s' option is only allowed in list mode"
msgstr "'%s' 选项只允许用在列表显示模式"

#: builtin/tag.c
#, c-format
msgid "'%s' is not a valid tag name."
msgstr "'%s' 不是一个有效的标签名称。"

#: builtin/tag.c
#, c-format
msgid "tag '%s' already exists"
msgstr "标签 '%s' 已存在"

#: builtin/tag.c sequencer.c
#, c-format
msgid "Invalid cleanup mode %s"
msgstr "无效的清理模式 %s"

#: builtin/tag.c
#, c-format
msgid "Updated tag '%s' (was %s)\n"
msgstr "已更新标签 '%s'（曾为 %s）\n"

#: builtin/unpack-objects.c
msgid "pack exceeds maximum allowed size"
msgstr "包超过了最大允许大小"

#: builtin/unpack-objects.c
msgid "failed to write object in stream"
msgstr "无法在流中写入对象"

#: builtin/unpack-objects.c
#, c-format
msgid "inflate returned (%d)"
msgstr "解压缩返回了 (%d)"

#: builtin/unpack-objects.c
msgid "invalid blob object from stream"
msgstr "流中无效的数据对象"

#: builtin/unpack-objects.c
msgid "Unpacking objects"
msgstr "展开对象中"

#: builtin/update-index.c
#, c-format
msgid "failed to create directory %s"
msgstr "无法创建目录 %s"

#: builtin/update-index.c
#, c-format
msgid "failed to delete file %s"
msgstr "无法删除文件 %s"

#: builtin/update-index.c
#, c-format
msgid "failed to delete directory %s"
msgstr "无法删除目录 %s"

#: builtin/update-index.c
#, c-format
msgid "Testing mtime in '%s' "
msgstr "在 '%s' 中测试 mtime "

#: builtin/update-index.c
msgid "directory stat info does not change after adding a new file"
msgstr "添加一个新文件后，目录的状态信息未改变"

#: builtin/update-index.c
msgid "directory stat info does not change after adding a new directory"
msgstr "添加一个新目录后，目录的状态信息未改变"

#: builtin/update-index.c
msgid "directory stat info changes after updating a file"
msgstr "更新一个文件后，目录的状态信息被修改"

#: builtin/update-index.c
msgid "directory stat info changes after adding a file inside subdirectory"
msgstr "在子目录中添加文件后，目录的状态信息被修改"

#: builtin/update-index.c
msgid "directory stat info does not change after deleting a file"
msgstr "删除一个文件后，目录的状态信息未改变"

#: builtin/update-index.c
msgid "directory stat info does not change after deleting a directory"
msgstr "删除一个目录后，目录的状态信息未改变"

#: builtin/update-index.c
msgid " OK"
msgstr " OK"

#: builtin/update-index.c
msgid "git update-index [<options>] [--] [<file>...]"
msgstr "git update-index [<选项>] [--] [<文件>...]"

#: builtin/update-index.c
msgid "continue refresh even when index needs update"
msgstr "当索引需要更新时继续刷新"

#: builtin/update-index.c
msgid "refresh: ignore submodules"
msgstr "刷新：忽略子模组"

#: builtin/update-index.c
msgid "do not ignore new files"
msgstr "不忽略新的文件"

#: builtin/update-index.c
msgid "let files replace directories and vice-versa"
msgstr "让文件替换目录（反之亦然）"

#: builtin/update-index.c
msgid "notice files missing from worktree"
msgstr "通知文件从工作区丢失"

#: builtin/update-index.c
msgid "refresh even if index contains unmerged entries"
msgstr "即使索引区包含未合并的条目也执行刷新"

#: builtin/update-index.c
msgid "refresh stat information"
msgstr "刷新统计信息"

#: builtin/update-index.c
msgid "like --refresh, but ignore assume-unchanged setting"
msgstr "类似于 --refresh，但是忽略 assume-unchanged 设置"

#: builtin/update-index.c
msgid "<mode>,<object>,<path>"
msgstr "<存取模式>,<对象>,<路径>"

#: builtin/update-index.c
msgid "add the specified entry to the index"
msgstr "添加指定的条目到索引区"

#: builtin/update-index.c
msgid "mark files as \"not changing\""
msgstr "把文件标记为 \"没有变更\""

#: builtin/update-index.c
msgid "clear assumed-unchanged bit"
msgstr "清除 assumed-unchanged 位"

#: builtin/update-index.c
msgid "mark files as \"index-only\""
msgstr "把文件标记为 \"仅索引\""

#: builtin/update-index.c
msgid "clear skip-worktree bit"
msgstr "清除 skip-worktree 位"

#: builtin/update-index.c
msgid "do not touch index-only entries"
msgstr "不要触碰仅索引条目"

#: builtin/update-index.c
msgid "add to index only; do not add content to object database"
msgstr "只添加到索引区；不添加对象到对象库"

#: builtin/update-index.c
msgid "remove named paths even if present in worktree"
msgstr "即使存在工作区里，也删除路径"

#: builtin/update-index.c
msgid "with --stdin: input lines are terminated by null bytes"
msgstr "携带 --stdin：输入的行以 null 字符终止"

#: builtin/update-index.c
msgid "read list of paths to be updated from standard input"
msgstr "从标准输入中读取需要更新的路径列表"

#: builtin/update-index.c
msgid "add entries from standard input to the index"
msgstr "从标准输入添加条目到索引区"

#: builtin/update-index.c
msgid "repopulate stages #2 and #3 for the listed paths"
msgstr "为指定文件重新生成第2和第3暂存区"

#: builtin/update-index.c
msgid "only update entries that differ from HEAD"
msgstr "只更新与 HEAD 不同的条目"

#: builtin/update-index.c
msgid "ignore files missing from worktree"
msgstr "忽略工作区丢失的文件"

#: builtin/update-index.c
msgid "report actions to standard output"
msgstr "在标准输出显示操作"

#: builtin/update-index.c
msgid "(for porcelains) forget saved unresolved conflicts"
msgstr "(for porcelains) 忘记保存的未解决的冲突"

#: builtin/update-index.c
msgid "write index in this format"
msgstr "以这种格式写入索引区"

#: builtin/update-index.c
msgid "report on-disk index format version"
msgstr "报告磁盘索引格式的版本"

#: builtin/update-index.c
msgid "enable or disable split index"
msgstr "启用或禁用索引拆分"

#: builtin/update-index.c
msgid "enable/disable untracked cache"
msgstr "启用/禁用对未跟踪文件的缓存"

#: builtin/update-index.c
msgid "test if the filesystem supports untracked cache"
msgstr "测试文件系统是否支持未跟踪文件缓存"

#: builtin/update-index.c
msgid "enable untracked cache without testing the filesystem"
msgstr "无需检测文件系统，启用对未跟踪文件的缓存"

#: builtin/update-index.c
msgid "write out the index even if is not flagged as changed"
msgstr "即使没有被标记为已更改，也要写出索引"

#: builtin/update-index.c
msgid "enable or disable file system monitor"
msgstr "启用或禁用文件系统监控"

#: builtin/update-index.c
msgid "mark files as fsmonitor valid"
msgstr "标记文件为 fsmonitor 有效"

#: builtin/update-index.c
msgid "clear fsmonitor valid bit"
msgstr "清除 fsmonitor 有效位"

#: builtin/update-index.c
#, c-format
msgid "%d\n"
msgstr "%d\n"

#: builtin/update-index.c
#, c-format
msgid "index-version: was %d, set to %d"
msgstr "索引版本：从 %d 设置为 %d"

#: builtin/update-index.c
msgid ""
"core.splitIndex is set to false; remove or change it, if you really want to "
"enable split index"
msgstr ""
"core.splitIndex 被设置为 false。如果您确实要启用索引拆分，请删除或修改它。"

#: builtin/update-index.c
msgid ""
"core.splitIndex is set to true; remove or change it, if you really want to "
"disable split index"
msgstr ""
"core.splitIndex 被设置为 true。如果您确实要禁用索引拆分，请删除或修改它。"

#: builtin/update-index.c
msgid ""
"core.untrackedCache is set to true; remove or change it, if you really want "
"to disable the untracked cache"
msgstr ""
"core.untrackedCache 被设置为 true。如果您确实要禁用未跟踪文件缓存，请删除或修"
"改它。"

#: builtin/update-index.c
msgid "Untracked cache disabled"
msgstr "缓存未跟踪文件被禁用"

#: builtin/update-index.c
msgid ""
"core.untrackedCache is set to false; remove or change it, if you really want "
"to enable the untracked cache"
msgstr ""
"core.untrackedCache 被设置为 false。如果您确实要启用未跟踪文件缓存，请删除或"
"修改它。"

#: builtin/update-index.c
#, c-format
msgid "Untracked cache enabled for '%s'"
msgstr "缓存未跟踪文件在 '%s' 启用"

#: builtin/update-index.c
msgid "core.fsmonitor is unset; set it if you really want to enable fsmonitor"
msgstr "core.fsmonitor 未设置；如果想要启用 fsmonitor 请设置该选项"

#: builtin/update-index.c
msgid "fsmonitor enabled"
msgstr "fsmonitor 被启用"

#: builtin/update-index.c
msgid ""
"core.fsmonitor is set; remove it if you really want to disable fsmonitor"
msgstr "core.fsmonitor 已设置；如果想要禁用 fsmonitor 请移除该选项"

#: builtin/update-index.c
msgid "fsmonitor disabled"
msgstr "fsmonitor 被禁用"

#: builtin/update-ref.c
msgid "git update-ref [<options>] -d <refname> [<old-oid>]"
msgstr "git update-ref [<选项>] -d <引用名> [<旧对象>]"

#: builtin/update-ref.c
msgid "git update-ref [<options>]    <refname> <new-oid> [<old-oid>]"
msgstr "git update-ref [<选项>]    <引用名> <新对象> [<旧对象>]"

#: builtin/update-ref.c
msgid "git update-ref [<options>] --stdin [-z]"
msgstr "git update-ref [<选项>] --stdin [-z]"

#: builtin/update-ref.c
msgid "delete the reference"
msgstr "删除引用"

#: builtin/update-ref.c
msgid "update <refname> not the one it points to"
msgstr "更新 <引用名> 本身而不是它指向的引用"

#: builtin/update-ref.c
msgid "stdin has NUL-terminated arguments"
msgstr "标准输入有以 NUL 字符终止的参数"

#: builtin/update-ref.c
msgid "read updates from stdin"
msgstr "从标准输入读取更新"

#: builtin/update-server-info.c
msgid "update the info files from scratch"
msgstr "从头开始更新文件信息"

#: builtin/upload-pack.c
msgid ""
"git-upload-pack [--[no-]strict] [--timeout=<n>] [--stateless-rpc]\n"
"                [--advertise-refs] <directory>"
msgstr ""
"git-upload-pack [--[no-]strict] [--timeout=<n>] [--stateless-rpc]\n"
"                [--advertise-refs] <目录>"

#: builtin/upload-pack.c t/helper/test-serve-v2.c
msgid "quit after a single request/response exchange"
msgstr "在一次单独的请求/响应之后退出"

#: builtin/upload-pack.c
msgid "serve up the info/refs for git-http-backend"
msgstr "为 git-http-backend 提供 info/refs"

#: builtin/upload-pack.c
msgid "do not try <directory>/.git/ if <directory> is no Git directory"
msgstr "如果 <目录> 不是一个 Git 目录，不要尝试 <目录>/.git/"

#: builtin/upload-pack.c
msgid "interrupt transfer after <n> seconds of inactivity"
msgstr "不活动 <n> 秒钟后终止传输"

#: builtin/verify-commit.c
msgid "git verify-commit [-v | --verbose] [--raw] <commit>..."
msgstr "git verify-commit [-v | --verbose] [--raw] <提交>..."

#: builtin/verify-commit.c
msgid "print commit contents"
msgstr "打印提交内容"

#: builtin/verify-commit.c builtin/verify-tag.c
msgid "print raw gpg status output"
msgstr "打印原始 gpg 状态输出"

#: builtin/verify-pack.c
msgid "git verify-pack [-v | --verbose] [-s | --stat-only] [--] <pack>.idx..."
msgstr "git verify-pack [-v | --verbose] [-s | --stat-only] [--] <包>.idx..."

#: builtin/verify-pack.c
msgid "verbose"
msgstr "冗长输出"

#: builtin/verify-pack.c
msgid "show statistics only"
msgstr "只显示统计"

#: builtin/verify-tag.c
msgid "git verify-tag [-v | --verbose] [--format=<format>] [--raw] <tag>..."
msgstr "git verify-tag [-v | --verbose] [--format=<格式>] [--raw] <标签>..."

#: builtin/verify-tag.c
msgid "print tag contents"
msgstr "打印标签内容"

#: builtin/worktree.c
msgid ""
"git worktree add [-f] [--detach] [--checkout] [--lock [--reason <string>]]\n"
"                 [--orphan] [(-b | -B) <new-branch>] <path> [<commit-ish>]"
msgstr ""
"git worktree add [-f] [--detach] [--checkout] [--lock [--reason <字符串>]]\n"
"                 [--orphan] [(-b | -B) <新分支>] <路径> [<提交号>]"

#: builtin/worktree.c
msgid "git worktree list [-v | --porcelain [-z]]"
msgstr "git worktree list [-v | --porcelain [-z]]"

#: builtin/worktree.c
msgid "git worktree lock [--reason <string>] <worktree>"
msgstr "git worktree lock [--reason <字符串>] <工作区>"

#: builtin/worktree.c
msgid "git worktree move <worktree> <new-path>"
msgstr "git worktree move <工作区> <新路径>"

#: builtin/worktree.c
msgid "git worktree prune [-n] [-v] [--expire <expire>]"
msgstr "git worktree prune [-n] [-v] [--expire <过期>]"

#: builtin/worktree.c
msgid "git worktree remove [-f] <worktree>"
msgstr "git worktree remove [-f] <工作区>"

#: builtin/worktree.c
msgid "git worktree repair [<path>...]"
msgstr "git worktree repair [<路径>...]"

#: builtin/worktree.c
msgid "git worktree unlock <worktree>"
msgstr "git worktree unlock <工作区>"

#: builtin/worktree.c
msgid "No possible source branch, inferring '--orphan'"
msgstr "没有可用的源分支，将基于 '--orphan' 选项进行推断"

#: builtin/worktree.c
#, c-format
msgid ""
"If you meant to create a worktree containing a new unborn branch\n"
"(branch with no commits) for this repository, you can do so\n"
"using the --orphan flag:\n"
"\n"
"    git worktree add --orphan -b %s %s\n"
msgstr ""
"如果你打算为此仓库创建一个包含新的未诞生的\n"
"分支（没有提交的分支）的工作区，你可以使用\n"
"选项 --orphan 来执行此操作：\n"
"\n"
"    git worktree add --orphan -b %s %s\n"

#: builtin/worktree.c
#, c-format
msgid ""
"If you meant to create a worktree containing a new unborn branch\n"
"(branch with no commits) for this repository, you can do so\n"
"using the --orphan flag:\n"
"\n"
"    git worktree add --orphan %s\n"
msgstr ""
"如果你打算为此仓库创建一个包含新的未诞生的\n"
"分支（没有提交的分支）的工作区，你可以使用\n"
"选项 --orphan 来执行此操作：\n"
"\n"
"    git worktree add --orphan %s\n"

#: builtin/worktree.c
#, c-format
msgid "Removing %s/%s: %s"
msgstr "删除 %s/%s: %s"

#: builtin/worktree.c
msgid "report pruned working trees"
msgstr "报告清除的工作区"

#: builtin/worktree.c
msgid "expire working trees older than <time>"
msgstr "将早于 <时间> 的工作区过期"

#: builtin/worktree.c
#, c-format
msgid "'%s' already exists"
msgstr "'%s' 已经存在"

#: builtin/worktree.c
#, c-format
msgid "unusable worktree destination '%s'"
msgstr "无法使用的工作区目标 '%s'"

#: builtin/worktree.c
#, c-format
msgid ""
"'%s' is a missing but locked worktree;\n"
"use '%s -f -f' to override, or 'unlock' and 'prune' or 'remove' to clear"
msgstr ""
"'%s' 是一个丢失但锁定的工作区，\n"
"使用 '%s -f -f' 覆盖，或用 'unlock' 和 'prune' 或 'remove' 清除"

#: builtin/worktree.c
#, c-format
msgid ""
"'%s' is a missing but already registered worktree;\n"
"use '%s -f' to override, or 'prune' or 'remove' to clear"
msgstr ""
"'%s' 是一个丢失但已经注册的工作区，\n"
"使用 '%s -f' 覆盖，或用 'prune' 或 'remove' 清除"

#: builtin/worktree.c
#, c-format
msgid "failed to copy '%s' to '%s'; sparse-checkout may not work correctly"
msgstr "无法将 '%s' 复制至 '%s'；稀疏检出可能无法正确工作"

#: builtin/worktree.c
#, c-format
msgid "failed to copy worktree config from '%s' to '%s'"
msgstr "无法把工作树配置从 '%s' 拷贝到 '%s'"

#: builtin/worktree.c
#, c-format
msgid "failed to unset '%s' in '%s'"
msgstr "无法在 '%2$s' 中取消配置 '%1$s'"

#: builtin/worktree.c
#, c-format
msgid "could not create directory of '%s'"
msgstr "不能创建目录 '%s'"

#: builtin/worktree.c
msgid "initializing"
msgstr "初始化"

#: builtin/worktree.c
#, c-format
msgid "could not find created worktree '%s'"
msgstr "无法找到已创建的工作树 '%s'"

#: builtin/worktree.c
#, c-format
msgid "Preparing worktree (new branch '%s')"
msgstr "准备工作区（新分支 '%s'）"

#: builtin/worktree.c
#, c-format
msgid "Preparing worktree (resetting branch '%s'; was at %s)"
msgstr "准备工作区（重置分支 '%s'，之前为 %s）"

#: builtin/worktree.c
#, c-format
msgid "Preparing worktree (checking out '%s')"
msgstr "准备工作区（检出 '%s'）"

#: builtin/worktree.c
#, c-format
msgid "unreachable: invalid reference: %s"
msgstr "不可达：无效引用：%s"

#: builtin/worktree.c
#, c-format
msgid "Preparing worktree (detached HEAD %s)"
msgstr "准备工作区（分离头指针 %s）"

#: builtin/worktree.c
#, c-format
msgid ""
"HEAD points to an invalid (or orphaned) reference.\n"
"HEAD path: '%s'\n"
"HEAD contents: '%s'"
msgstr ""
"HEAD 指向了一个无用的（或孤立的）引用。\n"
"HEAD 路径： '%s'\n"
"HEAD 内容： '%s'"

#: builtin/worktree.c
msgid ""
"No local or remote refs exist despite at least one remote\n"
"present, stopping; use 'add -f' to override or fetch a remote first"
msgstr ""
"尽管已配置远程仓库，但不存在任何本地的或远程的引用，操作终止。\n"
"请先使用 'add -f' 来覆盖或拉取一个远程仓库"

#: builtin/worktree.c
msgid "checkout <branch> even if already checked out in other worktree"
msgstr "检出 <分支>，即使已经被检出到其它工作区"

#: builtin/worktree.c
msgid "create a new branch"
msgstr "创建一个新分支"

#: builtin/worktree.c
msgid "create or reset a branch"
msgstr "创建或重置一个分支"

#: builtin/worktree.c
msgid "create unborn branch"
msgstr "创建一个尚未诞生的分支"

#: builtin/worktree.c
msgid "populate the new working tree"
msgstr "生成新的工作区"

#: builtin/worktree.c
msgid "keep the new working tree locked"
msgstr "锁定新工作区"

#: builtin/worktree.c
msgid "reason for locking"
msgstr "锁定原因"

#: builtin/worktree.c
msgid "set up tracking mode (see git-branch(1))"
msgstr "设置跟踪模式（参见 git-branch(1)）"

#: builtin/worktree.c
msgid "try to match the new branch name with a remote-tracking branch"
msgstr "尝试为新分支名匹配一个远程跟踪分支"

#: builtin/worktree.c
msgid "use relative paths for worktrees"
msgstr "对工作区使用相对路径"

#: builtin/worktree.c diff.c parse-options.c
#, c-format
msgid "options '%s', '%s', and '%s' cannot be used together"
msgstr "选项 '%s'、'%s' 和 '%s' 不能同时使用"

#: builtin/worktree.c
#, c-format
msgid "option '%s' and commit-ish cannot be used together"
msgstr "选项 '%s' 和提交号不能同时使用"

#: builtin/worktree.c
msgid "added with --lock"
msgstr "由 --lock 添加"

#: builtin/worktree.c
msgid "--[no-]track can only be used if a new branch is created"
msgstr "只能在创建新分支时使用选项 --[no-]track "

#: builtin/worktree.c
msgid "show extended annotations and reasons, if available"
msgstr "显示扩展的注释和原因（如果有）"

#: builtin/worktree.c
msgid "add 'prunable' annotation to worktrees older than <time>"
msgstr "向早于 <时间> 的工作区添添加“可修剪”注释"

#: builtin/worktree.c
msgid "terminate records with a NUL character"
msgstr "使用 NUL 字符终结记录"

#: builtin/worktree.c
#, c-format
msgid "'%s' is not a working tree"
msgstr "'%s' 不是一个工作区"

#: builtin/worktree.c
msgid "The main working tree cannot be locked or unlocked"
msgstr "主工作区无法被加锁或解锁"

#: builtin/worktree.c
#, c-format
msgid "'%s' is already locked, reason: %s"
msgstr "'%s' 已被锁定，原因：%s"

#: builtin/worktree.c
#, c-format
msgid "'%s' is already locked"
msgstr "'%s' 已被锁定"

#: builtin/worktree.c
#, c-format
msgid "'%s' is not locked"
msgstr "'%s' 未被锁定"

#: builtin/worktree.c
msgid "working trees containing submodules cannot be moved or removed"
msgstr "不能移动或删除包含子模组的工作区"

#: builtin/worktree.c
msgid "force move even if worktree is dirty or locked"
msgstr "强制移动，即使工作区是脏的或已锁定"

#: builtin/worktree.c
#, c-format
msgid "'%s' is a main working tree"
msgstr "'%s' 是一个主工作区"

#: builtin/worktree.c
#, c-format
msgid "could not figure out destination name from '%s'"
msgstr "无法从 '%s' 算出目标名称"

#: builtin/worktree.c
#, c-format
msgid ""
"cannot move a locked working tree, lock reason: %s\n"
"use 'move -f -f' to override or unlock first"
msgstr ""
"无法移动一个锁定的工作区，锁定原因：%s\n"
"使用 'move -f -f' 覆盖或先解锁"

#: builtin/worktree.c
msgid ""
"cannot move a locked working tree;\n"
"use 'move -f -f' to override or unlock first"
msgstr ""
"无法移动一个锁定的工作区，\n"
"使用 'move -f -f' 覆盖或先解锁"

#: builtin/worktree.c
#, c-format
msgid "validation failed, cannot move working tree: %s"
msgstr "验证失败，无法移动工作区：%s"

#: builtin/worktree.c
#, c-format
msgid "failed to move '%s' to '%s'"
msgstr "无法移动 '%s' 到 '%s'"

#: builtin/worktree.c
#, c-format
msgid "failed to run 'git status' on '%s'"
msgstr "无法在 '%s' 中执行 'git status'"

#: builtin/worktree.c
#, c-format
msgid "'%s' contains modified or untracked files, use --force to delete it"
msgstr "'%s' 包含修改或未跟踪的文件，使用 --force 删除"

#: builtin/worktree.c
#, c-format
msgid "failed to run 'git status' on '%s', code %d"
msgstr "无法在 '%s' 中执行 'git status'，退出码 %d"

#: builtin/worktree.c
msgid "force removal even if worktree is dirty or locked"
msgstr "强制删除，即使工作区是脏的或已锁定"

#: builtin/worktree.c
#, c-format
msgid ""
"cannot remove a locked working tree, lock reason: %s\n"
"use 'remove -f -f' to override or unlock first"
msgstr ""
"无法删除一个锁定的工作区，锁定原因：%s\n"
"使用 'remove -f -f' 覆盖或先解锁"

#: builtin/worktree.c
msgid ""
"cannot remove a locked working tree;\n"
"use 'remove -f -f' to override or unlock first"
msgstr ""
"无法删除一个锁定的工作区，\n"
"使用 'remove -f -f' 覆盖或先解锁"

#: builtin/worktree.c
#, c-format
msgid "validation failed, cannot remove working tree: %s"
msgstr "验证失败，无法删除工作区：%s"

#: builtin/worktree.c
#, c-format
msgid "repair: %s: %s"
msgstr "修理：%s：%s"

#: builtin/worktree.c
#, c-format
msgid "error: %s: %s"
msgstr "错误：%s：%s"

#: builtin/write-tree.c
msgid "git write-tree [--missing-ok] [--prefix=<prefix>/]"
msgstr "git write-tree [--missing-ok] [--prefix=<前缀>/]"

#: builtin/write-tree.c
msgid "<prefix>/"
msgstr "<前缀>/"

#: builtin/write-tree.c
msgid "write tree object for a subdirectory <prefix>"
msgstr "将 <前缀> 子目录内容写到一个树对象"

#: builtin/write-tree.c
msgid "only useful for debugging"
msgstr "只对调试有用"

#: bulk-checkin.c
msgid "core.fsyncMethod = batch is unsupported on this platform"
msgstr "core.fsyncMethod = batch 不支持本平台"

#: bundle-uri.c
#, c-format
msgid "could not parse bundle list key %s with value '%s'"
msgstr "不能解析归档包列表键 %s 的值 '%s'"

#: bundle-uri.c
#, c-format
msgid "bundle list at '%s' has no mode"
msgstr "在 '%s' 的归档包列表没有模式"

#: bundle-uri.c
msgid "failed to create temporary file"
msgstr "无法创建临时文件"

#: bundle-uri.c
msgid "insufficient capabilities"
msgstr "缺乏能力"

#: bundle-uri.c
#, c-format
msgid "file downloaded from '%s' is not a bundle"
msgstr "下载自 '%s' 的文件不是归档包"

#: bundle-uri.c
msgid "failed to store maximum creation token"
msgstr "无法储存最大的创建令牌"

#: bundle-uri.c
#, c-format
msgid "unrecognized bundle mode from URI '%s'"
msgstr "不可辨认的归档包模式来自 URI '%s'"

#: bundle-uri.c
#, c-format
msgid "exceeded bundle URI recursion limit (%d)"
msgstr "超过了 URI 递归限制 (%d)"

#: bundle-uri.c
#, c-format
msgid "failed to download bundle from URI '%s'"
msgstr "无法从 URI '%s' 下载归档包"

#: bundle-uri.c
#, c-format
msgid "file at URI '%s' is not a bundle or bundle list"
msgstr "位于 URI '%s' 的文件不是归档包或归档包列表"

#: bundle-uri.c
#, c-format
msgid "bundle-uri: unexpected argument: '%s'"
msgstr "bundle-uri: 意外的参数：'%s'"

#: bundle-uri.c
msgid "bundle-uri: expected flush after arguments"
msgstr "bundle-uri: 在参数之后应有一个 flush"

#: bundle-uri.c
msgid "bundle-uri: got an empty line"
msgstr "bundle-uri: 获得了空行"

#: bundle-uri.c
msgid "bundle-uri: line is not of the form 'key=value'"
msgstr "bundle-uri: 行不是以 'key=value' 格式"

#: bundle-uri.c
msgid "bundle-uri: line has empty key or value"
msgstr "bundle-uri: 行有空的键或值"

#: bundle.c
#, c-format
msgid "unrecognized bundle hash algorithm: %s"
msgstr "未能识别的归档包哈希算法：%s"

#: bundle.c
#, c-format
msgid "unknown capability '%s'"
msgstr "未知能力 '%s'"

#: bundle.c
#, c-format
msgid "'%s' does not look like a v2 or v3 bundle file"
msgstr "'%s' 不像是一个 v2 或 v3 版本的归档包文件"

#: bundle.c
#, c-format
msgid "unrecognized header: %s%s (%d)"
msgstr "未能识别的包头：%s%s (%d)"

#: bundle.c
msgid "Repository lacks these prerequisite commits:"
msgstr "仓库中缺少这些必备的提交："

#: bundle.c
msgid ""
"some prerequisite commits exist in the object store, but are not connected "
"to the repository's history"
msgstr "一些前置提交存在于对象储存中，但未连接于本仓库的历史"

#: bundle.c
#, c-format
msgid "The bundle contains this ref:"
msgid_plural "The bundle contains these %<PRIuMAX> refs:"
msgstr[0] "这个归档包中含有这个引用："
msgstr[1] "这个归档包中含有 %<PRIuMAX> 个引用："

#: bundle.c
msgid "The bundle records a complete history."
msgstr "这个归档包记录一个完整历史。"

#: bundle.c
#, c-format
msgid "The bundle requires this ref:"
msgid_plural "The bundle requires these %<PRIuMAX> refs:"
msgstr[0] "这个归档包需要这个引用："
msgstr[1] "这个归档包需要 %<PRIuMAX> 个引用："

#: bundle.c
#, c-format
msgid "The bundle uses this hash algorithm: %s"
msgstr "该归档包使用的哈希算法：%s"

#: bundle.c
#, c-format
msgid "The bundle uses this filter: %s"
msgstr "归档包使用了过滤器：%s"

#: bundle.c
msgid "unable to dup bundle descriptor"
msgstr "无法复制归档包描述符"

#: bundle.c
msgid "Could not spawn pack-objects"
msgstr "不能生成 pack-objects 进程"

#: bundle.c
msgid "pack-objects died"
msgstr "pack-objects 终止"

#: bundle.c
#, c-format
msgid "ref '%s' is excluded by the rev-list options"
msgstr "引用 '%s' 被 rev-list 选项排除"

#: bundle.c
#, c-format
msgid "unsupported bundle version %d"
msgstr "不支持的归档包版本 %d"

#: bundle.c
#, c-format
msgid "cannot write bundle version %d with algorithm %s"
msgstr "不能写入，归档包版本 %d 不支持算法 %s"

#: bundle.c
msgid "Refusing to create empty bundle."
msgstr "不能创建空的归档包。"

#: bundle.c
#, c-format
msgid "cannot create '%s'"
msgstr "不能创建 '%s'"

#: bundle.c
msgid "index-pack died"
msgstr "index-pack 终止"

#: cache-tree.c
#, c-format
msgid "directory '%s' is present in index, but not sparse"
msgstr "目录 '%s' 存在于索引中，但不是稀疏的"

#: cache-tree.c unpack-trees.c
msgid "corrupted cache-tree has entries not present in index"
msgstr "损坏的缓存树包含索引中不存在的条目"

#: cache-tree.c
#, c-format
msgid "%s with flags 0x%x should not be in cache-tree"
msgstr "标志位为 0x%2$x 的 %1$s 不应位于缓存树中"

#: cache-tree.c
#, c-format
msgid "bad subtree '%.*s'"
msgstr "损坏的子树 '%.*s'"

#: cache-tree.c
#, c-format
msgid "cache-tree for path %.*s does not match. Expected %s got %s"
msgstr "路径 %.*s 的缓存树不匹配。预期为 %s，实际为 %s"

#: chunk-format.c
msgid "terminating chunk id appears earlier than expected"
msgstr "终止块 ID 比预期更早出现"

#: chunk-format.c
#, c-format
msgid "chunk id %<PRIx32> not %d-byte aligned"
msgstr "块 id %<PRIx32> 未 %d 字节对齐"

#: chunk-format.c
#, c-format
msgid "improper chunk offset(s) %<PRIx64> and %<PRIx64>"
msgstr "不正确的块偏移 %<PRIx64> 和 %<PRIx64>"

#: chunk-format.c
#, c-format
msgid "duplicate chunk ID %<PRIx32> found"
msgstr "发现重复的块ID %<PRIx32>"

#: chunk-format.c
#, c-format
msgid "final chunk has non-zero id %<PRIx32>"
msgstr "最终块有非零 ID %<PRIx32>"

#: chunk-format.c
msgid "invalid hash version"
msgstr "无效的哈希版本"

#: color.c
#, c-format
msgid "invalid color value: %.*s"
msgstr "无效的颜色值：%.*s"

#: command-list.h
msgid "Add file contents to the index"
msgstr "添加文件内容至索引"

#: command-list.h
msgid "Apply a series of patches from a mailbox"
msgstr "应用邮箱格式的系列补丁"

#: command-list.h
msgid "Annotate file lines with commit information"
msgstr "使用提交信息注释文件行"

#: command-list.h
msgid "Apply a patch to files and/or to the index"
msgstr "应用一个补丁到文件和/或索引区"

#: command-list.h
msgid "Import a GNU Arch repository into Git"
msgstr "将一个 GNU Arch 仓库导入到 Git"

#: command-list.h
msgid "Create an archive of files from a named tree"
msgstr "基于一个指定的树创建文件存档"

#: command-list.h
msgid "Download missing objects in a partial clone"
msgstr "下载部分克隆中缺失的对象"

#: command-list.h
msgid "Use binary search to find the commit that introduced a bug"
msgstr "通过二分查找定位引入 bug 的提交"

#: command-list.h
msgid "Show what revision and author last modified each line of a file"
msgstr "显示文件每一行最后修改的版本和修改者"

#: command-list.h
msgid "List, create, or delete branches"
msgstr "列出、创建或删除分支"

#: command-list.h
msgid "Collect information for user to file a bug report"
msgstr "收集信息以供用户提交错误报告"

#: command-list.h
msgid "Move objects and refs by archive"
msgstr "通过归档移动对象和引用"

#: command-list.h
msgid "Provide contents or details of repository objects"
msgstr "提供仓库对象的内容或详情"

#: command-list.h
msgid "Display gitattributes information"
msgstr "显示 gitattributes 信息"

#: command-list.h
msgid "Debug gitignore / exclude files"
msgstr "调试 gitignore / exclude 文件"

#: command-list.h
msgid "Show canonical names and email addresses of contacts"
msgstr "显示联系人的规范名称和电子邮件"

#: command-list.h
msgid "Ensures that a reference name is well formed"
msgstr "确保引用名称格式正确"

#: command-list.h
msgid "Switch branches or restore working tree files"
msgstr "切换分支或恢复工作区文件"

#: command-list.h
msgid "Copy files from the index to the working tree"
msgstr "从索引拷贝文件到工作区"

#: command-list.h
msgid "Find commits yet to be applied to upstream"
msgstr "查找尚未应用到上游的提交"

#: command-list.h
msgid "Apply the changes introduced by some existing commits"
msgstr "应用一些现存提交引入的修改"

#: command-list.h
msgid "Graphical alternative to git-commit"
msgstr "git-commit 的图形替代界面"

#: command-list.h
msgid "Remove untracked files from the working tree"
msgstr "从工作区中删除未跟踪文件"

#: command-list.h
msgid "Clone a repository into a new directory"
msgstr "克隆仓库到一个新目录"

#: command-list.h
msgid "Display data in columns"
msgstr "以列的方式显示数据"

#: command-list.h
msgid "Record changes to the repository"
msgstr "记录变更到仓库"

#: command-list.h
msgid "Write and verify Git commit-graph files"
msgstr "写入和校验 Git 提交图文件"

#: command-list.h
msgid "Create a new commit object"
msgstr "创建一个新的提交对象"

#: command-list.h
msgid "Get and set repository or global options"
msgstr "获取和设置仓库或者全局选项"

#: command-list.h
msgid "Count unpacked number of objects and their disk consumption"
msgstr "计算未打包对象的数量和磁盘空间占用"

#: command-list.h
msgid "Retrieve and store user credentials"
msgstr "检索和存储用户密码"

#: command-list.h
msgid "Helper to temporarily store passwords in memory"
msgstr "在内存中临时存储密码的助手"

#: command-list.h
msgid "Helper to store credentials on disk"
msgstr "在磁盘存储密码的助手"

#: command-list.h
msgid "Export a single commit to a CVS checkout"
msgstr "将一个提交导出到 CVS 检出中"

#: command-list.h
msgid "Salvage your data out of another SCM people love to hate"
msgstr "从另外一个人们爱恨的配置管理系统中拯救您的数据"

#: command-list.h
msgid "A CVS server emulator for Git"
msgstr "Git 的一个 CVS 服务模拟器"

#: command-list.h
msgid "A really simple server for Git repositories"
msgstr "一个非常简单的 Git 仓库服务器"

#: command-list.h
msgid "Give an object a human readable name based on an available ref"
msgstr "基于一个现存的引用为一个对象起一个可读的名称"

#: command-list.h
msgid "Generate a zip archive of diagnostic information"
msgstr "生成诊断信息的压缩包"

#: command-list.h
msgid "Show changes between commits, commit and working tree, etc"
msgstr "显示提交之间、提交和工作区之间等的差异"

#: command-list.h
msgid "Compares files in the working tree and the index"
msgstr "比较工作区和索引区中的文件"

#: command-list.h
msgid "Compare a tree to the working tree or index"
msgstr "将一个树和工作区或索引做比较"

#: command-list.h
msgid "Compares the content and mode of blobs found via two tree objects"
msgstr "比较两个树对象的文件内容和模式"

#: command-list.h
msgid "Show changes using common diff tools"
msgstr "使用常见的差异工具显示更改"

#: command-list.h
msgid "Git data exporter"
msgstr "Git 数据导出器"

#: command-list.h
msgid "Backend for fast Git data importers"
msgstr "Git 快速数据导入器后端"

#: command-list.h
msgid "Download objects and refs from another repository"
msgstr "从另外一个仓库下载对象和引用"

#: command-list.h
msgid "Receive missing objects from another repository"
msgstr "从另一个仓库获取缺失的对象"

#: command-list.h
msgid "Rewrite branches"
msgstr "重写分支"

#: command-list.h
msgid "Produce a merge commit message"
msgstr "生成一个合并提交信息"

#: command-list.h
msgid "Output information on each ref"
msgstr "对每一个引用输出信息 "

#: command-list.h
msgid "Run a Git command on a list of repositories"
msgstr "在一个仓库列表上运行 Git 命令"

#: command-list.h
msgid "Prepare patches for e-mail submission"
msgstr "准备电子邮件提交的补丁"

#: command-list.h
msgid "Verifies the connectivity and validity of the objects in the database"
msgstr "验证仓库中对象的连通性和有效性"

#: command-list.h
msgid "Cleanup unnecessary files and optimize the local repository"
msgstr "清除不必要的文件和优化本地仓库"

#: command-list.h
msgid "Extract commit ID from an archive created using git-archive"
msgstr "从 git-archive 创建的归档文件中提取提交 ID"

#: command-list.h
msgid "Print lines matching a pattern"
msgstr "输出和模式匹配的行"

#: command-list.h
msgid "A portable graphical interface to Git"
msgstr "一个便携的 Git 图形客户端"

#: command-list.h
msgid "Compute object ID and optionally create an object from a file"
msgstr "从一个文件计算对象 ID，并支持可选地创建一个对象"

#: command-list.h
msgid "Display help information about Git"
msgstr "显示 Git 的帮助信息"

#: command-list.h
msgid "Run git hooks"
msgstr "运行 git 钩子"

#: command-list.h
msgid "Server side implementation of Git over HTTP"
msgstr "Git HTTP 协议的服务端实现"

#: command-list.h
msgid "Download from a remote Git repository via HTTP"
msgstr "通过 HTTP 从远程 Git 仓库下载"

#: command-list.h
msgid "Push objects over HTTP/DAV to another repository"
msgstr "通过 HTTP/DAV 推送对象另一个仓库"

#: command-list.h
msgid "Send a collection of patches from stdin to an IMAP folder"
msgstr "从标准输入将一组补丁发送到IMAP文件夹"

#: command-list.h
msgid "Build pack index file for an existing packed archive"
msgstr "从一个现存的包存档文件创建包索引"

#: command-list.h
msgid "Create an empty Git repository or reinitialize an existing one"
msgstr "创建一个空的 Git 仓库或重新初始化一个已存在的仓库"

#: command-list.h
msgid "Instantly browse your working repository in gitweb"
msgstr "在 gitweb 中即时浏览您的工作仓库"

#: command-list.h
msgid "Add or parse structured information in commit messages"
msgstr "添加或解析提交说明中的结构化信息"

#: command-list.h
msgid "Show commit logs"
msgstr "显示提交日志"

#: command-list.h
msgid "Show information about files in the index and the working tree"
msgstr "显示索引和工作区中文件的信息"

#: command-list.h
msgid "List references in a remote repository"
msgstr "显示一个远程仓库的引用"

#: command-list.h
msgid "List the contents of a tree object"
msgstr "显示一个树对象的内容"

#: command-list.h
msgid "Extracts patch and authorship from a single e-mail message"
msgstr "从单个电子邮件中提取补丁和作者身份"

#: command-list.h
msgid "Simple UNIX mbox splitter program"
msgstr "简单的 UNIX mbox 邮箱切分程序"

#: command-list.h
msgid "Run tasks to optimize Git repository data"
msgstr "运行任务以优化仓库数据"

#: command-list.h
msgid "Join two or more development histories together"
msgstr "合并两个或更多开发历史"

#: command-list.h
msgid "Find as good common ancestors as possible for a merge"
msgstr "为了合并查找尽可能好的公共祖先提交"

#: command-list.h
msgid "Run a three-way file merge"
msgstr "运行一个三路文件合并"

#: command-list.h
msgid "Run a merge for files needing merging"
msgstr "对于需要合并的文件执行合并"

#: command-list.h
msgid "The standard helper program to use with git-merge-index"
msgstr "与 git-merge-index 一起使用的标准向导程序"

#: command-list.h
msgid "Perform merge without touching index or working tree"
msgstr "在不触碰索引或工作树情况下应用合并"

#: command-list.h
msgid "Run merge conflict resolution tools to resolve merge conflicts"
msgstr "运行合并冲突解决工具以解决合并冲突"

#: command-list.h
msgid "Creates a tag object with extra validation"
msgstr "创建一个有额外验证的标签对象"

#: command-list.h
msgid "Build a tree-object from ls-tree formatted text"
msgstr "基于 ls-tree 的格式化文本创建一个树对象"

#: command-list.h
msgid "Write and verify multi-pack-indexes"
msgstr "写入和校验多包索引"

#: command-list.h
msgid "Move or rename a file, a directory, or a symlink"
msgstr "移动或重命名一个文件、目录或符号链接"

# 查找给定版本的符号名称
#: command-list.h
msgid "Find symbolic names for given revs"
msgstr "查找给定版本的符号名称"

#: command-list.h
msgid "Add or inspect object notes"
msgstr "添加或检查对象注释"

#: command-list.h
msgid "Import from and submit to Perforce repositories"
msgstr "导入和提交到 Perforce 仓库中"

#: command-list.h
msgid "Create a packed archive of objects"
msgstr "创建对象的存档包"

#: command-list.h
msgid "Find redundant pack files"
msgstr "查找冗余的包文件"

#: command-list.h
msgid "Pack heads and tags for efficient repository access"
msgstr "打包头和标签以实现高效的仓库访问"

#: command-list.h
msgid "Compute unique ID for a patch"
msgstr "计算一个补丁的唯一 ID"

#: command-list.h
msgid "Prune all unreachable objects from the object database"
msgstr "删除对象库中所有不可达对象"

#: command-list.h
msgid "Remove extra objects that are already in pack files"
msgstr "删除已经在包文件中的多余对象"

#: command-list.h
msgid "Fetch from and integrate with another repository or a local branch"
msgstr "获取并整合另外的仓库或一个本地分支"

#: command-list.h
msgid "Update remote refs along with associated objects"
msgstr "更新远程引用和相关的对象"

#: command-list.h
msgid "Applies a quilt patchset onto the current branch"
msgstr "将一个 quilt 补丁集应用到当前分支。"

#: command-list.h
msgid "Compare two commit ranges (e.g. two versions of a branch)"
msgstr "比较两个提交范围（如一个分支的两个版本）"

#: command-list.h
msgid "Reads tree information into the index"
msgstr "将树信息读取到索引"

#: command-list.h
msgid "Reapply commits on top of another base tip"
msgstr "在另一个分支上重新应用提交"

#: command-list.h
msgid "Receive what is pushed into the repository"
msgstr "接收推送到仓库中的对象"

#: command-list.h
msgid "Manage reflog information"
msgstr "管理 reflog 信息"

#: command-list.h
msgid "Low-level access to refs"
msgstr "对引用的低级访问"

#: command-list.h
msgid "Manage set of tracked repositories"
msgstr "管理已跟踪仓库"

#: command-list.h
msgid "Pack unpacked objects in a repository"
msgstr "打包仓库中未打包对象"

#: command-list.h
msgid "Create, list, delete refs to replace objects"
msgstr "创建、列出、删除对象替换引用"

#: command-list.h
msgid "EXPERIMENTAL: Replay commits on a new base, works with bare repos too"
msgstr "试验中：基于一个新基线重放提交，同样适用于纯仓库"

#: command-list.h
msgid "Generates a summary of pending changes"
msgstr "生成待定更改的摘要"

#: command-list.h
msgid "Reuse recorded resolution of conflicted merges"
msgstr "重用冲突合并的解决方案记录"

#: command-list.h
msgid "Reset current HEAD to the specified state"
msgstr "重置当前 HEAD 到指定状态"

#: command-list.h
msgid "Restore working tree files"
msgstr "恢复工作区文件"

#: command-list.h
msgid "Lists commit objects in reverse chronological order"
msgstr "按时间顺序列出提交对象"

#: command-list.h
msgid "Pick out and massage parameters"
msgstr "选出并处理参数"

#: command-list.h
msgid "Revert some existing commits"
msgstr "回退一些现存提交"

#: command-list.h
msgid "Remove files from the working tree and from the index"
msgstr "从工作区和索引中删除文件"

#: command-list.h
msgid "Send a collection of patches as emails"
msgstr "通过电子邮件发送一组补丁"

#: command-list.h
msgid "Push objects over Git protocol to another repository"
msgstr "使用 Git 协议推送对象到另一个仓库"

#: command-list.h
msgid "Git's i18n setup code for shell scripts"
msgstr "为 shell 脚本准备的 Git 国际化设置代码"

#: command-list.h
msgid "Common Git shell script setup code"
msgstr "常用的 Git shell 脚本设置代码"

#: command-list.h
msgid "Restricted login shell for Git-only SSH access"
msgstr "只允许 Git SSH 访问的受限登录shell"

#: command-list.h
msgid "Summarize 'git log' output"
msgstr "'git log' 输出摘要"

#: command-list.h
msgid "Show various types of objects"
msgstr "显示各种类型的对象"

#: command-list.h
msgid "Show branches and their commits"
msgstr "显示分支和提交"

#: command-list.h
msgid "Show packed archive index"
msgstr "显示打包归档索引"

#: command-list.h
msgid "List references in a local repository"
msgstr "显示本地仓库中的引用"

#  译者：中文字符串拼接，可删除前导空格
#: command-list.h
msgid "Reduce your working tree to a subset of tracked files"
msgstr "将您的工作树缩减至已追踪文件的子集"

#: command-list.h
msgid "Add file contents to the staging area"
msgstr "将文件内容添加到暂存区"

#: command-list.h
msgid "Stash the changes in a dirty working directory away"
msgstr "贮藏脏工作区中的修改"

#: command-list.h
msgid "Show the working tree status"
msgstr "显示工作区状态"

#: command-list.h
msgid "Remove unnecessary whitespace"
msgstr "删除不必要的空白字符"

#: command-list.h
msgid "Initialize, update or inspect submodules"
msgstr "初始化、更新或检查子模组"

#: command-list.h
msgid "Bidirectional operation between a Subversion repository and Git"
msgstr "Subersion 仓库和 Git 之间的双向操作"

#: command-list.h
msgid "Switch branches"
msgstr "切换分支"

#: command-list.h
msgid "Read, modify and delete symbolic refs"
msgstr "读取、修改和删除符号引用"

#: command-list.h
msgid "Create, list, delete or verify a tag object signed with GPG"
msgstr "创建、列出、删除或校验一个 GPG 签名的标签对象"

#: command-list.h
msgid "Creates a temporary file with a blob's contents"
msgstr "用 blob 数据对象的内容创建一个临时文件"

#: command-list.h
msgid "Unpack objects from a packed archive"
msgstr "从打包文件中解压缩对象"

#: command-list.h
msgid "Register file contents in the working tree to the index"
msgstr "将工作区的文件内容注册到索引"

#: command-list.h
msgid "Update the object name stored in a ref safely"
msgstr "安全地更新存储于引用中的对象名称"

#: command-list.h
msgid "Update auxiliary info file to help dumb servers"
msgstr "更新辅助信息文件以帮助哑协议服务"

#: command-list.h
msgid "Send archive back to git-archive"
msgstr "将存档发送回 git-archive"

#: command-list.h
msgid "Send objects packed back to git-fetch-pack"
msgstr "将对象压缩包发送回 git-fetch-pack"

#: command-list.h
msgid "Show a Git logical variable"
msgstr "显示一个Git逻辑变量"

#: command-list.h
msgid "Check the GPG signature of commits"
msgstr "检查 GPG 提交签名"

#: command-list.h
msgid "Validate packed Git archive files"
msgstr "校验打包的Git存仓文件"

#: command-list.h
msgid "Check the GPG signature of tags"
msgstr "检查标签的 GPG 签名"

#: command-list.h
msgid "Display version information about Git"
msgstr "显示关于 Git 的版本信息"

#: command-list.h
msgid "Show logs with differences each commit introduces"
msgstr "显示每一个提交引入的差异日志"

#: command-list.h
msgid "Manage multiple working trees"
msgstr "管理多个工作区"

#: command-list.h
msgid "Create a tree object from the current index"
msgstr "从当前索引创建一个树对象"

#: command-list.h
msgid "Defining attributes per path"
msgstr "定义路径的属性"

#: command-list.h
msgid "Git command-line interface and conventions"
msgstr "Git 命令行界面和约定"

#: command-list.h
msgid "A Git core tutorial for developers"
msgstr "面向开发人员的 Git 核心教程"

#: command-list.h
msgid "Providing usernames and passwords to Git"
msgstr "为 Git 提供用户名和口令"

#: command-list.h
msgid "Git for CVS users"
msgstr "适合 CVS 用户的 Git 帮助"

#: command-list.h
msgid "Tweaking diff output"
msgstr "调整差异输出"

#: command-list.h
msgid "A useful minimum set of commands for Everyday Git"
msgstr "每一天 Git 的一组有用的最小命令集合"

#: command-list.h
msgid "Frequently asked questions about using Git"
msgstr "关于使用 Git 的常见问题"

#: command-list.h
msgid "The bundle file format"
msgstr "归档包文件格式"

#: command-list.h
msgid "Chunk-based file formats"
msgstr "块式文件格式"

#: command-list.h
msgid "Git commit-graph format"
msgstr "Git 提交图格式"

#: command-list.h
msgid "Git index format"
msgstr "Git 索引格式"

#: command-list.h
msgid "Git pack format"
msgstr "Git 包格式"

#: command-list.h
msgid "Git cryptographic signature formats"
msgstr "Git 密码学签名格式"

#: command-list.h
msgid "A Git Glossary"
msgstr "Git 词汇表"

#: command-list.h
msgid "Hooks used by Git"
msgstr "Git 使用的钩子"

#: command-list.h
msgid "Specifies intentionally untracked files to ignore"
msgstr "指定故意忽略的未跟踪文件"

#: command-list.h
msgid "The Git repository browser"
msgstr "Git 仓库浏览器"

#: command-list.h
msgid "Map author/committer names and/or E-Mail addresses"
msgstr "映射作者/提交者的名称和/或邮件地址"

#: command-list.h
msgid "Defining submodule properties"
msgstr "定义子模组属性"

#: command-list.h
msgid "Git namespaces"
msgstr "Git 名字空间"

#: command-list.h
msgid "Protocol v0 and v1 capabilities"
msgstr "协议 v0 和 v1 能力"

#: command-list.h
msgid "Things common to various protocols"
msgstr "不同协议的共同部分"

#: command-list.h
msgid "Git HTTP-based protocols"
msgstr "Git 基于 HTTP 的协议"

#: command-list.h
msgid "How packs are transferred over-the-wire"
msgstr "包在线路中传输的方式"

#: command-list.h
msgid "Git Wire Protocol, Version 2"
msgstr "Git 传输协议，第二版"

#: command-list.h
msgid "Helper programs to interact with remote repositories"
msgstr "与远程仓库交互的助手程序"

#: command-list.h
msgid "Git Repository Layout"
msgstr "Git 仓库布局"

#: command-list.h
msgid "Specifying revisions and ranges for Git"
msgstr "指定 Git 的版本和版本范围"

#: command-list.h
msgid "Mounting one repository inside another"
msgstr "将一个仓库安装到另外一个仓库中"

#: command-list.h
msgid "A tutorial introduction to Git"
msgstr "Git 入门教程"

#: command-list.h
msgid "A tutorial introduction to Git: part two"
msgstr "Git 入门教程：第二部分"

#: command-list.h
msgid "Git web interface (web frontend to Git repositories)"
msgstr "Git web 界面（Git 仓库的 web 前端）"

#: command-list.h
msgid "An overview of recommended workflows with Git"
msgstr "Git 推荐的工作流概览"

#: command-list.h
msgid "A tool for managing large Git repositories"
msgstr "一个管理大型 Git 仓库的工具"

#: commit-graph.c
msgid "commit-graph file is too small"
msgstr "提交图文件太小"

#: commit-graph.c
msgid "commit-graph oid fanout chunk is wrong size"
msgstr "提交图中对象 ID 的扇出块大小错误"

#: commit-graph.c
msgid "commit-graph fanout values out of order"
msgstr "提交图的扇出值失序"

#: commit-graph.c
msgid "commit-graph OID lookup chunk is the wrong size"
msgstr "提交图的对象 ID 查询块大小错误"

#: commit-graph.c
msgid "commit-graph commit data chunk is wrong size"
msgstr "提交图的提交数据块大小错误"

#: commit-graph.c
msgid "commit-graph generations chunk is wrong size"
msgstr "提交图的世代块大小错误"

#: commit-graph.c
msgid "commit-graph changed-path index chunk is too small"
msgstr "提交图的变更路径的索引块太小"

#: commit-graph.c
#, c-format
msgid ""
"ignoring too-small changed-path chunk (%<PRIuMAX> < %<PRIuMAX>) in commit-"
"graph file"
msgstr "忽略提交图文件中过小的更改路径块（%<PRIuMAX> < %<PRIuMAX>）"

#: commit-graph.c
#, c-format
msgid "commit-graph signature %X does not match signature %X"
msgstr "提交图签名 %X 和签名 %X 不匹配"

#: commit-graph.c
#, c-format
msgid "commit-graph version %X does not match version %X"
msgstr "提交图版本 %X 和版本 %X 不匹配"

#: commit-graph.c
#, c-format
msgid "commit-graph hash version %X does not match version %X"
msgstr "提交图哈希版本 %X 和版本 %X 不匹配"

#: commit-graph.c
#, c-format
msgid "commit-graph file is too small to hold %u chunks"
msgstr "提交图文件太小，容不下 %u 个块"

#: commit-graph.c
msgid "commit-graph required OID fanout chunk missing or corrupted"
msgstr "提交图所需的对象 ID 扇出块缺失或损坏"

#: commit-graph.c
msgid "commit-graph required OID lookup chunk missing or corrupted"
msgstr "提交图所需的对象 ID 查询块缺失或损坏"

#: commit-graph.c
msgid "commit-graph required commit data chunk missing or corrupted"
msgstr "提交图所需的提交数据块缺失或损坏"

#: commit-graph.c
#, c-format
msgid ""
"disabling Bloom filters for commit-graph layer '%s' due to incompatible "
"settings"
msgstr "由于不兼容的设置，正在禁用提交图层 '%s' 的布隆过滤器"

#: commit-graph.c
msgid "commit-graph has no base graphs chunk"
msgstr "提交图没有基础图形块"

#: commit-graph.c
msgid "commit-graph base graphs chunk is too small"
msgstr "提交图的基础图形块过小"

#: commit-graph.c
msgid "commit-graph chain does not match"
msgstr "提交图链不匹配"

#: commit-graph.c
#, c-format
msgid "commit count in base graph too high: %<PRIuMAX>"
msgstr "基础图形中的提交数量过高：%<PRIuMAX>"

#: commit-graph.c
msgid "commit-graph chain file too small"
msgstr "提交图链文件太小"

#: commit-graph.c
#, c-format
msgid "invalid commit-graph chain: line '%s' not a hash"
msgstr "无效的提交图链：行 '%s' 不是一个哈希值"

#: commit-graph.c
msgid "unable to find all commit-graph files"
msgstr "无法找到所有提交图文件"

#: commit-graph.c
msgid "invalid commit position. commit-graph is likely corrupt"
msgstr "无效的提交位置。提交图可能已损坏"

#: commit-graph.c
#, c-format
msgid "could not find commit %s"
msgstr "无法找到提交 %s"

#: commit-graph.c
msgid "commit-graph requires overflow generation data but has none"
msgstr "提交图需要溢出世代数据，但是没有"

#: commit-graph.c
msgid "commit-graph overflow generation data is too small"
msgstr "提交图溢出世代数据过小"

#: commit-graph.c
msgid "commit-graph extra-edges pointer out of bounds"
msgstr "提交图额外边的指针越界"

#: commit-graph.c
msgid "Loading known commits in commit graph"
msgstr "正在加载提交图中的已知提交"

#: commit-graph.c
msgid "Expanding reachable commits in commit graph"
msgstr "正在扩展提交图中的可达提交"

#: commit-graph.c
msgid "Clearing commit marks in commit graph"
msgstr "正在清除提交图中的提交标记"

#: commit-graph.c
msgid "Computing commit graph topological levels"
msgstr "正在计算提交图拓扑级别"

#: commit-graph.c
msgid "Computing commit graph generation numbers"
msgstr "正在计算提交图世代数字"

#: commit-graph.c
msgid "Computing commit changed paths Bloom filters"
msgstr "计算提交变更路径的布隆过滤器"

#: commit-graph.c
msgid "Collecting referenced commits"
msgstr "正在收集引用的提交"

#: commit-graph.c
#, c-format
msgid "Finding commits for commit graph in %<PRIuMAX> pack"
msgid_plural "Finding commits for commit graph in %<PRIuMAX> packs"
msgstr[0] "正在 %<PRIuMAX> 个包中查找提交图的提交"
msgstr[1] "正在 %<PRIuMAX> 个包中查找提交图的提交"

#: commit-graph.c
#, c-format
msgid "error adding pack %s"
msgstr "添加包 %s 出错"

#: commit-graph.c
#, c-format
msgid "error opening index for %s"
msgstr "为 %s 打开索引出错"

#: commit-graph.c
msgid "Finding commits for commit graph among packed objects"
msgstr "正在打包对象中查找提交图的提交"

#: commit-graph.c
msgid "Finding extra edges in commit graph"
msgstr "正在查找提交图中额外的边"

#: commit-graph.c
msgid "failed to write correct number of base graph ids"
msgstr "无法写入正确数量的基础图形 ID"

#: commit-graph.c
msgid "unable to create temporary graph layer"
msgstr "无法创建临时图层"

#: commit-graph.c midx-write.c
#, c-format
msgid "unable to adjust shared permissions for '%s'"
msgstr "无法为 '%s' 调整共享权限"

#: commit-graph.c
#, c-format
msgid "Writing out commit graph in %d pass"
msgid_plural "Writing out commit graph in %d passes"
msgstr[0] "正在用 %d 步写出提交图"
msgstr[1] "正在用 %d 步写出提交图"

#: commit-graph.c
msgid "unable to open commit-graph chain file"
msgstr "无法打开提交图链文件"

#: commit-graph.c
msgid "failed to rename base commit-graph file"
msgstr "无法重命名基础提交图文件"

#: commit-graph.c
msgid "failed to rename temporary commit-graph file"
msgstr "无法重命名临时提交图文件"

#: commit-graph.c
#, c-format
msgid "cannot merge graphs with %<PRIuMAX>, %<PRIuMAX> commits"
msgstr ""
"无法合并提交图，总共已累加提交数：%<PRIuMAX>，当前待累加提交数：%<PRIuMAX>"

#: commit-graph.c
#, c-format
msgid "cannot merge graph %s, too many commits: %<PRIuMAX>"
msgstr "无法合并提交图 %s, 提交过多：%<PRIuMAX>"

#: commit-graph.c
msgid "Scanning merged commits"
msgstr "正在扫描合并提交"

#: commit-graph.c
msgid "Merging commit-graph"
msgstr "正在合并提交图"

#: commit-graph.c
msgid "attempting to write a commit-graph, but 'core.commitGraph' is disabled"
msgstr "正尝试写提交图，但是 'core.commitGraph' 被禁用"

#: commit-graph.c
#, c-format
msgid ""
"attempting to write a commit-graph, but 'commitGraph.changedPathsVersion' "
"(%d) is not supported"
msgstr "尝试写入提交图，但不支持 'commitGraph.changedPathsVersion' (%d)"

#: commit-graph.c
msgid "too many commits to write graph"
msgstr "提交太多不能画图"

#: commit-graph.c
msgid "the commit-graph file has incorrect checksum and is likely corrupt"
msgstr "提交图文件的校验码错误，可能已经损坏"

#: commit-graph.c
#, c-format
msgid "commit-graph has incorrect OID order: %s then %s"
msgstr "提交图的对象 ID 顺序不正确：%s 然后 %s"

#: commit-graph.c
#, c-format
msgid "commit-graph has incorrect fanout value: fanout[%d] = %u != %u"
msgstr "提交图有不正确的扇出值：fanout[%d] = %u != %u"

#: commit-graph.c
#, c-format
msgid "failed to parse commit %s from commit-graph"
msgstr "无法从提交图中解析提交 %s"

#: commit-graph.c
#, c-format
msgid "failed to parse commit %s from object database for commit-graph"
msgstr "无法从提交图的对象库中解析提交 %s"

#: commit-graph.c
#, c-format
msgid "root tree OID for commit %s in commit-graph is %s != %s"
msgstr "提交图中的提交 %s 的根树对象 ID 是 %s != %s"

#: commit-graph.c
#, c-format
msgid "commit-graph parent list for commit %s is too long"
msgstr "提交 %s 的提交图父提交列表太长了"

#: commit-graph.c
#, c-format
msgid "commit-graph parent for %s is %s != %s"
msgstr "%s 的提交图父提交是 %s != %s"

#: commit-graph.c
#, c-format
msgid "commit-graph parent list for commit %s terminates early"
msgstr "提交 %s 的提交图父提交列表过早终止"

#: commit-graph.c
#, c-format
msgid "commit-graph generation for commit %s is %<PRIuMAX> < %<PRIuMAX>"
msgstr "提交图中的提交 %s 的世代号是 %<PRIuMAX> < %<PRIuMAX>"

#: commit-graph.c
#, c-format
msgid "commit date for commit %s in commit-graph is %<PRIuMAX> != %<PRIuMAX>"
msgstr "提交图中提交 %s 的提交日期是 %<PRIuMAX> != %<PRIuMAX>"

#: commit-graph.c
#, c-format
msgid ""
"commit-graph has both zero and non-zero generations (e.g., commits '%s' and "
"'%s')"
msgstr "提交图具有零和非零的世代（例如：提交 '%s' 和 '%s'）"

#: commit-graph.c
msgid "Verifying commits in commit graph"
msgstr "正在校验提交图中的提交"

#: commit-reach.c sequencer.c
#, c-format
msgid "could not parse commit %s"
msgstr "不能解析提交 %s"

#: commit.c
#, c-format
msgid "%s %s is not a commit!"
msgstr "%s %s 不是一个提交！"

#: commit.c
msgid ""
"Support for <GIT_DIR>/info/grafts is deprecated\n"
"and will be removed in a future Git version.\n"
"\n"
"Please use \"git replace --convert-graft-file\"\n"
"to convert the grafts into replace refs.\n"
"\n"
"Turn this message off by running\n"
"\"git config set advice.graftFileDeprecated false\""
msgstr ""
"对 <GIT_DIR>/info/grafts 的支持已过时，并将在\n"
"未来的Git版本中被移除。\n"
"\n"
"请使用 \"git replace --convert-graft-file\" 将\n"
"（提交）移植转换为替换引用。\n"
"\n"
"运行 \"git config set advice.graftFileDeprecated false\"\n"
"可关闭本消息"

#: commit.c
#, c-format
msgid "commit %s exists in commit-graph but not in the object database"
msgstr "提交 %s 存在于提交图中，但不存在于对象数据库中"

#: commit.c
#, c-format
msgid "Commit %s has an untrusted GPG signature, allegedly by %s."
msgstr "提交 %s 有一个非可信的声称来自 %s 的 GPG 签名。"

#: commit.c
#, c-format
msgid "Commit %s has a bad GPG signature allegedly by %s."
msgstr "提交 %s 有一个错误的声称来自 %s 的 GPG 签名。"

#: commit.c
#, c-format
msgid "Commit %s does not have a GPG signature."
msgstr "提交 %s 没有 GPG 签名。"

#: commit.c
#, c-format
msgid "Commit %s has a good GPG signature by %s\n"
msgstr "提交 %s 有一个来自 %s 的好的 GPG 签名。\n"

#: commit.c
msgid ""
"Warning: commit message did not conform to UTF-8.\n"
"You may want to amend it after fixing the message, or set the config\n"
"variable i18n.commitEncoding to the encoding your project uses.\n"
msgstr ""
"警告：提交说明不符合 UTF-8 字符编码。\n"
"您可以通过修补提交来改正提交说明，或者将配置变量 i18n.commitEncoding\n"
"设置为您项目所用的字符编码。\n"

#: compat/compiler.h
msgid "no compiler information available\n"
msgstr "编译器信息不可用\n"

#: compat/compiler.h
msgid "no libc information available\n"
msgstr "libc 信息不可用\n"

#: compat/disk.h
#, c-format
msgid "could not determine free disk size for '%s'"
msgstr "不能确定 '%s' 的空余磁盘空间"

#: compat/disk.h
#, c-format
msgid "could not get info for '%s'"
msgstr "无法获得 '%s' 的信息"

#: compat/fsmonitor/fsm-health-win32.c
#, c-format
msgid "[GLE %ld] health thread could not open '%ls'"
msgstr "[GLE %ld] 健康监测线程不能打开 '%ls'"

#: compat/fsmonitor/fsm-health-win32.c
#, c-format
msgid "[GLE %ld] health thread getting BHFI for '%ls'"
msgstr "[GLE %ld] 健康监测线程正在获取 '%ls' 的 BHFI"

#: compat/fsmonitor/fsm-health-win32.c compat/fsmonitor/fsm-listen-win32.c
#, c-format
msgid "could not convert to wide characters: '%s'"
msgstr "不能转换至宽字符：'%s'"

#: compat/fsmonitor/fsm-health-win32.c
#, c-format
msgid "BHFI changed '%ls'"
msgstr "BHFI 已改变 '%ls'"

#: compat/fsmonitor/fsm-health-win32.c
#, c-format
msgid "unhandled case in 'has_worktree_moved': %d"
msgstr "'has_worktree_moved' 中未处理的情况：%d"

#: compat/fsmonitor/fsm-health-win32.c
#, c-format
msgid "health thread wait failed [GLE %ld]"
msgstr "健康监测线程等待失败 [GLE %ld]"

#: compat/fsmonitor/fsm-ipc-darwin.c
#, c-format
msgid "Invalid path: %s"
msgstr "无效路径： %s"

#: compat/fsmonitor/fsm-listen-darwin.c
msgid "Unable to create FSEventStream."
msgstr "无法创建 FSEventStream。"

#: compat/fsmonitor/fsm-listen-darwin.c
msgid "Failed to start the FSEventStream"
msgstr "无法启动 FSEventStream"

#: compat/fsmonitor/fsm-listen-win32.c
#, c-format
msgid "[GLE %ld] could not convert path to UTF-8: '%.*ls'"
msgstr "[GLE %ld] 无法将路径转换至 UTF-8：'%.*ls'"

#: compat/fsmonitor/fsm-listen-win32.c
#, c-format
msgid "[GLE %ld] could not watch '%s'"
msgstr "[GLE %ld] 无法监视 '%s'"

#: compat/fsmonitor/fsm-listen-win32.c
#, c-format
msgid "[GLE %ld] could not get longname of '%s'"
msgstr "[GLE %ld] 无法获取 '%s' 的长名称"

#: compat/fsmonitor/fsm-listen-win32.c
#, c-format
msgid "ReadDirectoryChangedW failed on '%s' [GLE %ld]"
msgstr "ReadDirectoryChangedW 失败于 '%s' [GLE %ld]"

#: compat/fsmonitor/fsm-listen-win32.c
#, c-format
msgid "GetOverlappedResult failed on '%s' [GLE %ld]"
msgstr "GetOverlappedResult 失败于 '%s' [GLE %ld]"

#: compat/fsmonitor/fsm-listen-win32.c
#, c-format
msgid "could not read directory changes [GLE %ld]"
msgstr "无法获取目录变更 [GLE %ld]"

#: compat/fsmonitor/fsm-path-utils-darwin.c
#, c-format
msgid "opendir('%s') failed"
msgstr "opendir('%s') 失败"

#: compat/fsmonitor/fsm-path-utils-darwin.c
#, c-format
msgid "lstat('%s') failed"
msgstr "lstat('%s') 失败"

#: compat/fsmonitor/fsm-path-utils-darwin.c
#, c-format
msgid "strbuf_readlink('%s') failed"
msgstr "strbuf_readlink('%s') 失败"

#: compat/fsmonitor/fsm-path-utils-darwin.c
#, c-format
msgid "closedir('%s') failed"
msgstr "closedir('%s') 失败"

#: compat/fsmonitor/fsm-path-utils-win32.c
#, c-format
msgid "[GLE %ld] unable to open for read '%ls'"
msgstr "[GLE %ld] 无法打开要读取的 '%ls'"

#: compat/fsmonitor/fsm-path-utils-win32.c
#, c-format
msgid "[GLE %ld] unable to get protocol information for '%ls'"
msgstr "[GLE %ld] 无法获取 '%ls' 的协议信息 "

#: compat/mingw.c
#, c-format
msgid "failed to copy SID (%ld)"
msgstr "无法拷贝 SID (%ld)"

#: compat/mingw.c
#, c-format
msgid "failed to get owner for '%s' (%ld)"
msgstr "无法获取 '%s' 的所有者 (%ld)"

#: compat/obstack.c
msgid "memory exhausted"
msgstr "内存耗尽"

#: compat/regex/regcomp.c
msgid "Success"
msgstr "成功"

#: compat/regex/regcomp.c
msgid "No match"
msgstr "无匹配"

#: compat/regex/regcomp.c
msgid "Invalid regular expression"
msgstr "无效的正则表达式"

#: compat/regex/regcomp.c
msgid "Invalid collation character"
msgstr "无效的集合字符"

#: compat/regex/regcomp.c
msgid "Invalid character class name"
msgstr "无效的字符类名"

#: compat/regex/regcomp.c
msgid "Trailing backslash"
msgstr "末尾的反斜杠"

#: compat/regex/regcomp.c
msgid "Invalid back reference"
msgstr "无效的反向索引"

#: compat/regex/regcomp.c
msgid "Unmatched [ or [^"
msgstr "未匹配的 [ 或 [^"

#: compat/regex/regcomp.c
msgid "Unmatched ( or \\("
msgstr "未匹配的 ( 或 \\("

#: compat/regex/regcomp.c
msgid "Unmatched \\{"
msgstr "未匹配的 \\{"

#: compat/regex/regcomp.c
msgid "Invalid content of \\{\\}"
msgstr "\\{\\} 的内容非法"

#: compat/regex/regcomp.c
msgid "Invalid range end"
msgstr "无效的范围结尾"

#: compat/regex/regcomp.c
msgid "Memory exhausted"
msgstr "内存耗尽"

#: compat/regex/regcomp.c
msgid "Invalid preceding regular expression"
msgstr "非法的前置正则表达式"

#: compat/regex/regcomp.c
msgid "Premature end of regular expression"
msgstr "正则表达式过早结束"

#: compat/regex/regcomp.c
msgid "Regular expression too big"
msgstr "正则表达式太大"

#: compat/regex/regcomp.c
msgid "Unmatched ) or \\)"
msgstr "未匹配的 ) 或 \\)"

#: compat/regex/regcomp.c
msgid "No previous regular expression"
msgstr "没有上一个正则表达式"

#: compat/simple-ipc/ipc-unix-socket.c compat/simple-ipc/ipc-win32.c
msgid "could not send IPC command"
msgstr "无法发送 IPC 命令"

#: compat/simple-ipc/ipc-unix-socket.c compat/simple-ipc/ipc-win32.c
msgid "could not read IPC response"
msgstr "无法读取 IPC 响应"

#: compat/simple-ipc/ipc-unix-socket.c
#, c-format
msgid "could not start accept_thread '%s'"
msgstr "无法启动 accept_thread '%s'"

#: compat/simple-ipc/ipc-unix-socket.c
#, c-format
msgid "could not start worker[0] for '%s'"
msgstr "无法启动 '%s' 的 worker[0]"

#: compat/simple-ipc/ipc-win32.c
#, c-format
msgid "ConnectNamedPipe failed for '%s' (%lu)"
msgstr "ConnectNamedPipe 失败于 '%s' (%lu)"

#: compat/simple-ipc/ipc-win32.c
#, c-format
msgid "could not create fd from pipe for '%s'"
msgstr "无法为 '%s' 从管道创建 fd"

#: compat/simple-ipc/ipc-win32.c
#, c-format
msgid "could not start thread[0] for '%s'"
msgstr "无法为 '%s' 启动 thread[0]"

#: compat/simple-ipc/ipc-win32.c
#, c-format
msgid "wait for hEvent failed for '%s'"
msgstr "为 '%s' 等待 hEvent 失败"

#: compat/terminal.c
msgid "cannot resume in the background, please use 'fg' to resume"
msgstr "无法从后台中恢复，请使用 'fg' 来恢复"

#: compat/terminal.c
msgid "cannot restore terminal settings"
msgstr "无法恢复终端设置"

#: config.c
#, c-format
msgid ""
"exceeded maximum include depth (%d) while including\n"
"\t%s\n"
"from\n"
"\t%s\n"
"This might be due to circular includes."
msgstr ""
"超过了最大包含深度（%1$d），当从\n"
"\t%3$s\n"
"包含\n"
"\t%2$s\n"
"这可能是因为循环包含。"

#: config.c
#, c-format
msgid "could not expand include path '%s'"
msgstr "无法扩展包含路径 '%s'"

#: config.c
msgid "relative config includes must come from files"
msgstr "相对路径的配置文件引用必须来自于文件"

#: config.c
msgid "relative config include conditionals must come from files"
msgstr "相对路径的配置文件条件引用必须来自于文件"

#: config.c
msgid ""
"remote URLs cannot be configured in file directly or indirectly included by "
"includeIf.hasconfig:remote.*.url"
msgstr ""
"远程 URL 不能在文件中配置，不管直接地还是通过 "
"includeIf.hasconfig:remote.*.url 间接地包含。"

#: config.c
#, c-format
msgid "invalid config format: %s"
msgstr "无效的配置格式：%s"

#: config.c
#, c-format
msgid "missing environment variable name for configuration '%.*s'"
msgstr "配置 '%.*s' 缺少环境变量名称"

#: config.c
#, c-format
msgid "missing environment variable '%s' for configuration '%.*s'"
msgstr "缺少环境变量 '%s' 于配置 '%.*s' "

#: config.c
#, c-format
msgid "key does not contain a section: %s"
msgstr "键名没有包含一个小节名称：%s"

#: config.c
#, c-format
msgid "key does not contain variable name: %s"
msgstr "键名没有包含变量名：%s"

#: config.c sequencer.c
#, c-format
msgid "invalid key: %s"
msgstr "无效键名：%s"

#: config.c
#, c-format
msgid "invalid key (newline): %s"
msgstr "无效键名（有换行符）：%s"

#: config.c
msgid "empty config key"
msgstr "空的配置键名"

#: config.c
#, c-format
msgid "bogus config parameter: %s"
msgstr "伪配置参数：%s"

#: config.c
#, c-format
msgid "bogus format in %s"
msgstr "%s 中格式错误"

#: config.c
#, c-format
msgid "bogus count in %s"
msgstr "%s 中错误计数"

#: config.c
#, c-format
msgid "too many entries in %s"
msgstr "%s 中太多的条目"

#: config.c
#, c-format
msgid "missing config key %s"
msgstr "缺失配置键名 %s"

#: config.c
#, c-format
msgid "missing config value %s"
msgstr "缺失配置取值 %s"

#: config.c
#, c-format
msgid "bad config line %d in blob %s"
msgstr "数据对象 %2$s 中错误的配置行 %1$d"

#: config.c
#, c-format
msgid "bad config line %d in file %s"
msgstr "文件 %2$s 中错误的配置行 %1$d"

#: config.c
#, c-format
msgid "bad config line %d in standard input"
msgstr "标准输入中错误的配置行 %d"

#: config.c
#, c-format
msgid "bad config line %d in submodule-blob %s"
msgstr "子模组数据对象 %2$s 中错误的配置行 %1$d"

#: config.c
#, c-format
msgid "bad config line %d in command line %s"
msgstr "命令行 %2$s 中错误的配置行 %1$d"

#: config.c
#, c-format
msgid "bad config line %d in %s"
msgstr "在 %2$s 中错误的配置行 %1$d"

#: config.c
msgid "out of range"
msgstr "超出范围"

#: config.c
msgid "invalid unit"
msgstr "无效的单位"

#: config.c
#, c-format
msgid "bad numeric config value '%s' for '%s': %s"
msgstr "配置变量 '%2$s' 的数字取值 '%1$s' 设置错误：%3$s"

#: config.c
#, c-format
msgid "bad numeric config value '%s' for '%s' in blob %s: %s"
msgstr "数据对象 %3$s 中配置变量 '%2$s' 错误的取值 '%1$s'：%4$s"

#: config.c
#, c-format
msgid "bad numeric config value '%s' for '%s' in file %s: %s"
msgstr "文件 %3$s 中配置变量 '%2$s' 错误的取值 '%1$s'：%4$s"

#: config.c
#, c-format
msgid "bad numeric config value '%s' for '%s' in standard input: %s"
msgstr "标准输入中配置变量 '%2$s' 错误的取值 '%1$s'：%3$s"

#: config.c
#, c-format
msgid "bad numeric config value '%s' for '%s' in submodule-blob %s: %s"
msgstr "子模组数据 %3$s 中配置变量 '%2$s' 错误的取值 '%1$s'：%4$s"

#: config.c
#, c-format
msgid "bad numeric config value '%s' for '%s' in command line %s: %s"
msgstr "命令行 %3$s 中配置变量 '%2$s' 错误的取值 '%1$s'：%4$s"

#: config.c
#, c-format
msgid "bad numeric config value '%s' for '%s' in %s: %s"
msgstr "在 %3$s 中配置变量 '%2$s' 错误的取值 '%1$s'：%4$s"

#: config.c
#, c-format
msgid "invalid value for variable %s"
msgstr "变量 %s 的值无效"

#: config.c
#, c-format
msgid "ignoring unknown core.fsync component '%s'"
msgstr "忽略未知的 core.fsync 组件 '%s'"

#: config.c
#, c-format
msgid "bad boolean config value '%s' for '%s'"
msgstr "'%2$s' 的错误的布尔取值 '%1$s'"

#: config.c
#, c-format
msgid "failed to expand user dir in: '%s'"
msgstr "无法扩展用户目录：'%s'"

#: config.c
#, c-format
msgid "'%s' for '%s' is not a valid timestamp"
msgstr "'%2$s' 的值 '%1$s' 不是一个有效的时间戳"

#: config.c
#, c-format
msgid "abbrev length out of range: %d"
msgstr "缩写长度超出范围：%d"

#: config.c
#, c-format
msgid "bad zlib compression level %d"
msgstr "错误的 zlib 压缩级别 %d"

#: config.c
#, c-format
msgid "%s cannot contain newline"
msgstr "%s 不能包含换行符"

#: config.c
#, c-format
msgid "%s must have at least one character"
msgstr "%s 必须至少有一个字符"

#: config.c
#, c-format
msgid "ignoring unknown core.fsyncMethod value '%s'"
msgstr "忽略未知的 core.fsyncMethod 值 '%s'"

#: config.c
msgid "core.fsyncObjectFiles is deprecated; use core.fsync instead"
msgstr "core.fsyncObjectFiles 已经被弃用；取而代之使用 core.fsync"

#: config.c
#, c-format
msgid "invalid mode for object creation: %s"
msgstr "无效的对象创建模式：%s"

#: config.c
#, c-format
msgid "malformed value for %s"
msgstr "%s 的取值格式错误"

#: config.c
#, c-format
msgid "malformed value for %s: %s"
msgstr "%s 的取值格式错误：%s"

#: config.c
msgid "must be one of nothing, matching, simple, upstream or current"
msgstr "必须是其中之一：nothing、matching、simple、upstream 或 current"

#: config.c
#, c-format
msgid "unable to load config blob object '%s'"
msgstr "无法从数据对象 '%s' 加载配置"

#: config.c
#, c-format
msgid "reference '%s' does not point to a blob"
msgstr "引用 '%s' 没有指向一个数据对象"

#: config.c
#, c-format
msgid "unable to resolve config blob '%s'"
msgstr "不能解析配置对象 '%s'"

#: config.c
msgid "unable to parse command-line config"
msgstr "无法解析命令行中的配置"

#: config.c
msgid "unknown error occurred while reading the configuration files"
msgstr "在读取配置文件时遇到未知错误"

#: config.c
#, c-format
msgid "Invalid %s: '%s'"
msgstr "无效 %s：'%s'"

#: config.c
#, c-format
msgid "splitIndex.maxPercentChange value '%d' should be between 0 and 100"
msgstr "splitIndex.maxPercentChange 的取值 '%d' 应该介于 0 和 100 之间"

#: config.c
#, c-format
msgid "unable to parse '%s' from command-line config"
msgstr "无法解析命令行配置中的 '%s'"

#: config.c
#, c-format
msgid "bad config variable '%s' in file '%s' at line %d"
msgstr "在文件 '%2$s' 的第 %3$d 行发现错误的配置变量 '%1$s'"

#: config.c
#, c-format
msgid "invalid section name '%s'"
msgstr "无效的小节名称 '%s'"

#: config.c
#, c-format
msgid "%s has multiple values"
msgstr "%s 有多个取值"

#: config.c
#, c-format
msgid "failed to write new configuration file %s"
msgstr "无法写入新的配置文件 %s"

#: config.c
#, c-format
msgid "no multi-line comment allowed: '%s'"
msgstr "不允许多行注释：'%s'"

#: config.c
#, c-format
msgid "could not lock config file %s"
msgstr "不能锁定配置文件 %s"

#: config.c
#, c-format
msgid "opening %s"
msgstr "打开 %s"

#: config.c
#, c-format
msgid "invalid config file %s"
msgstr "无效的配置文件 %s"

#: config.c
#, c-format
msgid "fstat on %s failed"
msgstr "对 %s 调用 fstat 失败"

#: config.c
#, c-format
msgid "unable to mmap '%s'%s"
msgstr "不能 mmap '%s'%s"

#: config.c
#, c-format
msgid "chmod on %s failed"
msgstr "对 %s 调用 chmod 失败"

#: config.c
#, c-format
msgid "could not write config file %s"
msgstr "不能写入配置文件 %s"

#: config.c
#, c-format
msgid "could not set '%s' to '%s'"
msgstr "不能设置 '%s' 为 '%s'"

#: config.c
#, c-format
msgid "invalid section name: %s"
msgstr "无效的小节名称：%s"

#: config.c
#, c-format
msgid "refusing to work with overly long line in '%s' on line %<PRIuMAX>"
msgstr "拒绝支持内容过长的行，位于文件 '%s' 中的第 %<PRIuMAX> 行"

#: config.c
#, c-format
msgid "missing value for '%s'"
msgstr "%s 的取值缺失"

#: connect.c
msgid "the remote end hung up upon initial contact"
msgstr "远端在初始连接时即挂断"

#: connect.c
msgid ""
"Could not read from remote repository.\n"
"\n"
"Please make sure you have the correct access rights\n"
"and the repository exists."
msgstr ""
"无法读取远程仓库。\n"
"\n"
"请确认您有正确的访问权限并且仓库存在。"

#: connect.c
#, c-format
msgid "server doesn't support '%s'"
msgstr "服务器不支持 '%s'"

#: connect.c
#, c-format
msgid "server doesn't support feature '%s'"
msgstr "服务器不支持特性 '%s'"

#: connect.c
msgid "expected flush after capabilities"
msgstr "在能力之后应为一个 flush 包"

#: connect.c
#, c-format
msgid "ignoring capabilities after first line '%s'"
msgstr "忽略第一行 '%s' 之后的能力字段"

#: connect.c
msgid "protocol error: unexpected capabilities^{}"
msgstr "协议错误：意外的 capabilities^{}"

#: connect.c
#, c-format
msgid "protocol error: expected shallow sha-1, got '%s'"
msgstr "协议错误：预期浅克隆 sha-1，却得到 '%s'"

#: connect.c
msgid "repository on the other end cannot be shallow"
msgstr "另一端的仓库不能是浅克隆仓库"

#: connect.c
msgid "invalid packet"
msgstr "无效数据包"

#: connect.c
#, c-format
msgid "protocol error: unexpected '%s'"
msgstr "协议错误：意外的 '%s'"

#: connect.c
#, c-format
msgid "unknown object format '%s' specified by server"
msgstr "服务器给出未知的对象格式 '%s'"

#: connect.c
#, c-format
msgid "error on bundle-uri response line %d: %s"
msgstr "于 bundle-uri 响应行 %d 发生错误：%s"

#: connect.c
msgid "expected flush after bundle-uri listing"
msgstr "在 bundle-uri 列表之后应该有一个 flush 包"

#: connect.c
msgid "expected response end packet after ref listing"
msgstr "在引用列表之后应该有响应结束包"

#: connect.c
#, c-format
msgid "invalid ls-refs response: %s"
msgstr "无效的 ls-refs 响应：%s"

#: connect.c
msgid "expected flush after ref listing"
msgstr "在引用列表之后应该有一个 flush 包"

#: connect.c
#, c-format
msgid "protocol '%s' is not supported"
msgstr "不支持 '%s' 协议"

#: connect.c
msgid "unable to set SO_KEEPALIVE on socket"
msgstr "无法为 socket 设置 SO_KEEPALIVE"

#: connect.c
#, c-format
msgid "Looking up %s ... "
msgstr "查找 %s ..."

#: connect.c
#, c-format
msgid "unable to look up %s (port %s) (%s)"
msgstr "无法查找 %s（端口 %s）（%s）"

#. TRANSLATORS: this is the end of "Looking up %s ... "
#: connect.c
#, c-format
msgid ""
"done.\n"
"Connecting to %s (port %s) ... "
msgstr ""
"完成。\n"
"连接到 %s（端口 %s）... "

#: connect.c
#, c-format
msgid ""
"unable to connect to %s:\n"
"%s"
msgstr ""
"无法连接到 %s：\n"
"%s"

#. TRANSLATORS: this is the end of "Connecting to %s (port %s) ... "
#: connect.c
msgid "done."
msgstr "完成。"

#: connect.c
#, c-format
msgid "unable to look up %s (%s)"
msgstr "无法查找 %s（%s）"

#: connect.c
#, c-format
msgid "unknown port %s"
msgstr "未知端口 %s"

#: connect.c
#, c-format
msgid "strange hostname '%s' blocked"
msgstr "已阻止奇怪的主机名 '%s'"

#: connect.c
#, c-format
msgid "strange port '%s' blocked"
msgstr "已阻止奇怪的端口号 '%s'"

#: connect.c
#, c-format
msgid "cannot start proxy %s"
msgstr "不能启动代理 %s"

#: connect.c
msgid "no path specified; see 'git help pull' for valid url syntax"
msgstr "未指定路径，执行 'git help pull' 查看有效的 url 语法"

#: connect.c
msgid "newline is forbidden in git:// hosts and repo paths"
msgstr "在 git:// 主机和仓库路径中禁止使用换行符"

#: connect.c
msgid "ssh variant 'simple' does not support -4"
msgstr "ssh 变体 'simple' 不支持 -4"

#: connect.c
msgid "ssh variant 'simple' does not support -6"
msgstr "ssh 变体 'simple' 不支持 -6"

#: connect.c
msgid "ssh variant 'simple' does not support setting port"
msgstr "ssh 变体 'simple' 不支持设置端口"

#: connect.c
#, c-format
msgid "strange pathname '%s' blocked"
msgstr "已阻止奇怪的路径名 '%s'"

#: connect.c
msgid "unable to fork"
msgstr "无法 fork"

#: connected.c
msgid "Could not run 'git rev-list'"
msgstr "不能执行 'git rev-list'"

#: connected.c
msgid "failed write to rev-list"
msgstr "写入 rev-list 失败"

#: connected.c
msgid "failed to close rev-list's stdin"
msgstr "无法关闭 rev-list 的标准输入"

#: convert.c
#, c-format
msgid "illegal crlf_action %d"
msgstr "非法的 crlf_action %d"

#: convert.c
#, c-format
msgid "CRLF would be replaced by LF in %s"
msgstr "%s 中的 CRLF 将被 LF 替换"

#: convert.c
#, c-format
msgid ""
"in the working copy of '%s', CRLF will be replaced by LF the next time Git "
"touches it"
msgstr "在 '%s' 的工作拷贝中，下次 Git 接触时 CRLF 将被 LF 替换"

#: convert.c
#, c-format
msgid "LF would be replaced by CRLF in %s"
msgstr "文件 %s 中的 LF 将被 CRLF 替换"

#: convert.c
#, c-format
msgid ""
"in the working copy of '%s', LF will be replaced by CRLF the next time Git "
"touches it"
msgstr "在 '%s' 的工作拷贝中，下次 Git 接触时 LF 将被 CRLF 替换"

#: convert.c
#, c-format
msgid "BOM is prohibited in '%s' if encoded as %s"
msgstr "如果使用 %2$s 编码，禁止在 '%1$s' 中使用 BOM"

#: convert.c
#, c-format
msgid ""
"The file '%s' contains a byte order mark (BOM). Please use UTF-%.*s as "
"working-tree-encoding."
msgstr ""
"文件 '%s' 包含一个字节顺序标记（BOM）。请使用 UTF-%.*s 作为工作区编码。"

#: convert.c
#, c-format
msgid "BOM is required in '%s' if encoded as %s"
msgstr "如果编码为 %2$s，需要在 '%1$s' 中使用 BOM"

#: convert.c
#, c-format
msgid ""
"The file '%s' is missing a byte order mark (BOM). Please use UTF-%sBE or UTF-"
"%sLE (depending on the byte order) as working-tree-encoding."
msgstr ""
"文件 '%s' 缺失一个字节顺序标记（BOM）。请使用 UTF-%sBE or UTF-%sLE（取决于字"
"节序）作为工作区编码。"

#: convert.c
#, c-format
msgid "failed to encode '%s' from %s to %s"
msgstr "无法对 '%s' 进行从 %s 到 %s 的编码"

#: convert.c
#, c-format
msgid "encoding '%s' from %s to %s and back is not the same"
msgstr "将'%s' 的编码从 %s 到 %s 来回转换不一致"

#: convert.c
#, c-format
msgid "cannot fork to run external filter '%s'"
msgstr "不能 fork 以执行外部过滤器 '%s'"

#: convert.c
#, c-format
msgid "cannot feed the input to external filter '%s'"
msgstr "不能将输入传递给外部过滤器 '%s'"

#: convert.c
#, c-format
msgid "external filter '%s' failed %d"
msgstr "外部过滤器 '%s' 失败码 %d"

#: convert.c
#, c-format
msgid "read from external filter '%s' failed"
msgstr "从外部过滤器 '%s' 读取失败"

#: convert.c
#, c-format
msgid "external filter '%s' failed"
msgstr "外部过滤器 '%s' 失败"

#: convert.c
msgid "unexpected filter type"
msgstr "意外的过滤类型"

#: convert.c
msgid "path name too long for external filter"
msgstr "外部过滤器的路径名太长"

#: convert.c
#, c-format
msgid ""
"external filter '%s' is not available anymore although not all paths have "
"been filtered"
msgstr "外部过滤器 '%s' 不再可用，但并非所有路径都已过滤"

#: convert.c
msgid "true/false are no valid working-tree-encodings"
msgstr "true/false 不是有效的工作区编码"

#: convert.c
#, c-format
msgid "%s: clean filter '%s' failed"
msgstr "%s：clean 过滤器 '%s' 失败"

#: convert.c
#, c-format
msgid "%s: smudge filter %s failed"
msgstr "%s：smudge 过滤器 %s 失败"

#: credential.c
#, c-format
msgid "skipping credential lookup for key: credential.%s"
msgstr "跳过凭据查询：credential.%s"

#: credential.c
msgid "refusing to work with credential missing host field"
msgstr "拒绝使用缺少主机字段的凭据"

#: credential.c
msgid "refusing to work with credential missing protocol field"
msgstr "拒绝使用缺少协议字段的凭据"

#: credential.c
#, c-format
msgid "url contains a newline in its %s component: %s"
msgstr "URL 的 %s 组件中包含换行符：%s"

#: credential.c
#, c-format
msgid "url has no scheme: %s"
msgstr "URL 没有 scheme：%s"

#: credential.c
#, c-format
msgid "credential url cannot be parsed: %s"
msgstr "不能解析凭据 URL：%s"

#: daemon.c
#, c-format
msgid "invalid timeout '%s', expecting a non-negative integer"
msgstr "无效的超时值 '%s'，应为非负整数"

#: daemon.c
#, c-format
msgid "invalid init-timeout '%s', expecting a non-negative integer"
msgstr "无效的初始超时值 '%s'，应为非负整数"

#: daemon.c
#, c-format
msgid "invalid max-connections '%s', expecting an integer"
msgstr "无效的最大连接数 '%s'，应为一个整数"

#: date.c
msgid "in the future"
msgstr "在将来"

#: date.c
#, c-format
msgid "%<PRIuMAX> second ago"
msgid_plural "%<PRIuMAX> seconds ago"
msgstr[0] "%<PRIuMAX> 秒钟前"
msgstr[1] "%<PRIuMAX> 秒钟前"

#: date.c
#, c-format
msgid "%<PRIuMAX> minute ago"
msgid_plural "%<PRIuMAX> minutes ago"
msgstr[0] "%<PRIuMAX> 分钟前"
msgstr[1] "%<PRIuMAX> 分钟前"

#: date.c
#, c-format
msgid "%<PRIuMAX> hour ago"
msgid_plural "%<PRIuMAX> hours ago"
msgstr[0] "%<PRIuMAX> 小时前"
msgstr[1] "%<PRIuMAX> 小时前"

#: date.c
#, c-format
msgid "%<PRIuMAX> day ago"
msgid_plural "%<PRIuMAX> days ago"
msgstr[0] "%<PRIuMAX> 天前"
msgstr[1] "%<PRIuMAX> 天前"

#: date.c
#, c-format
msgid "%<PRIuMAX> week ago"
msgid_plural "%<PRIuMAX> weeks ago"
msgstr[0] "%<PRIuMAX> 周前"
msgstr[1] "%<PRIuMAX> 周前"

#: date.c
#, c-format
msgid "%<PRIuMAX> month ago"
msgid_plural "%<PRIuMAX> months ago"
msgstr[0] "%<PRIuMAX> 个月前"
msgstr[1] "%<PRIuMAX> 个月前"

#: date.c
#, c-format
msgid "%<PRIuMAX> year"
msgid_plural "%<PRIuMAX> years"
msgstr[0] "%<PRIuMAX> 年"
msgstr[1] "%<PRIuMAX> 年"

#. TRANSLATORS: "%s" is "<n> years"
#: date.c
#, c-format
msgid "%s, %<PRIuMAX> month ago"
msgid_plural "%s, %<PRIuMAX> months ago"
msgstr[0] "%s %<PRIuMAX> 个月前"
msgstr[1] "%s %<PRIuMAX> 个月前"

#: date.c
#, c-format
msgid "%<PRIuMAX> year ago"
msgid_plural "%<PRIuMAX> years ago"
msgstr[0] "%<PRIuMAX> 年前"
msgstr[1] "%<PRIuMAX> 年前"

#: delta-islands.c
msgid "Propagating island marks"
msgstr "正在传播数据岛标记"

#: delta-islands.c
#, c-format
msgid "bad tree object %s"
msgstr "坏的树对象 %s"

#: delta-islands.c
#, c-format
msgid "failed to load island regex for '%s': %s"
msgstr "未能加载 '%s' 的数据岛正则表达式：%s"

#: delta-islands.c
#, c-format
msgid "island regex from config has too many capture groups (max=%d)"
msgstr "来自 config 的数据岛正则表达式有太多的捕获组（最多 %d 个）"

#: delta-islands.c
#, c-format
msgid "Marked %d islands, done.\n"
msgstr "已标记 %d 个数据岛，结束。\n"

#: diagnose.c
#, c-format
msgid "invalid --%s value '%s'"
msgstr "无效的 --%s 值 '%s'"

#: diagnose.c
#, c-format
msgid "could not archive missing directory '%s'"
msgstr "无法归档缺失的目录 '%s'"

#: diagnose.c dir.c
#, c-format
msgid "could not open directory '%s'"
msgstr "无法打开目录 '%s'"

#: diagnose.c
#, c-format
msgid "skipping '%s', which is neither file nor directory"
msgstr "跳过 '%s'，既不是文件又不是目录"

#: diagnose.c
msgid "could not duplicate stdout"
msgstr "无法复制标准输出"

#: diagnose.c
#, c-format
msgid "could not add directory '%s' to archiver"
msgstr "无法添加目录 '%s' 至归档器"

#: diagnose.c
msgid "failed to write archive"
msgstr "无法写入归档"

#: diff-lib.c
msgid "--merge-base does not work with ranges"
msgstr "--merge-base 不适用于范围"

#: diff-lib.c
msgid "unable to get HEAD"
msgstr "不能解析 HEAD"

#: diff-lib.c
msgid "no merge base found"
msgstr "未找到合并基线"

#: diff-lib.c
msgid "multiple merge bases found"
msgstr "找到了多条合并基线"

#: diff-no-index.c
msgid "cannot compare stdin to a directory"
msgstr "无法将标准输入和目录进行比较"

#: diff-no-index.c
msgid "cannot compare a named pipe to a directory"
msgstr "无法将命名管道和目录进行比较"

#: diff-no-index.c
msgid "git diff --no-index [<options>] <path> <path>"
msgstr "git diff --no-index [<选项>] <路径> <路径>"

#: diff-no-index.c
msgid ""
"Not a git repository. Use --no-index to compare two paths outside a working "
"tree"
msgstr "不是 git 仓库。使用 --no-index 比较工作区之外的两个路径"

#  译者：注意保持前导空格
#: diff.c
#, c-format
msgid "  Failed to parse dirstat cut-off percentage '%s'\n"
msgstr "  无法解析 dirstat 截止（cut-off）百分比 '%s'\n"

#  译者：注意保持前导空格
#: diff.c
#, c-format
msgid "  Unknown dirstat parameter '%s'\n"
msgstr "  未知的 dirstat 参数 '%s'\n"

#: diff.c
msgid ""
"color moved setting must be one of 'no', 'default', 'blocks', 'zebra', "
"'dimmed-zebra', 'plain'"
msgstr ""
"移动的颜色设置必须是 'no'、'default'、'blocks'、'zebra'、'dimmed-zebra' 或 "
"'plain'"

#: diff.c
#, c-format
msgid ""
"unknown color-moved-ws mode '%s', possible values are 'ignore-space-change', "
"'ignore-space-at-eol', 'ignore-all-space', 'allow-indentation-change'"
msgstr ""
"未知的 color-moved-ws 模式 '%s'，可能的取值有 'ignore-space-change'、'ignore-"
"space-at-eol'、'ignore-all-space'、'allow-indentation-change'"

#: diff.c
msgid ""
"color-moved-ws: allow-indentation-change cannot be combined with other "
"whitespace modes"
msgstr "color-moved-ws：allow-indentation-change 不能与其它空白字符模式共用"

#: diff.c
#, c-format
msgid "Unknown value for 'diff.submodule' config variable: '%s'"
msgstr "配置变量 'diff.submodule' 未知的取值：'%s'"

#: diff.c merge-recursive.c transport.c
#, c-format
msgid "unknown value for config '%s': %s"
msgstr "配置 '%s' 未知的取值：%s"

#: diff.c
#, c-format
msgid ""
"Found errors in 'diff.dirstat' config variable:\n"
"%s"
msgstr ""
"发现配置变量 'diff.dirstat' 中的错误：\n"
"%s"

#: diff.c
#, c-format
msgid "external diff died, stopping at %s"
msgstr "外部 diff 退出，停止在 %s"

#: diff.c
msgid "--follow requires exactly one pathspec"
msgstr "--follow 明确要求只跟一个路径规格"

#: diff.c
#, c-format
msgid "pathspec magic not supported by --follow: %s"
msgstr "指定 --follow: %s 的同时，不支持在路径规格中使用神奇前缀"

#: diff.c parse-options.c
#, c-format
msgid "options '%s', '%s', '%s', and '%s' cannot be used together"
msgstr "选项 '%s'、'%s'、'%s' 和 '%s' 不能同时使用"

#: diff.c
#, c-format
msgid "options '%s' and '%s' cannot be used together, use '%s' with '%s'"
msgstr "选项 '%1$s'、'%2$s' 不能同时使用，与 '%4$s' 一起使用 '%3$s'"

#: diff.c
#, c-format
msgid ""
"options '%s' and '%s' cannot be used together, use '%s' with '%s' and '%s'"
msgstr "选项 '%1$s'、'%2$s' 不能同时使用，与 '%4$s' 和 '%5$s' 一起使用 '%3$s'"

#: diff.c
#, c-format
msgid "invalid --stat value: %s"
msgstr "无效的 --stat 值：%s"

#: diff.c parse-options.c
#, c-format
msgid "%s expects a numerical value"
msgstr "%s 期望一个数字值"

#: diff.c
#, c-format
msgid ""
"Failed to parse --dirstat/-X option parameter:\n"
"%s"
msgstr ""
"无法解析 --dirstat/-X 选项的参数：\n"
"%s"

#: diff.c
#, c-format
msgid "unknown change class '%c' in --diff-filter=%s"
msgstr "--diff-filter=%2$s 中未知的变更类 '%1$c'"

#: diff.c
#, c-format
msgid "unknown value after ws-error-highlight=%.*s"
msgstr "ws-error-highlight=%.*s 之后未知的值"

#: diff.c
#, c-format
msgid "unable to resolve '%s'"
msgstr "不能解析 '%s'"

#: diff.c
#, c-format
msgid "%s expects <n>/<m> form"
msgstr "%s 期望 <n>/<m> 格式"

#: diff.c
#, c-format
msgid "%s expects a character, got '%s'"
msgstr "%s 期望一个字符，得到 '%s'"

#: diff.c
#, c-format
msgid "bad --color-moved argument: %s"
msgstr "坏的 --color-moved 参数：%s"

#: diff.c
#, c-format
msgid "invalid mode '%s' in --color-moved-ws"
msgstr "--color-moved-ws 中的无效模式 '%s' "

#: diff.c
#, c-format
msgid "invalid argument to %s"
msgstr "%s 的参数无效"

#: diff.c
#, c-format
msgid "invalid regex given to -I: '%s'"
msgstr "选项 -I 的正则表达式无效：'%s'"

#: diff.c
msgid "-G requires a non-empty argument"
msgstr "-G 需要一个非空参数"

#: diff.c
msgid "-S requires a non-empty argument"
msgstr "-S 需要一个非空参数"

#: diff.c
#, c-format
msgid "failed to parse --submodule option parameter: '%s'"
msgstr "无法解析 --submodule 选项的参数：'%s'"

#: diff.c
#, c-format
msgid "bad --word-diff argument: %s"
msgstr "坏的 --word-diff 参数：%s"

#: diff.c
msgid "Diff output format options"
msgstr "差异输出格式化选项"

#: diff.c
msgid "generate patch"
msgstr "生成补丁"

#: diff.c
msgid "<n>"
msgstr "<n>"

#: diff.c
msgid "generate diffs with <n> lines context"
msgstr "生成含 <n> 行上下文的差异"

#: diff.c
msgid "generate the diff in raw format"
msgstr "生成原始格式的差异"

#: diff.c
msgid "synonym for '-p --raw'"
msgstr "和 '-p --raw' 同义"

#: diff.c
msgid "synonym for '-p --stat'"
msgstr "和 '-p --stat' 同义"

#: diff.c
msgid "machine friendly --stat"
msgstr "机器友好的 --stat"

#: diff.c
msgid "output only the last line of --stat"
msgstr "只输出 --stat 的最后一行"

#: diff.c
msgid "<param1>,<param2>..."
msgstr "<参数1>,<参数2>..."

#: diff.c
msgid ""
"output the distribution of relative amount of changes for each sub-directory"
msgstr "输出每个子目录相对变更的分布"

#: diff.c
msgid "synonym for --dirstat=cumulative"
msgstr "和 --dirstat=cumulative 同义"

#: diff.c
msgid "synonym for --dirstat=files,<param1>,<param2>..."
msgstr "是 --dirstat=files,<参数1>,<参数2>... 的同义词"

#: diff.c
msgid "warn if changes introduce conflict markers or whitespace errors"
msgstr "如果变更中引入冲突定界符或空白错误，给出警告"

#: diff.c
msgid "condensed summary such as creations, renames and mode changes"
msgstr "精简摘要，例如创建、重命名和模式变更"

#: diff.c
msgid "show only names of changed files"
msgstr "只显示变更文件的文件名"

#: diff.c
msgid "show only names and status of changed files"
msgstr "只显示变更文件的文件名和状态"

#: diff.c
msgid "<width>[,<name-width>[,<count>]]"
msgstr "<宽度>[,<文件名宽度>[,<次数>]]"

#: diff.c
msgid "generate diffstat"
msgstr "生成差异统计（diffstat）"

#: diff.c
msgid "<width>"
msgstr "<宽度>"

#: diff.c
msgid "generate diffstat with a given width"
msgstr "使用给定的长度生成差异统计"

#: diff.c
msgid "generate diffstat with a given name width"
msgstr "使用给定的文件名长度生成差异统计"

#: diff.c
msgid "generate diffstat with a given graph width"
msgstr "使用给定的图形长度生成差异统计"

#: diff.c
msgid "<count>"
msgstr "<次数>"

#: diff.c
msgid "generate diffstat with limited lines"
msgstr "生成有限行数的差异统计"

#: diff.c
msgid "generate compact summary in diffstat"
msgstr "生成差异统计的简洁摘要"

#: diff.c
msgid "output a binary diff that can be applied"
msgstr "输出一个可以应用的二进制差异"

#: diff.c
msgid "show full pre- and post-image object names on the \"index\" lines"
msgstr "在 \"index\" 行显示完整的前后对象名称"

#: diff.c
msgid "show colored diff"
msgstr "显示带颜色的差异"

#: diff.c
msgid "<kind>"
msgstr "<类型>"

#: diff.c
msgid ""
"highlight whitespace errors in the 'context', 'old' or 'new' lines in the "
"diff"
msgstr "对于差异中的上下文、旧的和新的行，加亮显示错误的空白字符"

#: diff.c
msgid ""
"do not munge pathnames and use NULs as output field terminators in --raw or "
"--numstat"
msgstr ""
"在 --raw 或者 --numstat 中，不对路径字符转码并使用 NUL 字符做为输出字段的分隔"
"符"

#: diff.c
msgid "<prefix>"
msgstr "<前缀>"

#: diff.c
msgid "show the given source prefix instead of \"a/\""
msgstr "显示给定的源前缀取代 \"a/\""

#: diff.c
msgid "show the given destination prefix instead of \"b/\""
msgstr "显示给定的目标前缀取代 \"b/\""

#: diff.c
msgid "prepend an additional prefix to every line of output"
msgstr "输出的每一行附加前缀"

#: diff.c
msgid "do not show any source or destination prefix"
msgstr "不显示任何源和目标前缀"

#: diff.c
msgid "use default prefixes a/ and b/"
msgstr "使用 a/ 和 b/ 作为默认前缀"

#: diff.c
msgid "show context between diff hunks up to the specified number of lines"
msgstr "显示指定行数的差异块间的上下文"

#: diff.c
msgid "<char>"
msgstr "<字符>"

#: diff.c
msgid "specify the character to indicate a new line instead of '+'"
msgstr "指定一个字符取代 '+' 来表示新的一行"

#: diff.c
msgid "specify the character to indicate an old line instead of '-'"
msgstr "指定一个字符取代 '-' 来表示旧的一行"

#: diff.c
msgid "specify the character to indicate a context instead of ' '"
msgstr "指定一个字符取代 ' ' 来表示一行上下文"

#: diff.c
msgid "Diff rename options"
msgstr "差异重命名选项"

#: diff.c
msgid "<n>[/<m>]"
msgstr "<n>[/<m>]"

#: diff.c
msgid "break complete rewrite changes into pairs of delete and create"
msgstr "将完全重写的变更打破为成对的删除和创建"

#: diff.c
msgid "detect renames"
msgstr "检测重命名"

#: diff.c
msgid "omit the preimage for deletes"
msgstr "省略删除操作的差异输出"

#: diff.c
msgid "detect copies"
msgstr "检测拷贝"

#: diff.c
msgid "use unmodified files as source to find copies"
msgstr "使用未修改的文件做为发现拷贝的源"

#: diff.c
msgid "disable rename detection"
msgstr "禁用重命名探测"

#: diff.c
msgid "use empty blobs as rename source"
msgstr "使用空的数据对象做为重命名的源"

#: diff.c
msgid "continue listing the history of a file beyond renames"
msgstr "继续列出文件重命名以外的历史记录"

#: diff.c
msgid ""
"prevent rename/copy detection if the number of rename/copy targets exceeds "
"given limit"
msgstr "如果重命名/拷贝目标超过给定的限制，禁止重命名/拷贝检测"

#: diff.c
msgid "Diff algorithm options"
msgstr "差异算法选项"

#: diff.c
msgid "produce the smallest possible diff"
msgstr "生成尽可能小的差异"

#: diff.c
msgid "ignore whitespace when comparing lines"
msgstr "行比较时忽略空白字符"

#: diff.c
msgid "ignore changes in amount of whitespace"
msgstr "忽略空白字符的变更"

#: diff.c
msgid "ignore changes in whitespace at EOL"
msgstr "忽略行尾的空白字符变更"

#: diff.c
msgid "ignore carrier-return at the end of line"
msgstr "忽略行尾的回车符（CR）"

#: diff.c
msgid "ignore changes whose lines are all blank"
msgstr "忽略整行都是空白的变更"

#: diff.c
msgid "<regex>"
msgstr "<正则>"

#: diff.c
msgid "ignore changes whose all lines match <regex>"
msgstr "忽略所有行都和正则表达式匹配的变更"

#: diff.c
msgid "heuristic to shift diff hunk boundaries for easy reading"
msgstr "启发式转换差异边界以便阅读"

#: diff.c
msgid "generate diff using the \"patience diff\" algorithm"
msgstr "使用 \"patience diff\" 算法生成差异"

#: diff.c
msgid "generate diff using the \"histogram diff\" algorithm"
msgstr "使用 \"histogram diff\" 算法生成差异"

#: diff.c
msgid "<text>"
msgstr "<文本>"

#: diff.c
msgid "generate diff using the \"anchored diff\" algorithm"
msgstr "使用 \"anchored diff\" 算法生成差异"

#: diff.c
msgid "<mode>"
msgstr "<模式>"

#: diff.c
msgid "show word diff, using <mode> to delimit changed words"
msgstr "显示单词差异，使用 <模式> 分隔变更的单词"

#: diff.c
msgid "use <regex> to decide what a word is"
msgstr "使用 <正则表达式> 确定何为一个词"

#: diff.c
msgid "equivalent to --word-diff=color --word-diff-regex=<regex>"
msgstr "相当于 --word-diff=color --word-diff-regex=<正则>"

#: diff.c
msgid "moved lines of code are colored differently"
msgstr "移动的代码行用不同方式着色"

#: diff.c
msgid "how white spaces are ignored in --color-moved"
msgstr "在 --color-moved 下如何忽略空白字符"

#: diff.c
msgid "Other diff options"
msgstr "其它差异选项"

#: diff.c
msgid "when run from subdir, exclude changes outside and show relative paths"
msgstr "当从子目录运行，排除目录之外的变更并显示相对路径"

#: diff.c
msgid "treat all files as text"
msgstr "把所有文件当做文本处理"

#: diff.c
msgid "swap two inputs, reverse the diff"
msgstr "交换两个输入，反转差异"

#: diff.c
msgid "exit with 1 if there were differences, 0 otherwise"
msgstr "有差异时退出码为 1，否则为 0"

#: diff.c
msgid "disable all output of the program"
msgstr "禁用本程序的所有输出"

#: diff.c
msgid "allow an external diff helper to be executed"
msgstr "允许执行一个外置的差异助手"

#: diff.c
msgid "run external text conversion filters when comparing binary files"
msgstr "当比较二进制文件时，运行外部的文本转换过滤器"

#: diff.c
msgid "<when>"
msgstr "<何时>"

#: diff.c
msgid "ignore changes to submodules in the diff generation"
msgstr "在生成差异时，忽略子模组的更改"

#: diff.c
msgid "<format>"
msgstr "<格式>"

#: diff.c
msgid "specify how differences in submodules are shown"
msgstr "指定子模组的差异如何显示"

#: diff.c
msgid "hide 'git add -N' entries from the index"
msgstr "隐藏索引中 'git add -N' 条目"

#: diff.c
msgid "treat 'git add -N' entries as real in the index"
msgstr "将索引中 'git add -N' 条目当做真实的"

#: diff.c
msgid "<string>"
msgstr "<字符串>"

#: diff.c
msgid ""
"look for differences that change the number of occurrences of the specified "
"string"
msgstr "查找改变了指定字符串出现次数的差异"

#: diff.c
msgid ""
"look for differences that change the number of occurrences of the specified "
"regex"
msgstr "查找改变指定正则匹配出现次数的差异"

#: diff.c
msgid "show all changes in the changeset with -S or -G"
msgstr "显示使用 -S 或 -G 的变更集的所有变更"

#: diff.c
msgid "treat <string> in -S as extended POSIX regular expression"
msgstr "将 -S 的 <string> 当做扩展的 POSIX 正则表达式"

#: diff.c
msgid "control the order in which files appear in the output"
msgstr "控制输出中的文件显示顺序"

#: diff.c
msgid "<path>"
msgstr "<路径>"

#: diff.c
msgid "show the change in the specified path first"
msgstr "先显示指定路径的变更"

#: diff.c
msgid "skip the output to the specified path"
msgstr "跳过指定路径的输出"

#: diff.c
msgid "<object-id>"
msgstr "<对象 ID>"

#: diff.c
msgid ""
"look for differences that change the number of occurrences of the specified "
"object"
msgstr "查找改变指定对象出现次数的差异"

#: diff.c
msgid "[(A|C|D|M|R|T|U|X|B)...[*]]"
msgstr "[(A|C|D|M|R|T|U|X|B)...[*]]"

#: diff.c
msgid "select files by diff type"
msgstr "通过差异类型选择文件"

#: diff.c
msgid "<file>"
msgstr "<文件>"

#: diff.c
msgid "output to a specific file"
msgstr "输出到指定的文件"

#: diff.c
msgid "exhaustive rename detection was skipped due to too many files."
msgstr "由于文件太多，跳过详尽的重命名检查。"

#: diff.c
msgid "only found copies from modified paths due to too many files."
msgstr "由于文件太多，只在修改的路径中找到了拷贝。"

#: diff.c
#, c-format
msgid ""
"you may want to set your %s variable to at least %d and retry the command."
msgstr "您可能想要将变量 %s 设置为至少 %d 并再次执行此命令。"

#: diffcore-order.c
#, c-format
msgid "failed to read orderfile '%s'"
msgstr "无法读取排序文件 '%s'"

#: diffcore-rename.c
msgid "Performing inexact rename detection"
msgstr "正在进行非精确的重命名探测"

#: diffcore-rotate.c
#, c-format
msgid "No such path '%s' in the diff"
msgstr "在差异中无此路径 '%s'"

#: dir.c
#, c-format
msgid "pathspec '%s' did not match any file(s) known to git"
msgstr "路径规格 '%s' 未匹配任何 git 已知文件"

#: dir.c
#, c-format
msgid "unrecognized pattern: '%s'"
msgstr "未识别的模式：'%s'"

#: dir.c
#, c-format
msgid "unrecognized negative pattern: '%s'"
msgstr "未识别的反向模式：'%s'"

#: dir.c
#, c-format
msgid "your sparse-checkout file may have issues: pattern '%s' is repeated"
msgstr "您的 sparse-checkout 文件可能有问题：重复的模式 '%s'"

#: dir.c
msgid "disabling cone pattern matching"
msgstr "停用锥形模式匹配"

#: dir.c
#, c-format
msgid "cannot use %s as an exclude file"
msgstr "不能将 %s 用作排除文件"

#: dir.c
msgid "failed to get kernel name and information"
msgstr "无法获得内核名称和信息"

#: dir.c
msgid "untracked cache is disabled on this system or location"
msgstr "缓存未跟踪文件在本系统或位置中被禁用"

#: dir.c
msgid ""
"No directory name could be guessed.\n"
"Please specify a directory on the command line"
msgstr ""
"无法猜到目录名。\n"
"请在命令行指定一个目录"

#: dir.c
#, c-format
msgid "index file corrupt in repo %s"
msgstr "仓库 %s 中的索引文件损坏"

#: dir.c
#, c-format
msgid "could not create directories for %s"
msgstr "不能为 %s 创建目录"

#: dir.c
#, c-format
msgid "could not migrate git directory from '%s' to '%s'"
msgstr "不能从 '%s' 迁移 git 目录到 '%s'"

#: editor.c
#, c-format
msgid "hint: Waiting for your editor to close the file...%c"
msgstr "提示：等待您的编辑器关闭文件...%c"

#: editor.c sequencer.c wrapper.c
#, c-format
msgid "could not write to '%s'"
msgstr "不能写入 '%s'"

#: editor.c
#, c-format
msgid "could not edit '%s'"
msgstr "不能编辑 '%s'"

#: entry.c
msgid "Filtering content"
msgstr "过滤内容"

#: entry.c
#, c-format
msgid "could not stat file '%s'"
msgstr "不能对文件 '%s' 调用 stat"

#: environment.c
#, c-format
msgid "bad git namespace path \"%s\""
msgstr "错误的 git 名字空间路径 \"%s\""

#: exec-cmd.c
#, c-format
msgid "too many args to run %s"
msgstr "执行 %s 的参数太多"

#: fetch-pack.c
#, c-format
msgid ""
"You are attempting to fetch %s, which is in the commit graph file but not in "
"the object database.\n"
"This is probably due to repo corruption.\n"
"If you are attempting to repair this repo corruption by refetching the "
"missing object, use 'git fetch --refetch' with the missing object."
msgstr ""
"您正在尝试获取 %s，它位于提交图文件中，但不在对象数据库中。\n"
"这可能是由于仓库损坏造成的。\n"
"如果您尝试通过重新获取丢失的对象来修复此仓库损坏，请对丢失的对象使用 'git "
"fetch --refetch'。"

#: fetch-pack.c
msgid "git fetch-pack: expected shallow list"
msgstr "git fetch-pack：应为 shallow 列表"

#: fetch-pack.c
msgid "git fetch-pack: expected a flush packet after shallow list"
msgstr "git fetch-pack：在浅克隆列表之后期望一个 flush 包"

#: fetch-pack.c
msgid "git fetch-pack: expected ACK/NAK, got a flush packet"
msgstr "git fetch-pack：期望 ACK/NAK，却得到 flush 包"

#: fetch-pack.c
#, c-format
msgid "git fetch-pack: expected ACK/NAK, got '%s'"
msgstr "git fetch-pack：应为 ACK/NAK，却得到 '%s'"

#: fetch-pack.c
msgid "unable to write to remote"
msgstr "无法写到远程"

#: fetch-pack.c
msgid "Server supports filter"
msgstr "服务器支持 filter"

#: fetch-pack.c
#, c-format
msgid "invalid shallow line: %s"
msgstr "无效的 shallow 信息：%s"

#: fetch-pack.c
#, c-format
msgid "invalid unshallow line: %s"
msgstr "无效的 unshallow 信息：%s"

#: fetch-pack.c
#, c-format
msgid "object not found: %s"
msgstr "对象未找到：%s"

#: fetch-pack.c
#, c-format
msgid "error in object: %s"
msgstr "对象中出错：%s"

#: fetch-pack.c
#, c-format
msgid "no shallow found: %s"
msgstr "未发现 shallow：%s"

#: fetch-pack.c
#, c-format
msgid "expected shallow/unshallow, got %s"
msgstr "应为 shallow/unshallow，却得到 %s"

#: fetch-pack.c
#, c-format
msgid "got %s %d %s"
msgstr "得到 %s %d %s"

#: fetch-pack.c
#, c-format
msgid "invalid commit %s"
msgstr "无效提交 %s"

#: fetch-pack.c
msgid "giving up"
msgstr "放弃"

#: fetch-pack.c progress.h
msgid "done"
msgstr "完成"

#: fetch-pack.c
#, c-format
msgid "got %s (%d) %s"
msgstr "得到 %s (%d) %s"

#: fetch-pack.c
#, c-format
msgid "Marking %s as complete"
msgstr "标记 %s 为完成"

#: fetch-pack.c
#, c-format
msgid "already have %s (%s)"
msgstr "已经有 %s（%s）"

#: fetch-pack.c
msgid "fetch-pack: unable to fork off sideband demultiplexer"
msgstr "fetch-pack：无法派生 sideband 多路输出"

#: fetch-pack.c
msgid "protocol error: bad pack header"
msgstr "协议错误：坏的包头"

#: fetch-pack.c
#, c-format
msgid "fetch-pack: unable to fork off %s"
msgstr "fetch-pack：无法派生进程 %s"

#: fetch-pack.c
msgid "fetch-pack: invalid index-pack output"
msgstr "fetch-pack：无效的 index-pack 输出"

#: fetch-pack.c
#, c-format
msgid "%s failed"
msgstr "%s 失败"

#: fetch-pack.c
msgid "error in sideband demultiplexer"
msgstr "sideband 多路输出出错"

#: fetch-pack.c
#, c-format
msgid "Server version is %.*s"
msgstr "服务器版本 %.*s"

#: fetch-pack.c
#, c-format
msgid "Server supports %s"
msgstr "服务器支持 %s"

#: fetch-pack.c
msgid "Server does not support shallow clients"
msgstr "服务器不支持浅客户端"

#: fetch-pack.c
msgid "Server does not support --shallow-since"
msgstr "服务器不支持 --shallow-since"

#: fetch-pack.c
msgid "Server does not support --shallow-exclude"
msgstr "服务器不支持 --shallow-exclude"

#: fetch-pack.c
msgid "Server does not support --deepen"
msgstr "服务器不支持 --deepen"

#: fetch-pack.c
msgid "Server does not support this repository's object format"
msgstr "服务器不支持这个仓库的对象格式"

#: fetch-pack.c
msgid "no common commits"
msgstr "没有共同的提交"

#: fetch-pack.c
msgid "git fetch-pack: fetch failed."
msgstr "git fetch-pack：获取失败。"

#: fetch-pack.c
#, c-format
msgid "mismatched algorithms: client %s; server %s"
msgstr "不匹配的算法：客户端 %s，服务端 %s"

#: fetch-pack.c
#, c-format
msgid "the server does not support algorithm '%s'"
msgstr "服务器不支持算法 '%s'"

#: fetch-pack.c
msgid "Server does not support shallow requests"
msgstr "服务器不支持浅克隆请求"

#: fetch-pack.c
msgid "unable to write request to remote"
msgstr "无法将请求写到远程"

#: fetch-pack.c
#, c-format
msgid "expected '%s', received '%s'"
msgstr "预期 '%s'，得到 '%s'"

#: fetch-pack.c
#, c-format
msgid "expected '%s'"
msgstr "预期 '%s'"

#: fetch-pack.c
#, c-format
msgid "unexpected acknowledgment line: '%s'"
msgstr "意外的确认行：'%s'"

#: fetch-pack.c
#, c-format
msgid "error processing acks: %d"
msgstr "处理 ack 出错：%d"

#. TRANSLATORS: The parameter will be 'ready', a protocol
#. keyword.
#.
#: fetch-pack.c
#, c-format
msgid "expected packfile to be sent after '%s'"
msgstr "预期在 '%s' 之后发送 packfile"

#. TRANSLATORS: The parameter will be 'ready', a protocol
#. keyword.
#.
#: fetch-pack.c
#, c-format
msgid "expected no other sections to be sent after no '%s'"
msgstr "在没有 '%s' 后不应该发送其它小节"

#: fetch-pack.c
#, c-format
msgid "error processing shallow info: %d"
msgstr "处理浅克隆信息出错：%d"

#: fetch-pack.c
#, c-format
msgid "expected wanted-ref, got '%s'"
msgstr "预期 wanted-ref，得到 '%s'"

#: fetch-pack.c
#, c-format
msgid "unexpected wanted-ref: '%s'"
msgstr "意外的 wanted-ref：'%s'"

#: fetch-pack.c
#, c-format
msgid "error processing wanted refs: %d"
msgstr "处理要获取的引用出错：%d"

#: fetch-pack.c
msgid "git fetch-pack: expected response end packet"
msgstr "git fetch-pack：预期响应结束包"

#: fetch-pack.c
msgid "no matching remote head"
msgstr "没有匹配的远程分支"

#: fetch-pack.c
msgid "unexpected 'ready' from remote"
msgstr "来自远程的意外的 'ready'"

#: fetch-pack.c
#, c-format
msgid "no such remote ref %s"
msgstr "没有这样的远程引用 %s"

#: fetch-pack.c
#, c-format
msgid "Server does not allow request for unadvertised object %s"
msgstr "服务器不允许请求未公开的对象 %s"

#: fsmonitor-ipc.c
#, c-format
msgid "fsmonitor_ipc__send_query: invalid path '%s'"
msgstr "fsmonitor_ipc__send_query: 无效路径 '%s'"

#: fsmonitor-ipc.c
#, c-format
msgid "fsmonitor_ipc__send_query: unspecified error on '%s'"
msgstr "fsmonitor_ipc__send_query: 未知错误于 '%s'"

#: fsmonitor-ipc.c
msgid "fsmonitor--daemon is not running"
msgstr "fsmonitor--daemon 没有运行"

#: fsmonitor-ipc.c
#, c-format
msgid "could not send '%s' command to fsmonitor--daemon"
msgstr "无法发送 '%s' 命令至 fsmonitor--daemon"

#: fsmonitor-settings.c
#, c-format
msgid "bare repository '%s' is incompatible with fsmonitor"
msgstr "纯仓库 '%s' 与 fsmonitor 不兼容"

#: fsmonitor-settings.c
#, c-format
msgid "repository '%s' is incompatible with fsmonitor due to errors"
msgstr "因为错误，仓库 '%s' 与 fsmonitor 不兼容"

#: fsmonitor-settings.c
#, c-format
msgid "remote repository '%s' is incompatible with fsmonitor"
msgstr "远程仓库 '%s' 与 fsmonitor 不兼容"

#: fsmonitor-settings.c
#, c-format
msgid "virtual repository '%s' is incompatible with fsmonitor"
msgstr "虚拟仓库 '%s' 与 fsmonitor 不兼容"

#: fsmonitor-settings.c
#, c-format
msgid ""
"socket directory '%s' is incompatible with fsmonitor due to lack of Unix "
"sockets support"
msgstr "因为缺少 Unix 套接字支持，套接字目录 '%s' 与 fsmonitor 不兼容"

#: git.c
msgid ""
"git [-v | --version] [-h | --help] [-C <path>] [-c <name>=<value>]\n"
"           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n"
"           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--no-"
"lazy-fetch]\n"
"           [--no-optional-locks] [--no-advice] [--bare] [--git-dir=<path>]\n"
"           [--work-tree=<path>] [--namespace=<name>] [--config-"
"env=<name>=<envvar>]\n"
"           <command> [<args>]"
msgstr ""
"git [-v | --version] [-h | --help] [-C <路径>] [-c <名称>=<取值>]\n"
"           [--exec-path[=<路径>]] [--html-path] [--man-path] [--info-path]\n"
"           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [\"--"
"no-lazy-fetch]\n"
"           [--no-optional-locks] [--no-advice] [--bare] [--git-dir=<路径>]\n"
"           [--work-tree=<路径>] [--namespace=<名称>]\n"
"           [--config-env=<名称>=<环境变量>] <命令> [<参数>]"

#: git.c
msgid ""
"'git help -a' and 'git help -g' list available subcommands and some\n"
"concept guides. See 'git help <command>' or 'git help <concept>'\n"
"to read about a specific subcommand or concept.\n"
"See 'git help git' for an overview of the system."
msgstr ""
"命令 'git help -a' 和 'git help -g' 显示可用的子命令和一些概念帮助。\n"
"查看 'git help <命令>' 或 'git help <概念>' 以获取给定子命令或概念的\n"
"帮助。\n"
"有关系统的概述，查看 'git help git'。"

#: git.c help.c
#, c-format
msgid "unsupported command listing type '%s'"
msgstr "不支持的命令列表类型 '%s'"

#: git.c
#, c-format
msgid "no directory given for '%s' option\n"
msgstr "没有为 '%s' 选项提供目录\n"

#: git.c
#, c-format
msgid "no namespace given for --namespace\n"
msgstr "没有为 --namespace 提供命名空间\n"

#: git.c
#, c-format
msgid "-c expects a configuration string\n"
msgstr "应为 -c 提供一个配置字符串\n"

#: git.c
#, c-format
msgid "no config key given for --config-env\n"
msgstr "没有为 --config-env 提供配置名称\n"

#: git.c
#, c-format
msgid "no attribute source given for --attr-source\n"
msgstr "没有为 --attr-source 提供属性来源\n"

#: git.c
#, c-format
msgid "unknown option: %s\n"
msgstr "未知选项：%s\n"

#: git.c
#, c-format
msgid "while expanding alias '%s': '%s'"
msgstr "在扩展别名 '%s' 时：'%s'"

#: git.c
#, c-format
msgid ""
"alias '%s' changes environment variables.\n"
"You can use '!git' in the alias to do this"
msgstr ""
"别名 '%s' 修改环境变量。您可以使用在别名中\n"
"使用 '!git'"

#: git.c
#, c-format
msgid "empty alias for %s"
msgstr "%s 的空别名"

#: git.c
#, c-format
msgid "recursive alias: %s"
msgstr "递归的别名：%s"

#: git.c
msgid "write failure on standard output"
msgstr "在标准输出写入失败"

#: git.c
msgid "unknown write failure on standard output"
msgstr "到标准输出的未知写入错误"

#: git.c
msgid "close failed on standard output"
msgstr "标准输出关闭失败"

#: git.c
#, c-format
msgid "alias loop detected: expansion of '%s' does not terminate:%s"
msgstr "检测到别名循环：'%s'的扩展未终止：%s"

#: git.c
#, c-format
msgid "cannot handle %s as a builtin"
msgstr "不能作为内置命令处理 %s"

#: git.c
#, c-format
msgid ""
"usage: %s\n"
"\n"
msgstr ""
"用法：%s\n"
"\n"

#: git.c
#, c-format
msgid "expansion of alias '%s' failed; '%s' is not a git command\n"
msgstr "展开别名命令 '%s' 失败，'%s' 不是一个 git 命令\n"

#: git.c
#, c-format
msgid "failed to run command '%s': %s\n"
msgstr "无法运行命令 '%s'：%s\n"

#: gpg-interface.c
msgid "could not create temporary file"
msgstr "不能创建临时文件"

#: gpg-interface.c
#, c-format
msgid "failed writing detached signature to '%s'"
msgstr "无法将分离式签名写入 '%s'"

#: gpg-interface.c
msgid ""
"gpg.ssh.allowedSignersFile needs to be configured and exist for ssh "
"signature verification"
msgstr "ssh 签名验证需要 gpg.ssh.allowedSignersFile 被设置且存在"

#: gpg-interface.c
msgid ""
"ssh-keygen -Y find-principals/verify is needed for ssh signature "
"verification (available in openssh version 8.2p1+)"
msgstr ""
"ssh 签名验证需要 ssh-keygen -Y find-principals/verify \n"
"（openssh 8.2p1+ 版本可用）"

#: gpg-interface.c
#, c-format
msgid "ssh signing revocation file configured but not found: %s"
msgstr "设置了 ssh 签名吊销文件但无法找到：%s"

#: gpg-interface.c
#, c-format
msgid "bad/incompatible signature '%s'"
msgstr "坏的/不兼容的签名 '%s‘"

#: gpg-interface.c
#, c-format
msgid "failed to get the ssh fingerprint for key '%s'"
msgstr "无法得到密钥 '%s' 的 ssh 指纹"

#: gpg-interface.c
msgid ""
"either user.signingkey or gpg.ssh.defaultKeyCommand needs to be configured"
msgstr "需要配置 user.signingkey 或者 gpg.ssh.defaultKeyCommand 其中之一"

#: gpg-interface.c
#, c-format
msgid "gpg.ssh.defaultKeyCommand succeeded but returned no keys: %s %s"
msgstr "gpg.ssh.defaultKeyCommand 成功，但没有返回密钥：%s %s"

#: gpg-interface.c
#, c-format
msgid "gpg.ssh.defaultKeyCommand failed: %s %s"
msgstr "gpg.ssh.defaultKeyCommand 失败：%s %s"

#: gpg-interface.c
#, c-format
msgid ""
"gpg failed to sign the data:\n"
"%s"
msgstr ""
"gpg 无法为数据签名：\n"
"%s"

#: gpg-interface.c
msgid "user.signingKey needs to be set for ssh signing"
msgstr "ssh 签名需要设置 user.signingKey"

#: gpg-interface.c
#, c-format
msgid "failed writing ssh signing key to '%s'"
msgstr "无法将 ssh 签名密钥写入 '%s'"

#: gpg-interface.c
#, c-format
msgid "failed writing ssh signing key buffer to '%s'"
msgstr "无法将 ssh 签名密钥缓冲区写入 '%s'"

#: gpg-interface.c
msgid ""
"ssh-keygen -Y sign is needed for ssh signing (available in openssh version "
"8.2p1+)"
msgstr "ssh 签名需要 ssh-keygen -Y sign （openssh 8.2p1+ 版本可用）"

#: gpg-interface.c
#, c-format
msgid "failed reading ssh signing data buffer from '%s'"
msgstr "无法从 '%s' 读入 ssh 签名数据"

#: graph.c
#, c-format
msgid "ignored invalid color '%.*s' in log.graphColors"
msgstr "忽略 log.graphColors 中无效的颜色 '%.*s'"

#: grep.c
msgid ""
"given pattern contains NULL byte (via -f <file>). This is only supported "
"with -P under PCRE v2"
msgstr ""
"给定的模式包含 NULL 字符（通过 -f <文件> 参数）。只有 PCRE v2 下的 -P 支持此"
"功能"

#: grep.c
#, c-format
msgid "'%s': unable to read %s"
msgstr "'%s'：无法读取 %s"

#: grep.c
#, c-format
msgid "'%s': short read"
msgstr "'%s'：读取不完整"

#: help.c
msgid "start a working area (see also: git help tutorial)"
msgstr "开始一个工作区（参见：git help tutorial）"

#: help.c
msgid "work on the current change (see also: git help everyday)"
msgstr "在当前变更上工作（参见：git help everyday）"

#: help.c
msgid "examine the history and state (see also: git help revisions)"
msgstr "检查历史和状态（参见：git help revisions）"

#: help.c
msgid "grow, mark and tweak your common history"
msgstr "扩展、标记和调校您的历史记录"

#: help.c
msgid "collaborate (see also: git help workflows)"
msgstr "协同（参见：git help workflows）"

#: help.c
msgid "Main Porcelain Commands"
msgstr "主要的上层命令"

#: help.c
msgid "Ancillary Commands / Manipulators"
msgstr "辅助命令/操作者"

#: help.c
msgid "Ancillary Commands / Interrogators"
msgstr "辅助命令/询问者"

#: help.c
msgid "Interacting with Others"
msgstr "与其它系统交互"

#: help.c
msgid "Low-level Commands / Manipulators"
msgstr "低级命令/操作者"

#: help.c
msgid "Low-level Commands / Interrogators"
msgstr "低级命令/询问者"

#: help.c
msgid "Low-level Commands / Syncing Repositories"
msgstr "低级命令/同步仓库"

#: help.c
msgid "Low-level Commands / Internal Helpers"
msgstr "低级命令/内部助手"

#: help.c
msgid "User-facing repository, command and file interfaces"
msgstr "面向用户的仓库、命令和文件接口"

#: help.c
msgid "Developer-facing file formats, protocols and other interfaces"
msgstr "面向开发者的文件格式、协议和其他接口"

#: help.c
#, c-format
msgid "available git commands in '%s'"
msgstr "在 '%s' 下可用的 git 命令"

#: help.c
msgid "git commands available from elsewhere on your $PATH"
msgstr "在 $PATH 路径中的其他地方可用的 git 命令"

#: help.c
msgid "These are common Git commands used in various situations:"
msgstr "这些是各种场合常见的 Git 命令："

#: help.c
msgid "The Git concept guides are:"
msgstr "Git 概念向导有："

#: help.c
msgid "User-facing repository, command and file interfaces:"
msgstr "面向用户的仓库、命令和文件接口："

#: help.c
msgid "File formats, protocols and other developer interfaces:"
msgstr "文件格式、协议和其他开发者接口列表："

#: help.c
msgid "External commands"
msgstr "外部命令"

#: help.c
msgid "Command aliases"
msgstr "命令别名"

#: help.c
msgid "See 'git help <command>' to read about a specific subcommand"
msgstr "执行　'git help <command>' 来了解特定子命令"

#: help.c
#, c-format
msgid ""
"'%s' appears to be a git command, but we were not\n"
"able to execute it. Maybe git-%s is broken?"
msgstr ""
"'%s' 像是一个 git 命令，但却无法运行。\n"
"可能是 git-%s 受损？"

#: help.c
#, c-format
msgid "git: '%s' is not a git command. See 'git --help'."
msgstr "git：'%s' 不是一个 git 命令。参见 'git --help'。"

#: help.c
msgid "Uh oh. Your system reports no Git commands at all."
msgstr "唉呀，您的系统中未发现 Git 命令。"

#: help.c
#, c-format
msgid "WARNING: You called a Git command named '%s', which does not exist."
msgstr "警告：您运行了一个并不存在的 Git 命令 '%s'。"

#: help.c
#, c-format
msgid "Continuing under the assumption that you meant '%s'."
msgstr "假定您想要的是 '%s' 并继续。"

#: help.c
#, c-format
msgid "Run '%s' instead [y/N]? "
msgstr "取而代之运行 '%s' [y/N]？"

#: help.c
#, c-format
msgid "Continuing in %0.1f seconds, assuming that you meant '%s'."
msgstr "假定您想要的是 '%2$s'，在 %1$0.1f 秒钟后继续。"

#: help.c
msgid ""
"\n"
"The most similar command is"
msgid_plural ""
"\n"
"The most similar commands are"
msgstr[0] ""
"\n"
"最相似的命令是"
msgstr[1] ""
"\n"
"最相似的命令是"

#: help.c
msgid "git version [--build-options]"
msgstr "git version [--build-options]"

#: help.c
#, c-format
msgid "%s: %s - %s"
msgstr "%s：%s - %s"

#: help.c
msgid ""
"\n"
"Did you mean this?"
msgid_plural ""
"\n"
"Did you mean one of these?"
msgstr[0] ""
"\n"
"您指的是这个么？"
msgstr[1] ""
"\n"
"您指的是这其中的某一个么？"

#: hook.c
#, c-format
msgid ""
"The '%s' hook was ignored because it's not set as executable.\n"
"You can disable this warning with `git config set advice.ignoredHook false`."
msgstr ""
"因为没有将钩子 '%s' 设置为可执行，钩子被忽略。您可以通过\n"
"配置 `git config set advice.ignoredHook false` 来关闭这条警告。"

#: http-fetch.c
msgid "not a git repository"
msgstr "不是 git 仓库"

#: http-fetch.c
#, c-format
msgid "argument to --packfile must be a valid hash (got '%s')"
msgstr "--packfile 的参数必须是有效的哈希值（得到 '%s'）"

#: http.c
#, c-format
msgid "negative value for http.postBuffer; defaulting to %d"
msgstr "http.postBuffer 为负值，默认为 %d"

#: http.c
msgid "Delegation control is not supported with cURL < 7.22.0"
msgstr "不支持委托控制，因为 cURL < 7.22.0"

#: http.c
msgid "Unknown value for http.proactiveauth"
msgstr "http.proactiveauth 为未知取值"

#: http.c
#, c-format
msgid "Unsupported SSL backend '%s'. Supported SSL backends:"
msgstr "不支持的 SSL 后端 '%s'。支持的 SSL 后端："

#: http.c
#, c-format
msgid "Could not set SSL backend to '%s': cURL was built without SSL backends"
msgstr "无法设置 SSL 后端为 '%s'：cURL: cURL 没有使用 SSL 后端构建"

#: http.c
#, c-format
msgid "Could not set SSL backend to '%s': already set"
msgstr "无法将 SSL 后端设置为 '%s'：已经设置"

#: http.c
msgid "refusing to read cookies from http.cookiefile '-'"
msgstr "拒绝从 http.cookiefile '-' 读取 cookies"

#: http.c
msgid "ignoring http.savecookies for empty http.cookiefile"
msgstr "因为 http.cookiefile 为空，忽略 http.savecookies"

#: http.c
#, c-format
msgid ""
"unable to update url base from redirection:\n"
"  asked for: %s\n"
"   redirect: %s"
msgstr ""
"不能更新重定向的 url base：\n"
"     请求：%s\n"
"   重定向：%s"

#: ident.c
msgid "Author identity unknown\n"
msgstr "作者身份未知\n"

#: ident.c
msgid "Committer identity unknown\n"
msgstr "提交者身份未知\n"

#: ident.c
msgid ""
"\n"
"*** Please tell me who you are.\n"
"\n"
"Run\n"
"\n"
"  git config --global user.email \"you@example.com\"\n"
"  git config --global user.name \"Your Name\"\n"
"\n"
"to set your account's default identity.\n"
"Omit --global to set the identity only in this repository.\n"
"\n"
msgstr ""
"\n"
"*** 请告诉我您是谁。\n"
"\n"
"运行\n"
"\n"
"  git config --global user.email \"you@example.com\"\n"
"  git config --global user.name \"Your Name\"\n"
"\n"
"来设置您账号的缺省身份标识。\n"
"如果仅在本仓库设置身份标识，则省略 --global 参数。\n"
"\n"

#: ident.c
msgid "no email was given and auto-detection is disabled"
msgstr "未提供邮件地址且自动探测被禁用"

#: ident.c
#, c-format
msgid "unable to auto-detect email address (got '%s')"
msgstr "无法自动探测邮件地址（得到 '%s'）"

#: ident.c
msgid "no name was given and auto-detection is disabled"
msgstr "未提供姓名且自动探测被禁用"

#: ident.c
#, c-format
msgid "unable to auto-detect name (got '%s')"
msgstr "无法自动探测姓名（得到 '%s'）"

#: ident.c
#, c-format
msgid "empty ident name (for <%s>) not allowed"
msgstr "不允许空的姓名（对于 <%s>）"

#: ident.c
#, c-format
msgid "name consists only of disallowed characters: %s"
msgstr "姓名中仅包含禁用字符：%s"

#: list-objects-filter-options.c
msgid "expected 'tree:<depth>'"
msgstr "期望 'tree:<深度>'"

#: list-objects-filter-options.c
msgid "sparse:path filters support has been dropped"
msgstr "sparse:path 过滤器支持已被删除"

#: list-objects-filter-options.c
#, c-format
msgid "'%s' for 'object:type=<type>' is not a valid object type"
msgstr "'object:type=<type>' 的值 '%s' 不是有效的对象类型"

#: list-objects-filter-options.c
#, c-format
msgid "invalid filter-spec '%s'"
msgstr "无效的过滤器表达式 '%s'"

#: list-objects-filter-options.c
#, c-format
msgid "must escape char in sub-filter-spec: '%c'"
msgstr "必须对 sub-filter-spec 中的字符进行转义：'%c'"

#: list-objects-filter-options.c
msgid "expected something after combine:"
msgstr "期望在组合后有一些东西："

#: list-objects-filter-options.c
msgid "multiple filter-specs cannot be combined"
msgstr "不能混用多种过滤规格"

#: list-objects-filter-options.c
msgid "unable to upgrade repository format to support partial clone"
msgstr "无法升级仓库格式以支持部分克隆"

#: list-objects-filter-options.h
msgid "args"
msgstr "参数"

#: list-objects-filter-options.h
msgid "object filtering"
msgstr "对象过滤"

#: list-objects-filter.c
#, c-format
msgid "unable to access sparse blob in '%s'"
msgstr "不能访问 '%s' 中的稀疏数据对象"

#: list-objects-filter.c
#, c-format
msgid "unable to parse sparse filter data in %s"
msgstr "无法解析 %s 中的稀疏过滤器数据"

#: list-objects.c
#, c-format
msgid "entry '%s' in tree %s has tree mode, but is not a tree"
msgstr "树 %2$s 中的条目 '%1$s' 具有树的模式，但不是一个树对象"

#: list-objects.c
#, c-format
msgid "entry '%s' in tree %s has blob mode, but is not a blob"
msgstr "树 %2$s 中的条目 '%1$s' 具有数据对象的模式，但不是一个数据对象"

#: list-objects.c
#, c-format
msgid "unable to load root tree for commit %s"
msgstr "无法为提交 %s 加载根树"

#: lockfile.c
#, c-format
msgid ""
"Unable to create '%s.lock': %s.\n"
"\n"
"Another git process seems to be running in this repository, e.g.\n"
"an editor opened by 'git commit'. Please make sure all processes\n"
"are terminated then try again. If it still fails, a git process\n"
"may have crashed in this repository earlier:\n"
"remove the file manually to continue."
msgstr ""
"无法创建 '%s.lock'：%s。\n"
"\n"
"似乎另外一个 git 进程在这个仓库中运行，例如：'git commit' 命令打\n"
"开了一个编辑器。请确认所有进程都已经关闭然后重试。如果仍然报错，\n"
"可能之前有一个 git 进程在这个仓库中异常退出：\n"
"手动删除这个文件再继续。"

#: lockfile.c
#, c-format
msgid "Unable to create '%s.lock': %s"
msgstr "不能创建 '%s.lock'：%s"

#: log-tree.c
msgid "unable to create temporary object directory"
msgstr "无法创建临时对象目录"

#: loose.c
#, c-format
msgid "could not write loose object index %s"
msgstr "不能写入松散对象索引 %s"

#: loose.c
#, c-format
msgid "failed to write loose object index %s"
msgstr "无法写入松散对象索引 %s"

#: ls-refs.c
#, c-format
msgid "unexpected line: '%s'"
msgstr "意外的行：'%s'"

#: ls-refs.c
msgid "expected flush after ls-refs arguments"
msgstr "在 ls-refs 参数后应该有一个 flush 包"

#: mailinfo.c
msgid "quoted CRLF detected"
msgstr "检测到被引用的 CRLF"

#: mem-pool.c strbuf.c wrapper.c
#, c-format
msgid "unable to format message: %s"
msgstr "无法格式化消息：%s"

#: merge-ll.c
#, c-format
msgid "invalid marker-size '%s', expecting an integer"
msgstr "无效的标记大小 '%s'，应为一个整数"

#: merge-ort.c merge-recursive.c
#, c-format
msgid "Failed to merge submodule %s (not checked out)"
msgstr "无法合并子模组 %s （没有检出）"

#: merge-ort.c
#, c-format
msgid "Failed to merge submodule %s (no merge base)"
msgstr "无法合并子模组 %s （没有合并基线）"

#: merge-ort.c merge-recursive.c
#, c-format
msgid "Failed to merge submodule %s (commits not present)"
msgstr "无法合并子模组 %s（提交不存在）"

#: merge-ort.c
#, c-format
msgid "error: failed to merge submodule %s (repository corrupt)"
msgstr "错误：无法合并子模组 %s（仓库损坏）"

#: merge-ort.c merge-recursive.c
#, c-format
msgid "Failed to merge submodule %s (commits don't follow merge-base)"
msgstr "无法合并子模组 %s （提交未跟随合并基线）"

#: merge-ort.c
#, c-format
msgid "Note: Fast-forwarding submodule %s to %s"
msgstr "注意：快进子模组 %s 到 %s"

#: merge-ort.c
#, c-format
msgid "Failed to merge submodule %s"
msgstr "无法合并子模组 %s"

#: merge-ort.c
#, c-format
msgid ""
"Failed to merge submodule %s, but a possible merge resolution exists: %s"
msgstr "无法合并子模组 %s，但是存在一个可能的合并方案：%s"

#: merge-ort.c
#, c-format
msgid ""
"Failed to merge submodule %s, but multiple possible merges exist:\n"
"%s"
msgstr ""
"无法合并子模组 %s，但是存在多个可能的合并：\n"
"%s"

#: merge-ort.c
#, c-format
msgid "error: failed to execute internal merge for %s"
msgstr "错误：无法为 %s 执行内部合并"

#: merge-ort.c
#, c-format
msgid "error: unable to add %s to database"
msgstr "错误：不能添加 %s 至对象库"

#: merge-ort.c merge-recursive.c
#, c-format
msgid "Auto-merging %s"
msgstr "自动合并 %s"

#: merge-ort.c merge-recursive.c
#, c-format
msgid ""
"CONFLICT (implicit dir rename): Existing file/dir at %s in the way of "
"implicit directory rename(s) putting the following path(s) there: %s."
msgstr ""
"冲突（隐式目录重命名）：处于隐式目录重命名的现存文件/目录 %s，将以下路径放"
"在：%s。"

#: merge-ort.c merge-recursive.c
#, c-format
msgid ""
"CONFLICT (implicit dir rename): Cannot map more than one path to %s; "
"implicit directory renames tried to put these paths there: %s"
msgstr ""
"冲突（隐式目录重命名）：无法映射一个以上路径到 %s，隐式目录重命名尝试将这些路"
"径放置于此：%s"

#: merge-ort.c
#, c-format
msgid ""
"CONFLICT (directory rename split): Unclear where to rename %s to; it was "
"renamed to multiple other directories, with no destination getting a "
"majority of the files."
msgstr ""
"冲突（分割的目录重命名）：不清楚重命名 %s 到哪里，因为它被重命名到多个其他目"
"录中，没有一个目标目录中包含多数文件。"

#: merge-ort.c merge-recursive.c
#, c-format
msgid ""
"WARNING: Avoiding applying %s -> %s rename to %s, because %s itself was "
"renamed."
msgstr "警告：避免应用 %s -> %s 的重命名到 %s，因为 %s 本身已被重命名。"

#: merge-ort.c merge-recursive.c
#, c-format
msgid ""
"Path updated: %s added in %s inside a directory that was renamed in %s; "
"moving it to %s."
msgstr ""
"路径已更新：%s 添加到 %s，位于一个被重命名到 %s 的目录中，将其移动到 %s。"

#: merge-ort.c merge-recursive.c
#, c-format
msgid ""
"Path updated: %s renamed to %s in %s, inside a directory that was renamed in "
"%s; moving it to %s."
msgstr ""
"路径已更新：%1$s 重命名为 %3$s 中的 %2$s，而该目录被重命名到 %4$s 中，将其移"
"动到 %5$s。"

#: merge-ort.c merge-recursive.c
#, c-format
msgid ""
"CONFLICT (file location): %s added in %s inside a directory that was renamed "
"in %s, suggesting it should perhaps be moved to %s."
msgstr ""
"冲突（文件位置）：%s 添加到 %s，位于一个被重命名为 %s 的目录中，建议将其移动"
"到 %s。"

#: merge-ort.c merge-recursive.c
#, c-format
msgid ""
"CONFLICT (file location): %s renamed to %s in %s, inside a directory that "
"was renamed in %s, suggesting it should perhaps be moved to %s."
msgstr ""
"冲突（文件位置）：%1$s 重命名为 %3$s 中的 %2$s，而该目录被重命名到 %4$s 中，"
"建议将其移动到 %5$s。"

#: merge-ort.c
#, c-format
msgid "CONFLICT (rename/rename): %s renamed to %s in %s and to %s in %s."
msgstr ""
"冲突（重命名/重命名）：%1$s 重命名为 %3$s 中的 %2$s，以及在 %5$s 中的 %4$s。"

#: merge-ort.c
#, c-format
msgid ""
"CONFLICT (rename involved in collision): rename of %s -> %s has content "
"conflicts AND collides with another path; this may result in nested conflict "
"markers."
msgstr ""
"冲突（重命名卷入冲突）：重命名 %s -> %s 有内容冲突并且和另外一个路径碰撞，这"
"可能导致嵌套的冲突标签。"

#: merge-ort.c
#, c-format
msgid "CONFLICT (rename/delete): %s renamed to %s in %s, but deleted in %s."
msgstr "冲突（重命名/删除）：%1$s 在 %3$s 中重命名为 %2$s，但在 %4$s 中删除。"

#: merge-ort.c
#, c-format
msgid "error: cannot read object %s"
msgstr "错误：不能读取对象 %s"

#: merge-ort.c
#, c-format
msgid "error: object %s is not a blob"
msgstr "错误：对象 %s 不是一个数据对象"

#: merge-ort.c
#, c-format
msgid ""
"CONFLICT (file/directory): directory in the way of %s from %s; moving it to "
"%s instead."
msgstr "冲突（文件/目录）：目录已存在于 %2$s 中的 %1$s，将其移动到 %3$s。"

#: merge-ort.c
#, c-format
msgid ""
"CONFLICT (distinct types): %s had different types on each side; renamed both "
"of them so each can be recorded somewhere."
msgstr ""
"冲突（不同类型）：%s 在两侧有不同的类型，将两者都重命名以便它们能记录在不同位"
"置。"

#: merge-ort.c
#, c-format
msgid ""
"CONFLICT (distinct types): %s had different types on each side; renamed one "
"of them so each can be recorded somewhere."
msgstr ""
"冲突（不同类型）：%s 在两侧有不同的类型，将其中之一重命名以便它们能记录在不同"
"位置。"

#: merge-ort.c merge-recursive.c
msgid "content"
msgstr "内容"

#: merge-ort.c merge-recursive.c
msgid "add/add"
msgstr "添加/添加"

#: merge-ort.c merge-recursive.c
msgid "submodule"
msgstr "子模组"

#: merge-ort.c merge-recursive.c
#, c-format
msgid "CONFLICT (%s): Merge conflict in %s"
msgstr "冲突（%s）：合并冲突于 %s"

#: merge-ort.c
#, c-format
msgid ""
"CONFLICT (modify/delete): %s deleted in %s and modified in %s.  Version %s "
"of %s left in tree."
msgstr ""
"冲突（修改/删除）：%1$s 在 %2$s 中被删除，在 %3$s 中被修改。%5$s 的 %4$s 版本"
"在树中被保留。"

#. TRANSLATORS: This is a line of advice to resolve a merge
#. conflict in a submodule. The first argument is the submodule
#. name, and the second argument is the abbreviated id of the
#. commit that needs to be merged.  For example:
#.  - go to submodule (mysubmodule), and either merge commit abc1234"
#.
#: merge-ort.c
#, c-format
msgid ""
" - go to submodule (%s), and either merge commit %s\n"
"   or update to an existing commit which has merged those changes\n"
msgstr ""
" - 进入子模组（%s），要么合并提交 %s\n"
"   要么更新至已合并这些变更的提交\n"

#: merge-ort.c
#, c-format
msgid ""
"Recursive merging with submodules currently only supports trivial cases.\n"
"Please manually handle the merging of each conflicted submodule.\n"
"This can be accomplished with the following steps:\n"
"%s - come back to superproject and run:\n"
"\n"
"      git add %s\n"
"\n"
"   to record the above merge or update\n"
" - resolve any other conflicts in the superproject\n"
" - commit the resulting index in the superproject\n"
msgstr ""
"子模组内的递归合并现在只支持简单的情况。\n"
"请手动合并每个有冲突的子模组。\n"
"这可以通过下列步骤完成：\n"
"%s - 回到上级项目并运行：\n"
"\n"
"      git add %s\n"
"\n"
"   来记录上述的合并或更新\n"
" - 解决上级项目中的其他冲突\n"
" - 提交上级项目中的结果索引\n"

#. TRANSLATORS: The %s arguments are: 1) tree hash of a merge
#. base, and 2-3) the trees for the two trees we're merging.
#.
#: merge-ort.c
#, c-format
msgid "collecting merge info failed for trees %s, %s, %s"
msgstr "无法收集树 %s、%s、%s 的合并信息"

#: merge-recursive.c
msgid "(bad commit)\n"
msgstr "（坏提交）\n"

#: merge-recursive.c
#, c-format
msgid "add_cacheinfo failed for path '%s'; merge aborting."
msgstr "add_cacheinfo 对路径 '%s' 执行失败，合并终止。"

#: merge-recursive.c
#, c-format
msgid "add_cacheinfo failed to refresh for path '%s'; merge aborting."
msgstr "add_cacheinfo 无法刷新路径 '%s'，合并终止。"

#: merge-recursive.c
#, c-format
msgid "failed to create path '%s'%s"
msgstr "无法创建路径 '%s'%s"

#: merge-recursive.c
#, c-format
msgid "Removing %s to make room for subdirectory\n"
msgstr "删除 %s 以便为子目录留出空间\n"

#: merge-recursive.c
msgid ": perhaps a D/F conflict?"
msgstr "：可能是一个目录/文件冲突？"

#: merge-recursive.c
#, c-format
msgid "refusing to lose untracked file at '%s'"
msgstr "拒绝丢弃 '%s' 中的未跟踪文件"

#: merge-recursive.c
#, c-format
msgid "blob expected for %s '%s'"
msgstr "%s '%s' 应为数据对象"

#: merge-recursive.c
#, c-format
msgid "failed to open '%s': %s"
msgstr "无法打开 '%s'：%s"

#: merge-recursive.c
#, c-format
msgid "failed to symlink '%s': %s"
msgstr "无法创建符号链接 '%s'：%s"

#: merge-recursive.c
#, c-format
msgid "do not know what to do with %06o %s '%s'"
msgstr "不知道如何处理 %06o %s '%s'"

#: merge-recursive.c
#, c-format
msgid "Failed to merge submodule %s (repository corrupt)"
msgstr "无法合并子模组 %s（仓库损坏）"

#: merge-recursive.c
#, c-format
msgid "Fast-forwarding submodule %s to the following commit:"
msgstr "子模组 %s 快进到如下提交："

#: merge-recursive.c
#, c-format
msgid "Fast-forwarding submodule %s"
msgstr "快进子模组 %s"

#: merge-recursive.c
#, c-format
msgid "Failed to merge submodule %s (merge following commits not found)"
msgstr "无法合并子模组 %s （没发现合并跟随的提交）"

#: merge-recursive.c
#, c-format
msgid "Failed to merge submodule %s (not fast-forward)"
msgstr "无法合并子模组 %s（非快进）"

#: merge-recursive.c
msgid "Found a possible merge resolution for the submodule:\n"
msgstr "找到子模组的一个可能的合并方案：\n"

#: merge-recursive.c
#, c-format
msgid ""
"If this is correct simply add it to the index for example\n"
"by using:\n"
"\n"
"  git update-index --cacheinfo 160000 %s \"%s\"\n"
"\n"
"which will accept this suggestion.\n"
msgstr ""
"如果这个正确，将其添加到索引，例如使用命令：\n"
"\n"
"  git update-index --cacheinfo 160000 %s \"%s\"\n"
"\n"
"以接受此建议。\n"

#: merge-recursive.c
#, c-format
msgid "Failed to merge submodule %s (multiple merges found)"
msgstr "无法合并子模组 %s （发现多个合并）"

#: merge-recursive.c
msgid "failed to execute internal merge"
msgstr "无法执行内部合并"

#: merge-recursive.c
#, c-format
msgid "unable to add %s to database"
msgstr "不能添加 %s 至对象库"

#: merge-recursive.c
#, c-format
msgid "Error: Refusing to lose untracked file at %s; writing to %s instead."
msgstr "错误：拒绝丢失未跟踪文件 '%s'，而是写入 %s。"

#: merge-recursive.c
#, c-format
msgid ""
"CONFLICT (%s/delete): %s deleted in %s and %s in %s. Version %s of %s left "
"in tree."
msgstr ""
"冲突（%1$s/删除）：%2$s 在 %3$s 中被删除，在 %5$s 中被 %4$s。%7$s 的 %6$s 版"
"本被保留。"

#: merge-recursive.c
#, c-format
msgid ""
"CONFLICT (%s/delete): %s deleted in %s and %s to %s in %s. Version %s of %s "
"left in tree."
msgstr ""
"冲突（%1$s/删除）：%2$s 在 %3$s 中被删除，在 %6$s 中的 %5$s 被 %4$s。%8$s 的 "
"%7$s 版本被保留。"

#: merge-recursive.c
#, c-format
msgid ""
"CONFLICT (%s/delete): %s deleted in %s and %s in %s. Version %s of %s left "
"in tree at %s."
msgstr ""
"冲突（%1$s/删除）：%2$s 在 %3$s 中被删除，在 %5$s 中被 %4$s。%7$s 的 %6$s 版"
"本保留在 %8$s 中。"

#: merge-recursive.c
#, c-format
msgid ""
"CONFLICT (%s/delete): %s deleted in %s and %s to %s in %s. Version %s of %s "
"left in tree at %s."
msgstr ""
"冲突（%1$s/删除）：%2$s 在 %3$s 中被删除，在 %6$s 中的 %5$s 被 %4$s。%8$s 的 "
"%7$s 版本保留在 %9$s 中。"

#: merge-recursive.c
msgid "rename"
msgstr "重命名"

#: merge-recursive.c
msgid "renamed"
msgstr "重命名"

#: merge-recursive.c
#, c-format
msgid "Refusing to lose dirty file at %s"
msgstr "拒绝丢失脏文件 '%s'"

#: merge-recursive.c
#, c-format
msgid "Refusing to lose untracked file at %s, even though it's in the way."
msgstr "拒绝在 '%s' 处失去未跟踪文件，即使它存在于重命名中。"

#: merge-recursive.c
#, c-format
msgid "CONFLICT (rename/add): Rename %s->%s in %s.  Added %s in %s"
msgstr "冲突（重命名/添加）：在 %3$s 中重命名 %1$s->%2$s。在 %5$s 中添加 %4$s"

#: merge-recursive.c
#, c-format
msgid "%s is a directory in %s adding as %s instead"
msgstr "%s 是 %s 中的一个目录而以 %s 为名被添加"

#: merge-recursive.c
#, c-format
msgid "Refusing to lose untracked file at %s; adding as %s instead"
msgstr "拒绝丢失未跟踪文件 '%s'，而是添加为 %s"

#: merge-recursive.c
#, c-format
msgid ""
"CONFLICT (rename/rename): Rename \"%s\"->\"%s\" in branch \"%s\" rename "
"\"%s\"->\"%s\" in \"%s\"%s"
msgstr ""
"冲突（重命名/重命名）：在分支 \"%3$s\" 中重命名 \"%1$s\"->\"%2$s\"，在分支 "
"\"%6$s\" 中重命名 \"%4$s\"->\"%5$s\"%7$s"

#: merge-recursive.c
msgid " (left unresolved)"
msgstr "（留下未解决）"

#: merge-recursive.c
#, c-format
msgid "CONFLICT (rename/rename): Rename %s->%s in %s. Rename %s->%s in %s"
msgstr ""
"冲突（重命名/重命名）：在 %3$s 中重命名 %1$s->%2$s，在 %6$s 中重命名 %4$s-"
">%5$s"

#: merge-recursive.c
#, c-format
msgid ""
"CONFLICT (directory rename split): Unclear where to place %s because "
"directory %s was renamed to multiple other directories, with no destination "
"getting a majority of the files."
msgstr ""
"冲突（分割的目录重命名）：不清楚 %s 应该放在哪里，因为目录 %s 被重命名到多个"
"其它目录，没有目录包含大部分文件。"

#: merge-recursive.c
#, c-format
msgid ""
"CONFLICT (rename/rename): Rename directory %s->%s in %s. Rename directory %s-"
">%s in %s"
msgstr ""
"冲突（重命名/重命名）：在 %3$s 中重命名目录 %1$s->%2$s，在 %6$s 中重命名目录 "
"%4$s->%5$s"

#: merge-recursive.c
#, c-format
msgid "cannot read object %s"
msgstr "不能读取对象 %s"

#: merge-recursive.c
#, c-format
msgid "object %s is not a blob"
msgstr "对象 %s 不是一个数据对象"

#: merge-recursive.c
msgid "modify"
msgstr "修改"

#: merge-recursive.c
msgid "modified"
msgstr "修改"

#: merge-recursive.c
#, c-format
msgid "Skipped %s (merged same as existing)"
msgstr "略过 %s（已经做过相同合并）"

#: merge-recursive.c
#, c-format
msgid "Adding as %s instead"
msgstr "而是以 %s 为名添加"

#: merge-recursive.c
#, c-format
msgid "Removing %s"
msgstr "删除 %s"

#: merge-recursive.c
msgid "file/directory"
msgstr "文件/目录"

#: merge-recursive.c
msgid "directory/file"
msgstr "目录/文件"

#: merge-recursive.c
#, c-format
msgid "CONFLICT (%s): There is a directory with name %s in %s. Adding %s as %s"
msgstr "冲突（%1$s）：在 %3$s 中有一个名为 %2$s 的目录。以 %5$s 为名添加 %4$s"

#: merge-recursive.c
#, c-format
msgid "Adding %s"
msgstr "添加 %s"

#: merge-recursive.c
#, c-format
msgid "CONFLICT (add/add): Merge conflict in %s"
msgstr "冲突（add/add）：合并冲突于 %s"

#: merge-recursive.c
#, c-format
msgid "merging of trees %s and %s failed"
msgstr "无法合并树 %s 和 %s"

#: merge-recursive.c
msgid "Merging:"
msgstr "合并："

#: merge-recursive.c
#, c-format
msgid "found %u common ancestor:"
msgid_plural "found %u common ancestors:"
msgstr[0] "发现 %u 个共同祖先："
msgstr[1] "发现 %u 个共同祖先："

#: merge-recursive.c
msgid "merge returned no commit"
msgstr "合并未返回提交"

#: merge-recursive.c
#, c-format
msgid "Could not parse object '%s'"
msgstr "不能解析对象 '%s'"

#: merge.c
msgid "failed to read the cache"
msgstr "无法读取缓存"

#: midx-write.c
#, c-format
msgid "failed to add packfile '%s'"
msgstr "无法添加包文件 '%s'"

#: midx-write.c
#, c-format
msgid "failed to open pack-index '%s'"
msgstr "无法打开包索引 '%s'"

#: midx-write.c
#, c-format
msgid "failed to locate object %d in packfile"
msgstr "无法在包文件中定位对象 %d"

#: midx-write.c
msgid "cannot store reverse index file"
msgstr "无法存储反向索引文件"

#: midx-write.c
#, c-format
msgid "could not parse line: %s"
msgstr "不能解析行：%s"

#: midx-write.c
#, c-format
msgid "malformed line: %s"
msgstr "格式错误的行：%s"

#: midx-write.c
msgid "could not load pack"
msgstr "不能载入包"

#: midx-write.c
#, c-format
msgid "could not open index for %s"
msgstr "不能打开 %s 的索引"

#: midx-write.c
#, c-format
msgid "unable to link '%s' to '%s'"
msgstr "无法将 '%s' 链接至 '%s'"

#: midx-write.c midx.c
#, c-format
msgid "failed to clear multi-pack-index at %s"
msgstr "无法清理位于 %s 的多包索引"

#: midx-write.c
msgid "cannot write incremental MIDX with bitmap"
msgstr "无法使用位图写入增量 MIDX"

#: midx-write.c
msgid "ignoring existing multi-pack-index; checksum mismatch"
msgstr "忽略已存在的多包索引，校验码不匹配"

#: midx-write.c
msgid "Adding packfiles to multi-pack-index"
msgstr "添加包文件到多包索引"

#: midx-write.c
#, c-format
msgid "unknown preferred pack: '%s'"
msgstr "未知的首选包：'%s'"

#: midx-write.c
#, c-format
msgid "cannot select preferred pack %s with no objects"
msgstr "不能选择没有对象的首选包 %s"

#: midx-write.c
#, c-format
msgid "did not see pack-file %s to drop"
msgstr "没有看到要丢弃的包文件 %s"

#: midx-write.c
#, c-format
msgid "preferred pack '%s' is expired"
msgstr "首选包 '%s' 已过期"

#: midx-write.c
msgid "no pack files to index."
msgstr "没有要索引的包文件。"

#: midx-write.c
msgid "refusing to write multi-pack .bitmap without any objects"
msgstr "拒绝写入没有任何对象的多包位图"

#: midx-write.c
msgid "unable to create temporary MIDX layer"
msgstr "无法创建临时 MIDX 层"

#: midx-write.c
msgid "could not write multi-pack bitmap"
msgstr "无法写入多包位图"

#: midx-write.c
msgid "unable to open multi-pack-index chain file"
msgstr "无法打开多包索引链文件"

#: midx-write.c
msgid "unable to rename new multi-pack-index layer"
msgstr "无法重命名新的多包索引层"

#: midx-write.c
msgid "could not write multi-pack-index"
msgstr "无法写入多包索引"

#: midx-write.c
msgid "cannot expire packs from an incremental multi-pack-index"
msgstr "增量多包索引中的包不能过期"

#: midx-write.c
msgid "Counting referenced objects"
msgstr "正在对引用对象计数"

#: midx-write.c
msgid "Finding and deleting unreferenced packfiles"
msgstr "正在查找和删除未引用的包文件"

#: midx-write.c
msgid "cannot repack an incremental multi-pack-index"
msgstr "无法重新打包增量多包索引"

#: midx-write.c
msgid "could not start pack-objects"
msgstr "不能开始 pack-objects"

#: midx-write.c
msgid "could not finish pack-objects"
msgstr "不能结束 pack-objects"

#: midx.c
msgid "multi-pack-index OID fanout is of the wrong size"
msgstr "多包索引的对象 ID 扇出表大小错误"

#: midx.c
#, c-format
msgid ""
"oid fanout out of order: fanout[%d] = %<PRIx32> > %<PRIx32> = fanout[%d]"
msgstr "对象 ID 扇出失序：fanout[%d] = %<PRIx32> > %<PRIx32> = fanout[%d]"

#: midx.c
msgid "multi-pack-index OID lookup chunk is the wrong size"
msgstr "多包索引的对象 ID 查询块大小错误"

#: midx.c
msgid "multi-pack-index object offset chunk is the wrong size"
msgstr "多包索引的对象 ID 偏移块大小错误"

#: midx.c
#, c-format
msgid "multi-pack-index file %s is too small"
msgstr "多包索引文件 %s 太小"

#: midx.c
#, c-format
msgid "multi-pack-index signature 0x%08x does not match signature 0x%08x"
msgstr "多包索引签名 0x%08x 和签名 0x%08x 不匹配"

#: midx.c
#, c-format
msgid "multi-pack-index version %d not recognized"
msgstr "multi-pack-index 版本 %d 不能被识别"

#: midx.c
#, c-format
msgid "multi-pack-index hash version %u does not match version %u"
msgstr "多包索引哈希版本 %u 和版本 %u 不匹配"

#: midx.c
msgid "multi-pack-index required pack-name chunk missing or corrupted"
msgstr "多包索引必需的包名块缺失或损坏"

#: midx.c
msgid "multi-pack-index required OID fanout chunk missing or corrupted"
msgstr "多包索引必需的对象 ID 扇出块缺失或损坏"

#: midx.c
msgid "multi-pack-index required OID lookup chunk missing or corrupted"
msgstr "多包索引必需的对象 ID 查询块缺失或损坏"

#: midx.c
msgid "multi-pack-index required object offsets chunk missing or corrupted"
msgstr "多包索引必需的对象偏移块缺少或损坏"

#: midx.c
msgid "multi-pack-index pack-name chunk is too short"
msgstr "多包索引包名块过短"

#: midx.c
#, c-format
msgid "multi-pack-index pack names out of order: '%s' before '%s'"
msgstr "多包索引包名无序：'%s' 在 '%s' 之前"

#: midx.c
msgid "multi-pack-index chain file too small"
msgstr "多包索引链文件太小"

#: midx.c
#, c-format
msgid "pack count in base MIDX too high: %<PRIuMAX>"
msgstr "基线的 MIDX 中包的数量过高：%<PRIuMAX>"

#: midx.c
#, c-format
msgid "object count in base MIDX too high: %<PRIuMAX>"
msgstr "基线的 MIDX 中对象的数量过高：%<PRIuMAX>"

#: midx.c
#, c-format
msgid "invalid multi-pack-index chain: line '%s' not a hash"
msgstr "无效的多包索引链：第 '%s' 行不是哈希值"

#: midx.c
msgid "unable to find all multi-pack index files"
msgstr "无法找到所有的多包索引文件"

#: midx.c
msgid "invalid MIDX object position, MIDX is likely corrupt"
msgstr "无效的 MIDX 对象位置，MIDX 可能已损坏"

#: midx.c
#, c-format
msgid "bad pack-int-id: %u (%u total packs)"
msgstr "错的 pack-int-id：%u（共有 %u 个包）"

#: midx.c
msgid "MIDX does not contain the BTMP chunk"
msgstr "多包索引中未包含 BTMP 块"

#: midx.c
#, c-format
msgid "could not load bitmapped pack %<PRIu32>"
msgstr "不能打开已被位图索引的包 %<PRIu32>"

#: midx.c
msgid "multi-pack-index stores a 64-bit offset, but off_t is too small"
msgstr "多包索引存储一个64位偏移，但是 off_t 太小"

#: midx.c
msgid "multi-pack-index large offset out of bounds"
msgstr "多包索引大偏移区越界"

#: midx.c
msgid "multi-pack-index file exists, but failed to parse"
msgstr "多包索引文件存在，但无法解析"

#: midx.c
msgid "incorrect checksum"
msgstr "不正确的校验码"

#: midx.c
msgid "Looking for referenced packfiles"
msgstr "正在查找引用的包文件"

#: midx.c
msgid "the midx contains no oid"
msgstr "midx 不包含 oid"

#: midx.c
msgid "Verifying OID order in multi-pack-index"
msgstr "校验多包索引中的 OID 顺序"

#: midx.c
#, c-format
msgid "oid lookup out of order: oid[%d] = %s >= %s = oid[%d]"
msgstr "对象 ID 查询无序：oid[%d] = %s >= %s = oid[%d]"

#: midx.c
msgid "Sorting objects by packfile"
msgstr "通过包文件为对象排序"

#: midx.c
msgid "Verifying object offsets"
msgstr "校验对象偏移"

#: midx.c
#, c-format
msgid "failed to load pack entry for oid[%d] = %s"
msgstr "无法为 oid[%d] = %s 加载包条目"

#: midx.c
#, c-format
msgid "failed to load pack-index for packfile %s"
msgstr "无法为包文件 %s 加载包索引"

#: midx.c
#, c-format
msgid "incorrect object offset for oid[%d] = %s: %<PRIx64> != %<PRIx64>"
msgstr "oid[%d] = %s 错误的对象偏移：%<PRIx64> != %<PRIx64>"

#: name-hash.c
#, c-format
msgid "unable to create lazy_dir thread: %s"
msgstr "不能创建 lazy_dir 线程：%s"

#: name-hash.c
#, c-format
msgid "unable to create lazy_name thread: %s"
msgstr "不能创建 lazy_name 线程：%s"

#: name-hash.c
#, c-format
msgid "unable to join lazy_name thread: %s"
msgstr "不能加入 lazy_name 线程：%s"

#: notes-merge.c
#, c-format
msgid ""
"You have not concluded your previous notes merge (%s exists).\n"
"Please, use 'git notes merge --commit' or 'git notes merge --abort' to "
"commit/abort the previous merge before you start a new notes merge."
msgstr ""
"您的前一次注释合并尚未结束（存在 %s）。\n"
"在开始一个新的注释合并之前，请使用 'git notes merge --commit' 或者 'git "
"notes merge --abort' 来提交/终止前一次合并。"

#: notes-merge.c
#, c-format
msgid "You have not concluded your notes merge (%s exists)."
msgstr "您尚未结束注释合并（存在 %s）。"

#: notes-utils.c
msgid "Cannot commit uninitialized/unreferenced notes tree"
msgstr "不能提交未初始化/未引用的注解树"

#: notes-utils.c
#, c-format
msgid "Bad notes.rewriteMode value: '%s'"
msgstr "坏的 notes.rewriteMode 值：'%s'"

#: notes-utils.c
#, c-format
msgid "Refusing to rewrite notes in %s (outside of refs/notes/)"
msgstr "拒绝向 %s（在 refs/notes/ 之外）写入注解"

#. TRANSLATORS: The first %s is the name of
#. the environment variable, the second %s is
#. its value.
#.
#: notes-utils.c
#, c-format
msgid "Bad %s value: '%s'"
msgstr "坏的 %s 值：'%s'"

#: object-file-convert.c
msgid "failed to decode tree entry"
msgstr "无法解码树对象"

#: object-file-convert.c
#, c-format
msgid "failed to map tree entry for %s"
msgstr "无法为 %s 映射树对象"

#: object-file-convert.c
#, c-format
msgid "bad %s in commit"
msgstr "提交中有错误的 %s"

#: object-file-convert.c
#, c-format
msgid "unable to map %s %s in commit object"
msgstr "无法将 %s %s 映射到提交对象中"

#: object-file-convert.c
#, c-format
msgid "Failed to convert object from %s to %s"
msgstr "无法将对象从 %s 转换为 %s"

#: object-file.c
#, c-format
msgid "object directory %s does not exist; check .git/objects/info/alternates"
msgstr "对象目录 %s 不存在，检查 .git/objects/info/alternates"

#: object-file.c
#, c-format
msgid "unable to normalize alternate object path: %s"
msgstr "无法规范化备用对象路径：%s"

#: object-file.c
#, c-format
msgid "%s: ignoring alternate object stores, nesting too deep"
msgstr "%s：忽略备用对象库，嵌套太深"

#: object-file.c
msgid "unable to fdopen alternates lockfile"
msgstr "无法 fdopen 替换锁文件"

#: object-file.c
msgid "unable to read alternates file"
msgstr "无法读取替代文件"

#: object-file.c
msgid "unable to move new alternates file into place"
msgstr "无法将新的备用文件移动到位"

#: object-file.c
#, c-format
msgid "path '%s' does not exist"
msgstr "路径 '%s' 不存在"

#: object-file.c
#, c-format
msgid "reference repository '%s' as a linked checkout is not supported yet."
msgstr "尚不支持将参考仓库 '%s' 作为一个链接检出。"

#: object-file.c
#, c-format
msgid "reference repository '%s' is not a local repository."
msgstr "参考仓库 '%s' 不是一个本地仓库。"

#: object-file.c
#, c-format
msgid "reference repository '%s' is shallow"
msgstr "参考仓库 '%s' 是一个浅克隆"

#: object-file.c
#, c-format
msgid "reference repository '%s' is grafted"
msgstr "参考仓库 '%s' 已被移植"

#: object-file.c
#, c-format
msgid "could not find object directory matching %s"
msgstr "无法找到和 %s 匹配的对象目录"

#: object-file.c
#, c-format
msgid "invalid line while parsing alternate refs: %s"
msgstr "解析备用引用时无效的行：%s"

#: object-file.c
#, c-format
msgid "attempting to mmap %<PRIuMAX> over limit %<PRIuMAX>"
msgstr "尝试 mmap %<PRIuMAX>，超过了最大值 %<PRIuMAX>"

#: object-file.c
#, c-format
msgid "mmap failed%s"
msgstr "mmap 失败%s"

#: object-file.c
#, c-format
msgid "object file %s is empty"
msgstr "对象文件 %s 为空"

#: object-file.c
#, c-format
msgid "corrupt loose object '%s'"
msgstr "损坏的松散对象 '%s'"

#: object-file.c
#, c-format
msgid "garbage at end of loose object '%s'"
msgstr "松散对象 '%s' 后面有垃圾数据"

#: object-file.c
#, c-format
msgid "unable to open loose object %s"
msgstr "无法打开松散对象 %s"

#: object-file.c
#, c-format
msgid "unable to parse %s header"
msgstr "无法解析 %s 头部"

#: object-file.c
msgid "invalid object type"
msgstr "无效的对象类型"

#: object-file.c
#, c-format
msgid "unable to unpack %s header"
msgstr "无法解开 %s 头部"

#: object-file.c
#, c-format
msgid "header for %s too long, exceeds %d bytes"
msgstr "%s 的头部太长，超出了 %d 字节"

#: object-file.c
#, c-format
msgid "loose object %s (stored in %s) is corrupt"
msgstr "松散对象 %s（保存在 %s）已损坏"

#: object-file.c
#, c-format
msgid "replacement %s not found for %s"
msgstr "找不到 %2$s 的替代 %1$s"

#: object-file.c
#, c-format
msgid "packed object %s (stored in %s) is corrupt"
msgstr "打包对象 %s（保存在 %s）已损坏"

#: object-file.c
#, c-format
msgid "missing mapping of %s to %s"
msgstr "缺少 %s 到 %s 的映射"

#: object-file.c
#, c-format
msgid "unable to open %s"
msgstr "不能打开 %s"

#: object-file.c
#, c-format
msgid "files '%s' and '%s' differ in contents"
msgstr "文件 '%s' 和 '%s' 的内容不同"

#: object-file.c
#, c-format
msgid "unable to write file %s"
msgstr "无法写文件 %s"

#: object-file.c
#, c-format
msgid "unable to write repeatedly vanishing file %s"
msgstr "无法写入反复消失的文件 %s"

#: object-file.c
#, c-format
msgid "unable to set permission to '%s'"
msgstr "无法为 '%s' 设置权限"

#: object-file.c
msgid "error when closing loose object file"
msgstr "关闭松散对象文件时出错"

#: object-file.c
#, c-format
msgid "insufficient permission for adding an object to repository database %s"
msgstr "权限不足，无法在仓库对象库 %s 中添加对象"

#: object-file.c
msgid "unable to create temporary file"
msgstr "无法创建临时文件"

#: object-file.c
msgid "unable to write loose object file"
msgstr "不能写松散对象文件"

#: object-file.c
#, c-format
msgid "unable to deflate new object %s (%d)"
msgstr "不能压缩新对象 %s（%d）"

#: object-file.c
#, c-format
msgid "deflateEnd on object %s failed (%d)"
msgstr "在对象 %s 上调用 deflateEnd 失败（%d）"

#: object-file.c
#, c-format
msgid "confused by unstable object source data for %s"
msgstr "被 %s 的不稳定对象源数据搞糊涂了"

#: object-file.c
#, c-format
msgid "write stream object %ld != %<PRIuMAX>"
msgstr "写入流对象 %ld != %<PRIuMAX>"

#: object-file.c
#, c-format
msgid "unable to stream deflate new object (%d)"
msgstr "不能流式压缩新对象（%d）"

#: object-file.c
#, c-format
msgid "deflateEnd on stream object failed (%d)"
msgstr "在流对象上调用 deflateEnd 失败（%d）"

#: object-file.c
#, c-format
msgid "unable to create directory %s"
msgstr "无法创建目录 %s"

#: object-file.c
#, c-format
msgid "cannot read object for %s"
msgstr "不能读取对象 %s"

#: object-file.c
#, c-format
msgid "cannot map object %s to %s"
msgstr "无法将对象 %s 映射到 %s"

#: object-file.c
#, c-format
msgid "object fails fsck: %s"
msgstr "对象 fsck 失败：%s"

#: object-file.c
msgid "refusing to create malformed object"
msgstr "拒绝创建格式错误的对象"

#: object-file.c
#, c-format
msgid "read error while indexing %s"
msgstr "索引 %s 时读取错误"

#: object-file.c
#, c-format
msgid "short read while indexing %s"
msgstr "索引 %s 时读入不完整"

#: object-file.c
#, c-format
msgid "%s: failed to insert into database"
msgstr "%s：无法插入数据库"

#: object-file.c
#, c-format
msgid "%s: unsupported file type"
msgstr "%s：不支持的文件类型"

#: object-file.c
#, c-format
msgid "%s is not a valid '%s' object"
msgstr "%s 不是一个有效的 '%s' 对象"

#: object-file.c
#, c-format
msgid "hash mismatch for %s (expected %s)"
msgstr "%s 的哈希值不匹配（预期 %s）"

#: object-file.c
#, c-format
msgid "unable to mmap %s"
msgstr "不能 mmap %s"

#: object-file.c
#, c-format
msgid "unable to unpack header of %s"
msgstr "无法解压缩 %s 的头部"

#: object-file.c
#, c-format
msgid "unable to parse header of %s"
msgstr "无法解析 %s 的头部"

#: object-file.c
#, c-format
msgid "unable to unpack contents of %s"
msgstr "无法解压缩 %s 的内容"

#. TRANSLATORS: This is a line of ambiguous object
#. output shown when we cannot look up or parse the
#. object in question. E.g. "deadbeef [bad object]".
#.
#: object-name.c
#, c-format
msgid "%s [bad object]"
msgstr "%s [坏的对象]"

#. TRANSLATORS: This is a line of ambiguous commit
#. object output. E.g.:
#. *
#.    "deadbeef commit 2021-01-01 - Some Commit Message"
#.
#: object-name.c
#, c-format
msgid "%s commit %s - %s"
msgstr "%s 提交 %s - %s"

#. TRANSLATORS: This is a line of ambiguous
#. tag object output. E.g.:
#. *
#.    "deadbeef tag 2022-01-01 - Some Tag Message"
#. *
#. The second argument is the YYYY-MM-DD found
#. in the tag.
#. *
#. The third argument is the "tag" string
#. from object.c.
#.
#: object-name.c
#, c-format
msgid "%s tag %s - %s"
msgstr "%s 标签 %s - %s"

#. TRANSLATORS: This is a line of ambiguous
#. tag object output where we couldn't parse
#. the tag itself. E.g.:
#. *
#.    "deadbeef [bad tag, could not parse it]"
#.
#: object-name.c
#, c-format
msgid "%s [bad tag, could not parse it]"
msgstr "%s [坏的标签，无法解析]"

#. TRANSLATORS: This is a line of ambiguous <type>
#. object output. E.g. "deadbeef tree".
#.
#: object-name.c
#, c-format
msgid "%s tree"
msgstr "%s 树"

#. TRANSLATORS: This is a line of ambiguous <type>
#. object output. E.g. "deadbeef blob".
#.
#: object-name.c
#, c-format
msgid "%s blob"
msgstr "%s 数据对象"

#: object-name.c
#, c-format
msgid "short object ID %s is ambiguous"
msgstr "短对象ID %s 存在歧义"

#. TRANSLATORS: The argument is the list of ambiguous
#. objects composed in show_ambiguous_object(). See
#. its "TRANSLATORS" comments for details.
#.
#: object-name.c
#, c-format
msgid ""
"The candidates are:\n"
"%s"
msgstr ""
"候选者有：\n"
"%s"

#: object-name.c
msgid ""
"Git normally never creates a ref that ends with 40 hex characters\n"
"because it will be ignored when you just specify 40-hex. These refs\n"
"may be created by mistake. For example,\n"
"\n"
"  git switch -c $br $(git rev-parse ...)\n"
"\n"
"where \"$br\" is somehow empty and a 40-hex ref is created. Please\n"
"examine these refs and maybe delete them. Turn this message off by\n"
"running \"git config set advice.objectNameWarning false\""
msgstr ""
"Git 通常不会创建一个以40个十六进制字符结尾的引用，因为当您只提供40\n"
"个十六进制字符时将被忽略。这些引用可能被错误地创建。例如：\n"
"\n"
"  git switch -c $br $(git rev-parse ...)\n"
"\n"
"当 \"$br\" 某种原因空白时，一个40位十六进制的引用将被创建。请检查这些\n"
"引用，可能需要删除它们。运行 \"git config set advice.objectNameWarning\n"
"false\" 命令关闭本消息通知。"

#: object-name.c
#, c-format
msgid "log for '%.*s' only goes back to %s"
msgstr "'%.*s' 的日志仅能回到 %s"

#: object-name.c
#, c-format
msgid "log for '%.*s' only has %d entries"
msgstr "'%.*s' 的日志仅有 %d 个条目"

#: object-name.c
#, c-format
msgid "path '%s' exists on disk, but not in '%.*s'"
msgstr "路径 '%s' 在磁盘上，但是不在 '%.*s' 中"

#: object-name.c
#, c-format
msgid ""
"path '%s' exists, but not '%s'\n"
"hint: Did you mean '%.*s:%s' aka '%.*s:./%s'?"
msgstr ""
"路径 '%s' 存在，而 '%s' 不存在\n"
"提示：您的意思是 '%.*s:%s' 亦即 '%.*s:./%s'？"

#: object-name.c
#, c-format
msgid "path '%s' does not exist in '%.*s'"
msgstr "路径 '%s' 不在 '%.*s' 中"

#: object-name.c
#, c-format
msgid ""
"path '%s' is in the index, but not at stage %d\n"
"hint: Did you mean ':%d:%s'?"
msgstr ""
"路径 '%s' 在索引中，但不在暂存区 %d 中\n"
"提示：您的意思是 ':%d:%s'？"

#: object-name.c
#, c-format
msgid ""
"path '%s' is in the index, but not '%s'\n"
"hint: Did you mean ':%d:%s' aka ':%d:./%s'?"
msgstr ""
"路径 '%s' 在索引中，但 '%s' 不在\n"
"提示：您的意思是 ':%d:%s' 亦即 ':%d:./%s'？"

#: object-name.c
#, c-format
msgid "path '%s' exists on disk, but not in the index"
msgstr "路径 '%s' 在磁盘上，但不在索引里"

#: object-name.c
#, c-format
msgid "path '%s' does not exist (neither on disk nor in the index)"
msgstr "路径 '%s' 不存在（既不在磁盘上，也不在索引中）"

#: object-name.c
msgid "relative path syntax can't be used outside working tree"
msgstr "不能在工作区之外使用相对路径语法"

#: object-name.c
#, c-format
msgid "<object>:<path> required, only <object> '%s' given"
msgstr "需要 <对象>:<路径>，只给出了 <对象> '%s'"

#: object-name.c
#, c-format
msgid "invalid object name '%.*s'."
msgstr "无效的对象名 '%.*s'。"

#: object.c
#, c-format
msgid "invalid object type \"%s\""
msgstr "无效的对象类型 \"%s\""

#: object.c
#, c-format
msgid "object %s is a %s, not a %s"
msgstr "对象 %s 是一个 %s，不是一个 %s"

#: object.c
#, c-format
msgid "object %s has unknown type id %d"
msgstr "对象 %s 有未知的类型 id %d"

#: object.c
#, c-format
msgid "unable to parse object: %s"
msgstr "不能解析对象：%s"

#: object.c
#, c-format
msgid "hash mismatch %s"
msgstr "哈希值与 %s 不匹配"

#: pack-bitmap-write.c
#, c-format
msgid "duplicate entry when writing bitmap index: %s"
msgstr "写入位图索引时存在重复条目：'%s'"

#: pack-bitmap-write.c
#, c-format
msgid "attempted to store non-selected commit: '%s'"
msgstr "尝试存储未选定的提交：'%s'"

#: pack-bitmap-write.c
msgid "too many pseudo-merges"
msgstr "太多伪合并"

#: pack-bitmap-write.c
msgid "trying to write commit not in index"
msgstr "尝试写入未在索引中的提交"

#: pack-bitmap.c
msgid "failed to load bitmap index (corrupted?)"
msgstr "无法载入位图索引（已损坏？）"

#: pack-bitmap.c
msgid "corrupted bitmap index (too small)"
msgstr "损坏的位图索引（太小）"

#: pack-bitmap.c
msgid "corrupted bitmap index file (wrong header)"
msgstr "损坏的位图索引（错误的文件头）"

#: pack-bitmap.c
#, c-format
msgid "unsupported version '%d' for bitmap index file"
msgstr "不支持的位图索引文件版本 '%d'"

#: pack-bitmap.c
msgid "corrupted bitmap index file (too short to fit hash cache)"
msgstr "损坏的位图索引（太小，容不下哈希缓存）"

#: pack-bitmap.c
msgid "corrupted bitmap index file (too short to fit lookup table)"
msgstr "损坏的位图索引（太小，容不下查询表）"

#: pack-bitmap.c
msgid ""
"corrupted bitmap index file (too short to fit pseudo-merge table header)"
msgstr "损坏的位图索引文件（太短而无法容纳伪合并表头）"

#: pack-bitmap.c
msgid "corrupted bitmap index file (too short to fit pseudo-merge table)"
msgstr "损坏的位图索引（太短而无法容纳伪合并表）"

#: pack-bitmap.c
msgid "corrupted bitmap index file, pseudo-merge table too short"
msgstr "损坏的位图索引，伪合并表过短"

#: pack-bitmap.c
#, c-format
msgid "duplicate entry in bitmap index: '%s'"
msgstr "位图索引中的重复条目：'%s'"

#: pack-bitmap.c
#, c-format
msgid "corrupt ewah bitmap: truncated header for entry %d"
msgstr "损坏的 EWAH 位图：条目 %d 截断的文件头"

#: pack-bitmap.c
#, c-format
msgid "corrupt ewah bitmap: commit index %u out of range"
msgstr "损坏的 EWAH 位图：提交索引 %u 超出范围"

#: pack-bitmap.c
msgid "corrupted bitmap pack index"
msgstr "损坏的位图包索引"

#: pack-bitmap.c
msgid "invalid XOR offset in bitmap pack index"
msgstr "位图包索引中 XOR 偏移值无效"

#: pack-bitmap.c
msgid "cannot fstat bitmap file"
msgstr "不能对位图文件调用 fstat"

#: pack-bitmap.c
msgid "checksum doesn't match in MIDX and bitmap"
msgstr "MIDX 和位图中的校验码不匹配"

#: pack-bitmap.c
msgid "multi-pack bitmap is missing required reverse index"
msgstr "多包位图缺少必需的反向索引"

#: pack-bitmap.c
#, c-format
msgid "could not open pack %s"
msgstr "不能打开包 %s"

#: pack-bitmap.c
msgid "corrupt bitmap lookup table: triplet position out of index"
msgstr "损坏的位图查询表：三元组位置超出索引"

#: pack-bitmap.c
msgid "corrupt bitmap lookup table: xor chain exceeds entry count"
msgstr "损坏的位图查询表：xor 链超出条目数"

#: pack-bitmap.c
#, c-format
msgid "corrupt bitmap lookup table: commit index %u out of range"
msgstr "损坏的位图查询表：提交索引 %u 超出范围"

#: pack-bitmap.c
#, c-format
msgid "corrupt ewah bitmap: truncated header for bitmap of commit \"%s\""
msgstr "损坏的 EWAH 位图：提交 \"%s\" 位图的文件头被截断"

#: pack-bitmap.c
#, c-format
msgid "unable to load pack: '%s', disabling pack-reuse"
msgstr "无法打开包：'%s'，禁用包重用"

#: pack-bitmap.c
msgid "unable to compute preferred pack, disabling pack-reuse"
msgstr "无法计算首选包，禁用包重用"

#: pack-bitmap.c
#, c-format
msgid "object '%s' not found in type bitmaps"
msgstr "对象 %s 为在类型位图中找到"

#: pack-bitmap.c
#, c-format
msgid "object '%s' does not have a unique type"
msgstr "对象 '%s' 没有唯一的类型"

#: pack-bitmap.c
#, c-format
msgid "object '%s': real type '%s', expected: '%s'"
msgstr "对象 '%s'：实际类型 '%s'，预期：'%s'"

#: pack-bitmap.c
#, c-format
msgid "object not in bitmap: '%s'"
msgstr "对象不在位图中：%s"

#: pack-bitmap.c
msgid "failed to load bitmap indexes"
msgstr "无法载入位图索引"

#: pack-bitmap.c
msgid "you must specify exactly one commit to test"
msgstr "您必须准确指定一个提交来测试"

#: pack-bitmap.c
#, c-format
msgid "commit '%s' doesn't have an indexed bitmap"
msgstr "提交 '%s' 没有索引位图"

#: pack-bitmap.c
msgid "mismatch in bitmap results"
msgstr "位图结果不一致"

#: pack-bitmap.c
#, c-format
msgid "pseudo-merge index out of range (%<PRIu32> >= %<PRIuMAX>)"
msgstr "伪合并索引超出范围 (%<PRIu32> >= %<PRIuMAX>)"

#: pack-bitmap.c
#, c-format
msgid "could not find '%s' in pack '%s' at offset %<PRIuMAX>"
msgstr "无法在包 '%2$s' 偏移 %3$<PRIuMAX> 中找到 '%1$s'"

#: pack-bitmap.c
#, c-format
msgid "unable to get disk usage of '%s'"
msgstr "无法得到 '%s' 的磁盘使用量"

#: pack-bitmap.c
#, c-format
msgid "bitmap file '%s' has invalid checksum"
msgstr "位图文件 '%s' 有无效的校验码"

#: pack-mtimes.c
#, c-format
msgid "mtimes file %s is too small"
msgstr "mtimes 文件 %s 太小"

#: pack-mtimes.c
#, c-format
msgid "mtimes file %s has unknown signature"
msgstr "mtimes 文件 %s 有未知的签名"

#: pack-mtimes.c
#, c-format
msgid "mtimes file %s has unsupported version %<PRIu32>"
msgstr "mtimes 文件 %s 不支持的版本 %<PRIu32>"

#: pack-mtimes.c
#, c-format
msgid "mtimes file %s has unsupported hash id %<PRIu32>"
msgstr "mtimes 文件 %s 有不支持的哈希 ID %<PRIu32>"

#: pack-mtimes.c
#, c-format
msgid "mtimes file %s is corrupt"
msgstr "mtimes 文件 %s 损坏"

#: pack-revindex.c
#, c-format
msgid "reverse-index file %s is too small"
msgstr "反向索引文件 %s 太小"

#: pack-revindex.c
#, c-format
msgid "reverse-index file %s is corrupt"
msgstr "反向索引文件 %s 损坏"

#: pack-revindex.c
#, c-format
msgid "reverse-index file %s has unknown signature"
msgstr "反向索引文件 %s 有错误的签名"

#: pack-revindex.c
#, c-format
msgid "reverse-index file %s has unsupported version %<PRIu32>"
msgstr "反向索引文件 %s 不支持的版本 %<PRIu32>"

#: pack-revindex.c
#, c-format
msgid "reverse-index file %s has unsupported hash id %<PRIu32>"
msgstr "反向索引文件 %s 有不支持的哈希 ID %<PRIu32>"

#: pack-revindex.c
msgid "invalid checksum"
msgstr "无效的校验码 %s"

#: pack-revindex.c
#, c-format
msgid "invalid rev-index position at %<PRIu64>: %<PRIu32> != %<PRIu32>"
msgstr "位于 %<PRIu64> 的无效的反向索引：%<PRIu32> != %<PRIu32>"

#: pack-revindex.c
msgid "multi-pack-index reverse-index chunk is the wrong size"
msgstr "多包索引的反向索引块大小错误"

#: pack-revindex.c
msgid "could not determine preferred pack"
msgstr "无法确定首选包"

#: pack-write.c
msgid "cannot both write and verify reverse index"
msgstr "无法同时写入和校验反向索引"

#: pack-write.c
#, c-format
msgid "could not stat: %s"
msgstr "不能调用 stat：%s"

#: pack-write.c
#, c-format
msgid "failed to make %s readable"
msgstr "无法设置 %s 为可读"

#: pack-write.c
#, c-format
msgid "could not write '%s' promisor file"
msgstr "无法写入 '%s' 承诺者文件"

#: packfile.c
msgid "offset before end of packfile (broken .idx?)"
msgstr "偏移量在包文件结束之前（损坏的 .idx？）"

#: packfile.c
#, c-format
msgid "packfile %s cannot be mapped%s"
msgstr "包文件 %s 不能被映射%s"

#: packfile.c
#, c-format
msgid "offset before start of pack index for %s (corrupt index?)"
msgstr "偏移量在 %s 的包索引开始之前（损坏的索引？）"

#: packfile.c
#, c-format
msgid "offset beyond end of pack index for %s (truncated index?)"
msgstr "偏移量越过了 %s 的包索引的结尾（被截断的索引？）"

#: parse-options-cb.c
#, c-format
msgid "malformed expiration date '%s'"
msgstr "格式错误的到期时间：'%s'"

#: parse-options-cb.c
#, c-format
msgid "option `%s' expects \"always\", \"auto\", or \"never\""
msgstr "选项 `%s' 期望 \"always\"、\"auto\" 或 \"never\""

#: parse-options-cb.c
#, c-format
msgid "malformed object name '%s'"
msgstr "格式错误的对象名 '%s'"

#: parse-options-cb.c
#, c-format
msgid "option `%s' expects \"%s\" or \"%s\""
msgstr "选项 `%s' 期望 \"%s\" 或 \"%s\""

#: parse-options.c
#, c-format
msgid "%s requires a value"
msgstr "%s 需要一个值"

#: parse-options.c
#, c-format
msgid "%s takes no value"
msgstr "%s 不取值"

#: parse-options.c
#, c-format
msgid "%s isn't available"
msgstr "%s 不可用"

#: parse-options.c
#, c-format
msgid "%s expects a non-negative integer value with an optional k/m/g suffix"
msgstr "%s 期望一个非负整数和一个可选的 k/m/g 后缀"

#: parse-options.c
#, c-format
msgid "ambiguous option: %s (could be --%s%s or --%s%s)"
msgstr "有歧义的选项：%s（可以是 --%s%s 或 --%s%s）"

#: parse-options.c
#, c-format
msgid "did you mean `--%s` (with two dashes)?"
msgstr "您的意思是 `--%s`（有两个短线）？"

#: parse-options.c
#, c-format
msgid "alias of --%s"
msgstr "--%s 的别名"

#: parse-options.c
msgid "need a subcommand"
msgstr "需要一个子命令"

#: parse-options.c
#, c-format
msgid "unknown option `%s'"
msgstr "未知选项 `%s'"

#: parse-options.c
#, c-format
msgid "unknown switch `%c'"
msgstr "未知开关 `%c'"

#: parse-options.c
#, c-format
msgid "unknown non-ascii option in string: `%s'"
msgstr "字符串中未知的非 ascii 字符选项：`%s'"

#. TRANSLATORS: The "<%s>" part of this string
#. stands for an optional value given to a command
#. line option in the long form, and "<>" is there
#. as a convention to signal that it is a
#. placeholder (i.e. the user should substitute it
#. with the real value).  If your language uses a
#. different convention, you can change "<%s>" part
#. to match yours, e.g. it might use "|%s|" instead,
#. or if the alphabet is different enough it may use
#. "%s" without any placeholder signal.  Most
#. translations leave this message as is.
#.
#: parse-options.c
#, c-format
msgid "[=<%s>]"
msgstr "[=<%s>]"

#. TRANSLATORS: The "<%s>" part of this string
#. stands for an optional value given to a command
#. line option in the short form, and "<>" is there
#. as a convention to signal that it is a
#. placeholder (i.e. the user should substitute it
#. with the real value).  If your language uses a
#. different convention, you can change "<%s>" part
#. to match yours, e.g. it might use "|%s|" instead,
#. or if the alphabet is different enough it may use
#. "%s" without any placeholder signal.  Most
#. translations leave this message as is.
#.
#: parse-options.c
#, c-format
msgid "[<%s>]"
msgstr "[<%s>]"

#. TRANSLATORS: The "<%s>" part of this string stands for a
#. value given to a command line option, and "<>" is there
#. as a convention to signal that it is a placeholder
#. (i.e. the user should substitute it with the real value).
#. If your language uses a different convention, you can
#. change "<%s>" part to match yours, e.g. it might use
#. "|%s|" instead, or if the alphabet is different enough it
#. may use "%s" without any placeholder signal.  Most
#. translations leave this message as is.
#.
#: parse-options.c
#, c-format
msgid " <%s>"
msgstr " <%s>"

#: parse-options.c
msgid "..."
msgstr "..."

#: parse-options.c
#, c-format
msgid "usage: %s"
msgstr "用法：%s"

#. TRANSLATORS: the colon here should align with the
#. one in "usage: %s" translation.
#.
#: parse-options.c
#, c-format
msgid "   or: %s"
msgstr "  或：%s"

#. TRANSLATORS: You should only need to translate this format
#. string if your language is a RTL language (e.g. Arabic,
#. Hebrew etc.), not if it's a LTR language (e.g. German,
#. Russian, Chinese etc.).
#. *
#. When a translated usage string has an embedded "\n" it's
#. because options have wrapped to the next line. The line
#. after the "\n" will then be padded to align with the
#. command name, such as N_("git cmd [opt]\n<8
#. spaces>[opt2]"), where the 8 spaces are the same length as
#. "git cmd ".
#. *
#. This format string prints out that already-translated
#. line. The "%*s" is whitespace padding to account for the
#. padding at the start of the line that we add in this
#. function. The "%s" is a line in the (hopefully already
#. translated) N_() usage string, which contained embedded
#. newlines before we split it up.
#.
#: parse-options.c
#, c-format
msgid "%*s%s"
msgstr "%*s%s"

#  译者：为保证在输出中对齐，注意调整句中空格！
#: parse-options.c
#, c-format
msgid "    %s"
msgstr "    %s"

#: parse-options.c
msgid "-NUM"
msgstr "-数字"

#: parse-options.c
#, c-format
msgid "opposite of --no-%s"
msgstr "与 --no-%s 相反"

#: parse-options.h
msgid "expiry-date"
msgstr "到期时间"

#: parse-options.h
msgid "no-op (backward compatibility)"
msgstr "空操作（向后兼容）"

#: parse-options.h
msgid "be more verbose"
msgstr "更加详细"

#: parse-options.h
msgid "be more quiet"
msgstr "更加安静"

#: parse-options.h
msgid "use <n> digits to display object names"
msgstr "用 <n> 位数字显示对象名"

#: parse-options.h
msgid "prefixed path to initial superproject"
msgstr "用来初始化父项目的前缀路径"

#: parse-options.h
msgid "how to strip spaces and #comments from message"
msgstr "设置如何删除提交说明里的空格和#注释"

#: parse-options.h
msgid "read pathspec from file"
msgstr "从文件读取路径表达式"

#: parse-options.h
msgid ""
"with --pathspec-from-file, pathspec elements are separated with NUL character"
msgstr "使用 --pathspec-from-file，路径表达式用空字符分隔"

#: parse.c
#, c-format
msgid "bad boolean environment value '%s' for '%s'"
msgstr "对于 '%2$s' 的错误的布尔环境取值 '%1$s'"

#: parse.c
#, c-format
msgid "failed to parse %s"
msgstr "无法解析 %s"

#: path-walk.c
#, c-format
msgid "failed to walk children of tree %s: not found"
msgstr "无法遍历树 %s 的子节点：未找到"

#: path-walk.c
#, c-format
msgid "failed to find object %s"
msgstr "无法找到对象 %s"

#: path-walk.c
#, c-format
msgid "failed to find tag %s"
msgstr "无法找到标签 %s"

#: path-walk.c
msgid "failed to setup revision walk"
msgstr "无法设置版本遍历"

#: path.c
#, c-format
msgid "Could not make %s writable by group"
msgstr "不能设置 %s 为组可写"

#: pathspec.c
msgid "Escape character '\\' not allowed as last character in attr value"
msgstr "转义字符 '\\' 不能作为属性值的最后一个字符"

#: pathspec.c
msgid "Only one 'attr:' specification is allowed."
msgstr "只允许一个 'attr:' 规格。"

#: pathspec.c
msgid "attr spec must not be empty"
msgstr "属性规格不能为空"

#: pathspec.c
#, c-format
msgid "invalid attribute name %s"
msgstr "无效的属性名 %s"

#: pathspec.c
msgid "global 'glob' and 'noglob' pathspec settings are incompatible"
msgstr "全局的 'glob' 和 'noglob' 路径规格设置不兼容"

#: pathspec.c
msgid ""
"global 'literal' pathspec setting is incompatible with all other global "
"pathspec settings"
msgstr "全局的 'literal' 路径规格设置和其它的全局路径规格设置不兼容"

#: pathspec.c
msgid "invalid parameter for pathspec magic 'prefix'"
msgstr "路径规格包含无效的神奇前缀"

#: pathspec.c
#, c-format
msgid "Invalid pathspec magic '%.*s' in '%s'"
msgstr "在路径规格 '%3$s' 中无效的神奇前缀 '%2$.*1$s'"

#: pathspec.c
#, c-format
msgid "Missing ')' at the end of pathspec magic in '%s'"
msgstr "路径规格 '%s' 的神奇前缀结尾少了一个 ')'"

#: pathspec.c
#, c-format
msgid "Unimplemented pathspec magic '%c' in '%s'"
msgstr "路径规格 '%2$s' 中包含未实现的神奇前缀 '%1$c'"

#: pathspec.c
#, c-format
msgid "%s: 'literal' and 'glob' are incompatible"
msgstr "%s：'literal' 和 'glob' 不兼容"

#: pathspec.c
#, c-format
msgid "'%s' is outside the directory tree"
msgstr "'%s' 位于目录树之外"

#: pathspec.c
#, c-format
msgid "%s: '%s' is outside repository at '%s'"
msgstr "%s：'%s' 在位于 '%s' 的仓库之外"

#: pathspec.c
#, c-format
msgid "'%s' (mnemonic: '%c')"
msgstr "'%s'（助记符：'%c'）"

#: pathspec.c
#, c-format
msgid "%s: pathspec magic not supported by this command: %s"
msgstr "%s：路径规格神奇前缀不被此命令支持：%s"

#: pathspec.c
#, c-format
msgid "pathspec '%s' is beyond a symbolic link"
msgstr "路径规格 '%s' 位于符号链接中"

#: pathspec.c
#, c-format
msgid "line is badly quoted: %s"
msgstr "行被错误地引用：%s"

#: pkt-line.c
msgid "unable to write flush packet"
msgstr "无法写 flush 包"

#: pkt-line.c
msgid "unable to write delim packet"
msgstr "无法写 delim 包"

#: pkt-line.c
msgid "unable to write response end packet"
msgstr "无法写入响应结束数据包"

#: pkt-line.c
msgid "flush packet write failed"
msgstr "flush 包写错误"

#: pkt-line.c
msgid "protocol error: impossibly long line"
msgstr "协议错误：不可能的长行"

#: pkt-line.c
msgid "packet write with format failed"
msgstr "格式化包写入错误"

#: pkt-line.c
msgid "packet write failed - data exceeds max packet size"
msgstr "写数据包失败：数据超过了包的最大长度"

#: pkt-line.c
#, c-format
msgid "packet write failed: %s"
msgstr "数据包写入失败：%s"

#: pkt-line.c
msgid "read error"
msgstr "读取错误"

#: pkt-line.c
msgid "the remote end hung up unexpectedly"
msgstr "远端意外挂断了"

#: pkt-line.c
#, c-format
msgid "protocol error: bad line length character: %.4s"
msgstr "协议错误：错误的行长度字符串：%.4s"

#: pkt-line.c
#, c-format
msgid "protocol error: bad line length %d"
msgstr "协议错误：错误的行长度 %d"

#: pkt-line.c sideband.c
#, c-format
msgid "remote error: %s"
msgstr "远程错误：%s"

#: preload-index.c
msgid "Refreshing index"
msgstr "正在刷新索引"

#: preload-index.c
#, c-format
msgid "unable to create threaded lstat: %s"
msgstr "无法创建线程 lstat：%s"

#: pretty.c
msgid "unable to parse --pretty format"
msgstr "不能解析 --pretty 格式"

#: promisor-remote.c
msgid "lazy fetching disabled; some objects may not be available"
msgstr "禁用延迟获取，某些对象可能不可用"

#: promisor-remote.c
msgid "promisor-remote: unable to fork off fetch subprocess"
msgstr "promisor-remote：无法派生 fetch 子进程"

#: promisor-remote.c
msgid "promisor-remote: could not write to fetch subprocess"
msgstr "promisor-remote：无法向 fetch 子进程写入"

#: promisor-remote.c
msgid "promisor-remote: could not close stdin to fetch subprocess"
msgstr "promisor-remote：无法关闭至 fetch 子进程的标准输入"

#: promisor-remote.c
#, c-format
msgid "promisor remote name cannot begin with '/': %s"
msgstr "promisor 远程名称不能以 '/' 开始：%s"

#: promisor-remote.c
#, c-format
msgid "could not fetch %s from promisor remote"
msgstr "无法从承诺者远程获取 %s"

#: promisor-remote.c
#, c-format
msgid "known remote named '%s' but with url '%s' instead of '%s'"
msgstr "已知远程名称为 '%s'，但 url 为 '%s' 而不是 '%s'"

#: promisor-remote.c
#, c-format
msgid "unknown '%s' value for '%s' config option"
msgstr "配置项 '%2$s' 为未知的取值 '%1$s'"

#: promisor-remote.c
#, c-format
msgid "unknown element '%s' from remote info"
msgstr "远程信息中的未知元素 '%s'"

#: promisor-remote.c
#, c-format
msgid "accepted promisor remote '%s' not found"
msgstr "未找到已接受的承诺者远程 '%s'"

#: protocol-caps.c
msgid "object-info: expected flush after arguments"
msgstr "object-info：在参数之后应有一个 flush"

#: prune-packed.c
msgid "Removing duplicate objects"
msgstr "正在删除重复对象"

#: pseudo-merge.c
#, c-format
msgid "failed to load pseudo-merge regex for %s: '%s'"
msgstr "未能加载 %s 的伪合并正则表达式：'%s'"

#: pseudo-merge.c
#, c-format
msgid "%s must be non-negative, using default"
msgstr "%s 必须为非负整数，使用默认值"

#: pseudo-merge.c
#, c-format
msgid "%s must be between 0 and 1, using default"
msgstr "%s 必须介于 0 到 1 之间，使用默认值"

#: pseudo-merge.c
#, c-format
msgid "%s must be positive, using default"
msgstr "%s 必须为正数，使用默认值"

#: pseudo-merge.c
#, c-format
msgid "pseudo-merge group '%s' missing required pattern"
msgstr "伪合并组 '%s' 缺少所需的模式"

#: pseudo-merge.c
#, c-format
msgid "pseudo-merge group '%s' has unstable threshold before stable one"
msgstr "伪合并组 '%s' 在稳定阈值之前有不稳定阈值"

#: pseudo-merge.c
#, c-format
msgid ""
"pseudo-merge regex from config has too many capture groups (max=%<PRIuMAX>)"
msgstr "来自 config 的伪合并正则表达式有太多的捕获组（最多 %<PRIuMAX> 个）"

#: pseudo-merge.c
#, c-format
msgid "extended pseudo-merge read out-of-bounds (%<PRIuMAX> >= %<PRIuMAX>)"
msgstr "扩展伪合并读取越界 (%<PRIuMAX> >= %<PRIuMAX>)"

#: pseudo-merge.c
#, c-format
msgid "extended pseudo-merge entry is too short (%<PRIuMAX> >= %<PRIuMAX>)"
msgstr "扩展伪合并条目太短（%<PRIuMAX> >= %<PRIuMAX>）"

#: pseudo-merge.c
#, c-format
msgid "could not find pseudo-merge for commit %s at offset %<PRIuMAX>"
msgstr "无法在提交 %1$s 的偏移 %2$<PRIuMAX> 中找到伪合并"

#: pseudo-merge.c
#, c-format
msgid "extended pseudo-merge lookup out-of-bounds (%<PRIu32> >= %<PRIu32>)"
msgstr "扩展伪合并查找越界 (%<PRIu32> >= %<PRIu32>)"

#: pseudo-merge.c
#, c-format
msgid "out-of-bounds read: (%<PRIuMAX> >= %<PRIuMAX>)"
msgstr "越界读取：(%<PRIuMAX> >= %<PRIuMAX>)"

#: pseudo-merge.c
#, c-format
msgid "could not read extended pseudo-merge table for commit %s"
msgstr "无法读取提交 %s 的扩展伪合并表"

#: range-diff.c
msgid "could not start `log`"
msgstr "不能启动 `log`"

#: range-diff.c
msgid "could not read `log` output"
msgstr "不能读取 `log` 的输出"

#: range-diff.c sequencer.c
#, c-format
msgid "could not parse commit '%s'"
msgstr "不能解析提交 '%s'"

#: range-diff.c
#, c-format
msgid ""
"could not parse first line of `log` output: did not start with 'commit ': "
"'%s'"
msgstr "无法解析 `log` 输出的首行：不是以 'commit ' 开头：'%s'"

#: range-diff.c
#, c-format
msgid "could not parse git header '%.*s'"
msgstr "无法解析 git 头 '%.*s'"

#: range-diff.c
msgid "failed to generate diff"
msgstr "无法生成 diff"

#: range-diff.c
#, c-format
msgid "could not parse log for '%s'"
msgstr "不能解析 '%s' 的日志"

#: reachable.c
#, c-format
msgid "invalid extra cruft tip: '%s'"
msgstr "无效的额外废弃提交版本：'%s'"

#: reachable.c
msgid "unable to enumerate additional recent objects"
msgstr "无法枚举额外的近期对象"

#: read-cache.c
#, c-format
msgid "will not add file alias '%s' ('%s' already exists in index)"
msgstr "将不会添加文件别名 '%s'（'%s' 已经存在于索引中）"

#: read-cache.c
msgid "cannot create an empty blob in the object database"
msgstr "不能在对象数据库中创建空的数据对象"

#: read-cache.c
#, c-format
msgid "%s: can only add regular files, symbolic links or git-directories"
msgstr "%s：只能添加常规文件、符号链接或 git 目录"

#: read-cache.c
#, c-format
msgid "unable to index file '%s'"
msgstr "无法索引文件 '%s'"

#: read-cache.c
#, c-format
msgid "unable to add '%s' to index"
msgstr "无法在索引中添加 '%s'"

#: read-cache.c
#, c-format
msgid "'%s' appears as both a file and as a directory"
msgstr "'%s' 看起来既是文件又是目录"

#: read-cache.c
msgid "Refresh index"
msgstr "刷新索引"

#: read-cache.c
#, c-format
msgid ""
"index.version set, but the value is invalid.\n"
"Using version %i"
msgstr ""
"设置了 index.version，但是取值无效。\n"
"使用版本 %i"

#: read-cache.c
#, c-format
msgid ""
"GIT_INDEX_VERSION set, but the value is invalid.\n"
"Using version %i"
msgstr ""
"设置了 GIT_INDEX_VERSION，但是取值无效。\n"
"使用版本 %i"

#: read-cache.c
#, c-format
msgid "bad signature 0x%08x"
msgstr "坏的签名 0x%08x"

#: read-cache.c
#, c-format
msgid "bad index version %d"
msgstr "坏的索引版本 %d"

#: read-cache.c
msgid "bad index file sha1 signature"
msgstr "坏的索引文件 sha1 签名"

#: read-cache.c
#, c-format
msgid "index uses %.4s extension, which we do not understand"
msgstr "索引使用不被支持的 %.4s 扩展"

#: read-cache.c
#, c-format
msgid "ignoring %.4s extension"
msgstr "忽略 %.4s 扩展"

#: read-cache.c
#, c-format
msgid "unknown index entry format 0x%08x"
msgstr "未知的索引条目格式 0x%08x"

#: read-cache.c
#, c-format
msgid "malformed name field in the index, near path '%s'"
msgstr "索引中靠近路径 '%s' 有错误的名称字段"

#: read-cache.c
msgid "unordered stage entries in index"
msgstr "索引中有未排序的暂存条目"

#: read-cache.c
#, c-format
msgid "multiple stage entries for merged file '%s'"
msgstr "合并文件 '%s' 有多个暂存条目"

#: read-cache.c
#, c-format
msgid "unordered stage entries for '%s'"
msgstr "'%s' 的未排序暂存条目"

#: read-cache.c
#, c-format
msgid "unable to create load_cache_entries thread: %s"
msgstr "无法创建 load_cache_entries 线程：%s"

#: read-cache.c
#, c-format
msgid "unable to join load_cache_entries thread: %s"
msgstr "无法加入 load_cache_entries 线程：%s"

#: read-cache.c
#, c-format
msgid "%s: index file open failed"
msgstr "%s：打开索引文件失败"

#: read-cache.c
#, c-format
msgid "%s: cannot stat the open index"
msgstr "%s：不能对打开的索引执行 stat 操作"

#: read-cache.c
#, c-format
msgid "%s: index file smaller than expected"
msgstr "%s：索引文件比预期的小"

#: read-cache.c
#, c-format
msgid "%s: unable to map index file%s"
msgstr "%s：无法映射索引文件%s"

#: read-cache.c
#, c-format
msgid "unable to create load_index_extensions thread: %s"
msgstr "无法创建 load_index_extensions 线程：%s"

#: read-cache.c
#, c-format
msgid "unable to join load_index_extensions thread: %s"
msgstr "无法加入 load_index_extensions 线程：%s"

#: read-cache.c
#, c-format
msgid "could not freshen shared index '%s'"
msgstr "无法刷新共享索引 '%s'"

#: read-cache.c
#, c-format
msgid "broken index, expect %s in %s, got %s"
msgstr "损坏的索引，期望在 %2$s 中的 %1$s，得到 %3$s"

#: read-cache.c
msgid "cannot write split index for a sparse index"
msgstr "无法为稀疏索引写入拆分索引"

#: read-cache.c
msgid "failed to convert to a sparse-index"
msgstr "无法转换为稀疏索引"

#: read-cache.c
#, c-format
msgid "unable to open git dir: %s"
msgstr "不能打开 git 目录：%s"

#: read-cache.c
#, c-format
msgid "unable to unlink: %s"
msgstr "无法删除：%s"

#: read-cache.c
#, c-format
msgid "cannot fix permission bits on '%s'"
msgstr "不能修复 '%s' 的权限位"

#: read-cache.c
#, c-format
msgid "%s: cannot drop to stage #0"
msgstr "%s：不能落到暂存区 #0"

#: read-cache.c
#, c-format
msgid "unexpected diff status %c"
msgstr "意外的差异状态 %c"

#: read-cache.c
#, c-format
msgid "remove '%s'\n"
msgstr "删除 '%s'\n"

#: rebase-interactive.c
msgid ""
"You can fix this with 'git rebase --edit-todo' and then run 'git rebase --"
"continue'.\n"
"Or you can abort the rebase with 'git rebase --abort'.\n"
msgstr ""
"您可以用 'git rebase --edit-todo' 修正，然后执行 'git rebase --continue'。\n"
"或者您可以用 'git rebase --abort' 终止变基。\n"

#: rebase-interactive.c
#, c-format
msgid ""
"unrecognized setting %s for option rebase.missingCommitsCheck. Ignoring."
msgstr "选项 rebase.missingCommitsCheck 的值 %s 无法识别。已忽略。"

#: rebase-interactive.c
msgid ""
"\n"
"Commands:\n"
"p, pick <commit> = use commit\n"
"r, reword <commit> = use commit, but edit the commit message\n"
"e, edit <commit> = use commit, but stop for amending\n"
"s, squash <commit> = use commit, but meld into previous commit\n"
"f, fixup [-C | -c] <commit> = like \"squash\" but keep only the previous\n"
"                   commit's log message, unless -C is used, in which case\n"
"                   keep only this commit's message; -c is same as -C but\n"
"                   opens the editor\n"
"x, exec <command> = run command (the rest of the line) using shell\n"
"b, break = stop here (continue rebase later with 'git rebase --continue')\n"
"d, drop <commit> = remove commit\n"
"l, label <label> = label current HEAD with a name\n"
"t, reset <label> = reset HEAD to a label\n"
"m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n"
"        create a merge commit using the original merge commit's\n"
"        message (or the oneline, if no original merge commit was\n"
"        specified); use -c <commit> to reword the commit message\n"
"u, update-ref <ref> = track a placeholder for the <ref> to be updated\n"
"                      to this position in the new commits. The <ref> is\n"
"                      updated at the end of the rebase\n"
"\n"
"These lines can be re-ordered; they are executed from top to bottom.\n"
msgstr ""
"\n"
"命令:\n"
"p, pick <提交> = 使用提交\n"
"r, reword <提交> = 使用提交，但编辑提交说明\n"
"e, edit <提交> = 使用提交，但停止以便修补提交\n"
"s, squash <提交> = 使用提交，但挤压到前一个提交\n"
"f, fixup [-C | -c] <提交> = 类似于 \"squash\"，但只保留前一个提交\n"
"                   的提交说明，除非使用了 -C 参数，此情况下则只\n"
"                   保留本提交说明。使用 -c 和 -C 类似，但会打开\n"
"                   编辑器修改提交说明\n"
"x, exec <命令> = 使用 shell 运行命令（此行剩余部分）\n"
"b, break = 在此处停止（使用 'git rebase --continue' 继续变基）\n"
"d, drop <提交> = 删除提交\n"
"l, label <label> = 为当前 HEAD 打上标记\n"
"t, reset <label> = 重置 HEAD 到该标记\n"
"m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n"
".       创建一个合并提交，并使用原始的合并提交说明（如果没有指定\n"
".       原始提交，使用注释部分的 oneline 作为提交说明）。使用\n"
".       -c <提交> 可以编辑提交说明。\n"
"u, update-ref <引用> = 为引用 <ref> 设置一个占位符，以将该引用更新为此处的新"
"提交。\n"
"                      此 <引用> 在变基结束后更新。\n"
"\n"
"可以对这些行重新排序，将从上至下执行。\n"

#: rebase-interactive.c
#, c-format
msgid "Rebase %s onto %s (%d command)"
msgid_plural "Rebase %s onto %s (%d commands)"
msgstr[0] "变基 %s 到 %s（%d 个提交）"
msgstr[1] "变基 %s 到 %s（%d 个提交）"

#: rebase-interactive.c
msgid ""
"\n"
"Do not remove any line. Use 'drop' explicitly to remove a commit.\n"
msgstr ""
"\n"
"不要删除任意一行。使用 'drop' 显式地删除一个提交。\n"

#: rebase-interactive.c
msgid ""
"\n"
"If you remove a line here THAT COMMIT WILL BE LOST.\n"
msgstr ""
"\n"
"如果您在这里删除一行，对应的提交将会丢失。\n"

#: rebase-interactive.c
msgid ""
"\n"
"You are editing the todo file of an ongoing interactive rebase.\n"
"To continue rebase after editing, run:\n"
"    git rebase --continue\n"
"\n"
msgstr ""
"\n"
"您正在修改进行中的交互式变基待办列表。若要在编辑结束后继续变基，\n"
"请执行：\n"
"    git rebase --continue\n"
"\n"

#: rebase-interactive.c
msgid ""
"\n"
"However, if you remove everything, the rebase will be aborted.\n"
"\n"
msgstr ""
"\n"
"然而，如果您删除全部内容，变基操作将会终止。\n"
"\n"

#: rebase-interactive.c
#, c-format
msgid "could not write '%s'."
msgstr "不能写入 '%s'。"

#: rebase-interactive.c
#, c-format
msgid ""
"Warning: some commits may have been dropped accidentally.\n"
"Dropped commits (newer to older):\n"
msgstr ""
"警告：一些提交可能被意外丢弃。\n"
"丢弃的提交（从新到旧）：\n"

#: rebase-interactive.c
#, c-format
msgid ""
"To avoid this message, use \"drop\" to explicitly remove a commit.\n"
"\n"
"Use 'git config rebase.missingCommitsCheck' to change the level of "
"warnings.\n"
"The possible behaviours are: ignore, warn, error.\n"
"\n"
msgstr ""
"为避免这条信息，使用 \"drop\" 指令显式地删除一个提交。\n"
"\n"
"使用 'git config rebase.missingCommitsCheck' 来修改警告级别。\n"
"可选值有：ignore、warn、error。\n"
"\n"

#: rebase.c
#, c-format
msgid "%s: 'preserve' superseded by 'merges'"
msgstr "%s：'preserve' 被 'merges' 取代"

#: ref-filter.c wt-status.c
msgid "gone"
msgstr "丢失"

#: ref-filter.c
#, c-format
msgid "ahead %d"
msgstr "领先 %d"

#: ref-filter.c
#, c-format
msgid "behind %d"
msgstr "落后 %d"

#: ref-filter.c
#, c-format
msgid "ahead %d, behind %d"
msgstr "领先 %d，落后 %d"

#: ref-filter.c
#, c-format
msgid "%%(%.*s) does not take arguments"
msgstr "%%(%.*s) 不带参数"

#: ref-filter.c
#, c-format
msgid "unrecognized %%(%.*s) argument: %s"
msgstr "未能识别的 %%(%.*s) 参数：%s"

#: ref-filter.c
#, c-format
msgid "expected format: %%(color:<color>)"
msgstr "期望的格式：%%(color:<颜色>)"

#: ref-filter.c
#, c-format
msgid "unrecognized color: %%(color:%s)"
msgstr "未能识别的颜色：%%(color:%s)"

#: ref-filter.c
#, c-format
msgid "Integer value expected refname:lstrip=%s"
msgstr "期望整数值 refname:lstrip=%s"

#: ref-filter.c
#, c-format
msgid "Integer value expected refname:rstrip=%s"
msgstr "期望整数值 refname:rstrip=%s"

#: ref-filter.c
#, c-format
msgid "expected %%(trailers:key=<value>)"
msgstr "预期 %%(trailers:key=<值>)"

#: ref-filter.c
#, c-format
msgid "unknown %%(trailers) argument: %s"
msgstr "未知的 %%(trailers) 参数：%s"

#: ref-filter.c
#, c-format
msgid "positive value expected contents:lines=%s"
msgstr "期望一个正数 contents:lines=%s"

#: ref-filter.c
#, c-format
msgid "argument expected for %s"
msgstr "预期参数 %s"

#: ref-filter.c
#, c-format
msgid "positive value expected %s=%s"
msgstr "预期正数参数值 %s=%s"

#: ref-filter.c
#, c-format
msgid "cannot fully parse %s=%s"
msgstr "不能完整解析 %s=%s"

#: ref-filter.c
#, c-format
msgid "value expected %s="
msgstr "预期值 %s="

#: ref-filter.c
#, c-format
msgid "positive value expected '%s' in %%(%s)"
msgstr "期望 %%(%2$s) 中的 '%1$s' 是一个正数"

#: ref-filter.c
#, c-format
msgid "expected format: %%(align:<width>,<position>)"
msgstr "期望的格式：%%(align:<宽度>,<位置>)"

#: ref-filter.c
#, c-format
msgid "unrecognized position:%s"
msgstr "未能识别的位置：%s"

#: ref-filter.c
#, c-format
msgid "unrecognized width:%s"
msgstr "未能识别的宽度：%s"

#: ref-filter.c
#, c-format
msgid "unrecognized %%(%s) argument: %s"
msgstr "未能识别的 %%(%s) 参数：%s"

#: ref-filter.c
#, c-format
msgid "positive width expected with the %%(align) atom"
msgstr "元素 %%(align) 需要一个正数的宽度"

#: ref-filter.c
#, c-format
msgid "expected format: %%(ahead-behind:<committish>)"
msgstr "期望的格式：%%(ahead-behind:<提交号>)"

#: ref-filter.c
#, c-format
msgid "expected format: %%(is-base:<committish>)"
msgstr "期望的格式：%%(is-base:<提交号>)"

#: ref-filter.c
#, c-format
msgid "malformed field name: %.*s"
msgstr "格式错误的字段名：%.*s"

#: ref-filter.c
#, c-format
msgid "unknown field name: %.*s"
msgstr "未知的字段名：%.*s"

#: ref-filter.c
#, c-format
msgid ""
"not a git repository, but the field '%.*s' requires access to object data"
msgstr "不是 git 仓库，但是字段 '%.*s' 需要访问对象数据"

#: ref-filter.c
#, c-format
msgid "format: %%(%s) atom used without a %%(%s) atom"
msgstr "格式：在没有 %%(%2$s) 元素的情况下使用了 %%(%1$s) 元素"

#: ref-filter.c
#, c-format
msgid "format: %%(then) atom used more than once"
msgstr "格式：%%(then) 元素用了多次"

#: ref-filter.c
#, c-format
msgid "format: %%(then) atom used after %%(else)"
msgstr "格式：%%(then) 元素用在了 %%(else) 之后"

#: ref-filter.c
#, c-format
msgid "format: %%(else) atom used more than once"
msgstr "格式：%%(else) 元素用了多次"

#: ref-filter.c
#, c-format
msgid "format: %%(end) atom used without corresponding atom"
msgstr "格式：使用了 %%(end) 元素却没有它的对应元素"

#: ref-filter.c
#, c-format
msgid "malformed format string %s"
msgstr "错误的格式化字符串 %s"

#: ref-filter.c
#, c-format
msgid "this command reject atom %%(%.*s)"
msgstr "这个命令拒绝元素 %%(%.*s)"

#: ref-filter.c
#, c-format
msgid "--format=%.*s cannot be used with --python, --shell, --tcl"
msgstr "--format=%.*s 不能和 --python、--shell、--tcl 同时使用"

#: ref-filter.c
msgid "failed to run 'describe'"
msgstr "无法运行 'describe'"

#: ref-filter.c
#, c-format
msgid "(no branch, rebasing %s)"
msgstr "（非分支，正变基 %s）"

#: ref-filter.c
#, c-format
msgid "(no branch, rebasing detached HEAD %s)"
msgstr "（非分支，正变基分离头指针 %s）"

#: ref-filter.c
#, c-format
msgid "(no branch, bisect started on %s)"
msgstr "（非分支，二分查找开始于 %s）"

#: ref-filter.c
#, c-format
msgid "(HEAD detached at %s)"
msgstr "（头指针在 %s 分离）"

#: ref-filter.c
#, c-format
msgid "(HEAD detached from %s)"
msgstr "（头指针自 %s 分离）"

#: ref-filter.c
msgid "(no branch)"
msgstr "（非分支）"

#: ref-filter.c
#, c-format
msgid "missing object %s for %s"
msgstr "缺失 %2$s 的对象 %1$s"

#: ref-filter.c
#, c-format
msgid "parse_object_buffer failed on %s for %s"
msgstr "parse_object_buffer 失败于 %2$s 的 %1$s"

#: ref-filter.c
#, c-format
msgid "malformed object at '%s'"
msgstr "格式错误的对象 '%s'"

#: ref-filter.c
#, c-format
msgid "ignoring ref with broken name %s"
msgstr "忽略带有错误名称 %s 的引用"

#: ref-filter.c refs.c
#, c-format
msgid "ignoring broken ref %s"
msgstr "忽略损坏的引用 %s"

#: ref-filter.c
#, c-format
msgid "format: %%(end) atom missing"
msgstr "格式：缺少 %%(end) 元素"

#: ref-filter.c
#, c-format
msgid "malformed object name %s"
msgstr "格式错误的对象名 %s"

#: ref-filter.c
#, c-format
msgid "option `%s' must point to a commit"
msgstr "选项 `%s' 必须指向一个提交"

#: ref-filter.h
msgid "key"
msgstr "key"

#: ref-filter.h
msgid "field name to sort on"
msgstr "排序的字段名"

#: ref-filter.h
msgid "exclude refs which match pattern"
msgstr "排除与 <模式> 相匹配的引用"

#: reflog.c
#, c-format
msgid "not a reflog: %s"
msgstr "不是一个引用日志：%s"

#: reflog.c
#, c-format
msgid "no reflog for '%s'"
msgstr "没有 '%s' 的引用日志"

#: refs.c
#, c-format
msgid "%s does not point to a valid object!"
msgstr "%s 没有指向一个有效的对象！"

#: refs.c
#, c-format
msgid ""
"Using '%s' as the name for the initial branch. This default branch name\n"
"is subject to change. To configure the initial branch name to use in all\n"
"of your new repositories, which will suppress this warning, call:\n"
"\n"
"\tgit config --global init.defaultBranch <name>\n"
"\n"
"Names commonly chosen instead of 'master' are 'main', 'trunk' and\n"
"'development'. The just-created branch can be renamed via this command:\n"
"\n"
"\tgit branch -m <name>\n"
msgstr ""
"使用 '%s' 作为初始分支的名称。这个默认分支名称可能会更改。要在新仓库中\n"
"配置使用初始分支名，并消除这条警告，请执行：\n"
"\n"
"\tgit config --global init.defaultBranch <名称>\n"
"\n"
"除了 'master' 之外，通常选定的名字有 'main'、'trunk' 和 'development'。\n"
"可以通过以下命令重命名刚创建的分支：\n"
"\n"
"\tgit branch -m <name>\n"

#: refs.c
#, c-format
msgid "could not retrieve `%s`"
msgstr "无法获取 `%s`"

#: refs.c
#, c-format
msgid "invalid branch name: %s = %s"
msgstr "无效的分支名：%s = %s"

#: refs.c
#, c-format
msgid "ignoring dangling symref %s"
msgstr "忽略悬空符号引用 %s"

#: refs.c
#, c-format
msgid "log for ref %s has gap after %s"
msgstr "引用 %s 的日志在 %s 之后有缺口"

#: refs.c
#, c-format
msgid "log for ref %s unexpectedly ended on %s"
msgstr "引用 %s 的日志意外终止于 %s "

#: refs.c
#, c-format
msgid "log for %s is empty"
msgstr "%s 的日志为空"

#: refs.c
#, c-format
msgid "refusing to update reflog for pseudoref '%s'"
msgstr "拒绝为伪引用 '%s' 更新引用日志"

#: refs.c
#, c-format
msgid "refusing to update pseudoref '%s'"
msgstr "拒绝更新伪引用 '%s'"

#: refs.c
#, c-format
msgid "refusing to update reflog with bad name '%s'"
msgstr "拒绝使用错误名称 '%s' 更新引用日志"

#: refs.c
#, c-format
msgid "refusing to update ref with bad name '%s'"
msgstr "拒绝更新有错误名称 '%s' 的引用"

#: refs.c
msgid "refusing to force and skip creation of reflog"
msgstr "拒绝强制跳过创建引用日志"

#: refs.c
#, c-format
msgid "update_ref failed for ref '%s': %s"
msgstr "对引用 '%s' 执行 update_ref 失败：%s"

#: refs.c
#, c-format
msgid "multiple updates for ref '%s' not allowed"
msgstr "不允许对引用 '%s' 多次更新"

#: refs.c
msgid "ref updates forbidden inside quarantine environment"
msgstr "在隔离环境中禁止更新引用"

#: refs.c
msgid "ref updates aborted by hook"
msgstr "引用更新被钩子中止"

#: refs.c
#, c-format
msgid "'%s' exists; cannot create '%s'"
msgstr "'%s' 已存在，无法创建 '%s'"

#: refs.c
#, c-format
msgid "cannot process '%s' and '%s' at the same time"
msgstr "无法同时处理 '%s' 和 '%s'"

#: refs.c
#, c-format
msgid "could not delete reference %s: %s"
msgstr "无法删除引用 %s：%s"

#: refs.c
#, c-format
msgid "could not delete references: %s"
msgstr "无法删除引用：%s"

#: refs.c
#, c-format
msgid "Finished dry-run migration of refs, the result can be found at '%s'\n"
msgstr "已完成 refs 的试运行迁移，结果可在 '%s' 处找到\n"

#: refs.c
#, c-format
msgid "could not remove temporary migration directory '%s'"
msgstr "无法删除临时迁移目录 '%s'"

#: refs.c
#, c-format
msgid "migrated refs can be found at '%s'"
msgstr "迁移的引用可以在 '%s' 处找到"

#: refs/files-backend.c refs/reftable-backend.c
#, c-format
msgid ""
"cannot lock ref '%s': expected symref with target '%s': but is a regular ref"
msgstr "无法锁定引用 '%s'：预期目标为 '%s' 的符号引用：但是是普通引用"

#: refs/files-backend.c
#, c-format
msgid "cannot read ref file '%s'"
msgstr "无法读取引用文件 '%s'"

#: refs/files-backend.c
#, c-format
msgid "cannot open directory %s"
msgstr "无法打开目录 %s"

#: refs/files-backend.c
msgid "Checking references consistency"
msgstr "正在检查引用一致性"

#: refs/reftable-backend.c
#, c-format
msgid "refname is dangerous: %s"
msgstr "危险的引用名称：%s"

#: refs/reftable-backend.c
#, c-format
msgid "trying to write ref '%s' with nonexistent object %s"
msgstr "试图用不存在的对象 %2$s 写入引用 '%1$s'"

#: refs/reftable-backend.c
#, c-format
msgid "trying to write non-commit object %s to branch '%s'"
msgstr "尝试将非提交对象 %s 写入分支 '%s'"

#: refs/reftable-backend.c
#, c-format
msgid ""
"multiple updates for 'HEAD' (including one via its referent '%s') are not "
"allowed"
msgstr "不允许对 'HEAD' 进行多次更新（包括通过其引用 '%s' 进行的更新）"

#: refs/reftable-backend.c
#, c-format
msgid "cannot lock ref '%s': unable to resolve reference '%s'"
msgstr "无法锁定引用 '%s'：无法解析引用 '%s'"

#: refs/reftable-backend.c
#, c-format
msgid "cannot lock ref '%s': error reading reference"
msgstr "无法锁定引用 '%s'：读取引用时出错"

#: refs/reftable-backend.c
#, c-format
msgid ""
"multiple updates for '%s' (including one via symref '%s') are not allowed"
msgstr "不允许对 '%s' 进行多次更新（包括通过符号引用 '%s' 更新）"

#: refs/reftable-backend.c
#, c-format
msgid "cannot lock ref '%s': reference already exists"
msgstr "无法锁定引用 '%s'：引用已存在"

#: refs/reftable-backend.c
#, c-format
msgid "cannot lock ref '%s': reference is missing but expected %s"
msgstr "无法锁定 '%s' 引用：引用丢失，但预期为 %s"

#: refs/reftable-backend.c
#, c-format
msgid "cannot lock ref '%s': is at %s but expected %s"
msgstr "无法锁定 '%s' 引用：位于 %s，但预期为 %s"

#: refs/reftable-backend.c
#, c-format
msgid "reftable: transaction prepare: %s"
msgstr "reftable: 事务准备：%s"

#: refs/reftable-backend.c
#, c-format
msgid "reftable: transaction failure: %s"
msgstr "reftable: 事务失败：%s"

#: refs/reftable-backend.c
#, c-format
msgid "unable to compact stack: %s"
msgstr "无法压缩栈：%s"

#: refs/reftable-backend.c
#, c-format
msgid "refname %s not found"
msgstr "引用名称 %s 未找到"

#: refs/reftable-backend.c
#, c-format
msgid "refname %s is a symbolic ref, copying it is not supported"
msgstr "引用名 %s 是一个符号引用，不支持复制"

#: refspec.c
#, c-format
msgid "invalid refspec '%s'"
msgstr "无效的引用规格：'%s'"

#: refspec.c
#, c-format
msgid "pattern '%s' has no '*'"
msgstr "模式 '%s' 没有 '*'"

#: refspec.c
#, c-format
msgid "replacement '%s' has no '*'"
msgstr "替换 '%s' 没有 '*'"

#: remote-curl.c
#, c-format
msgid "invalid quoting in push-option value: '%s'"
msgstr "在 push-option 取值中无效的引号：'%s'"

#: remote-curl.c
#, c-format
msgid "unknown value for object-format: %s"
msgstr "对象格式的未知取值：%s"

#: remote-curl.c
#, c-format
msgid "%sinfo/refs not valid: is this a git repository?"
msgstr "%sinfo/refs 无效：这是 git 仓库么？"

#: remote-curl.c
msgid "invalid server response; expected service, got flush packet"
msgstr "无效的服务端响应。预期服务，得到 flush 包"

#: remote-curl.c
#, c-format
msgid "invalid server response; got '%s'"
msgstr "无效的服务端响应，得到 '%s'"

#: remote-curl.c
#, c-format
msgid "repository '%s' not found"
msgstr "仓库 '%s' 未找到"

#: remote-curl.c
#, c-format
msgid "Authentication failed for '%s'"
msgstr "'%s' 鉴权失败"

#: remote-curl.c
#, c-format
msgid "unable to access '%s' with http.pinnedPubkey configuration: %s"
msgstr "无法以 http.pinnedPubkey 设置访问 '%s'：%s"

#: remote-curl.c
#, c-format
msgid "unable to access '%s': %s"
msgstr "无法访问 '%s'：%s"

#: remote-curl.c
#, c-format
msgid "redirecting to %s"
msgstr "重定向到 %s"

#: remote-curl.c
msgid "shouldn't have EOF when not gentle on EOF"
msgstr "当没有设置温和处理文件结束符（EOF）时，不应该有文件结束符"

#: remote-curl.c
msgid "remote server sent unexpected response end packet"
msgstr "远程服务器发送意外的响应结束数据包"

#: remote-curl.c
msgid "unable to rewind rpc post data - try increasing http.postBuffer"
msgstr "无法倒回 rpc post 数据 - 尝试增加 http.postBuffer"

#: remote-curl.c
#, c-format
msgid "remote-curl: bad line length character: %.4s"
msgstr "remote-curl：错误的行宽字符：%.4s"

#: remote-curl.c
msgid "remote-curl: unexpected response end packet"
msgstr "remote-curl：意外响应结束包"

#: remote-curl.c
#, c-format
msgid "RPC failed; %s"
msgstr "RPC 失败。%s"

#: remote-curl.c
msgid "cannot handle pushes this big"
msgstr "不能处理这么大的推送"

#: remote-curl.c
#, c-format
msgid "cannot deflate request; zlib deflate error %d"
msgstr "不能压缩请求，zlib 压缩错误 %d"

#: remote-curl.c
#, c-format
msgid "cannot deflate request; zlib end error %d"
msgstr "不能压缩请求，zlib 结束错误 %d"

#: remote-curl.c
#, c-format
msgid "%d bytes of length header were received"
msgstr "收到了 %d 字节长度的头信息"

#: remote-curl.c
#, c-format
msgid "%d bytes of body are still expected"
msgstr "预期仍然需要 %d 个字节的正文"

#: remote-curl.c
msgid "dumb http transport does not support shallow capabilities"
msgstr "哑 http 传输不支持浅克隆能力"

#: remote-curl.c
msgid "fetch failed."
msgstr "获取失败。"

#: remote-curl.c
msgid "cannot fetch by sha1 over smart http"
msgstr "无法通过智能 HTTP 获取 sha1"

#: remote-curl.c
#, c-format
msgid "protocol error: expected sha/ref, got '%s'"
msgstr "协议错误：期望 sha/ref，却得到 '%s'"

#: remote-curl.c
#, c-format
msgid "http transport does not support %s"
msgstr "http 传输协议不支持 %s"

#: remote-curl.c
msgid "protocol error: expected '<url> <path>', missing space"
msgstr "协议错误：预期 '<url> <path>'，缺少空格"

#: remote-curl.c
#, c-format
msgid "failed to download file at URL '%s'"
msgstr "无法下载位于 URL '%s' 的文件"

#: remote-curl.c
msgid "git-http-push failed"
msgstr "git-http-push 失败"

#: remote-curl.c
msgid "remote-curl: usage: git remote-curl <remote> [<url>]"
msgstr "remote-curl：用法：git remote-curl <远程> [<url>]"

#: remote-curl.c
msgid "remote-curl: error reading command stream from git"
msgstr "remote-curl：错误读取来自 git 的命令流"

#: remote-curl.c
msgid "remote-curl: fetch attempted without a local repo"
msgstr "remote-curl：尝试没有本地仓库下获取"

#: remote-curl.c
#, c-format
msgid "remote-curl: unknown command '%s' from git"
msgstr "remote-curl：未知的来自 git 的命令 '%s'"

#: remote.c
#, c-format
msgid ""
"reading remote from \"%s/%s\", which is nominated for removal.\n"
"\n"
"If you still use the \"remotes/\" directory it is recommended to\n"
"migrate to config-based remotes:\n"
"\n"
"\tgit remote rename %s %s\n"
"\n"
"If you cannot, please let us know why you still need to use it by\n"
"sending an e-mail to <git@vger.kernel.org>."
msgstr ""
"正在从 \"%s/%s\" 读取远程内容，该内容被提名删除。\n"
"\n"
"如果你仍然在使用 \"remotes/\" 目录，建议迁移为基于配置远程的方式：\n"
"\n"
"\tgit remote rename %s %s\n"
"\n"
"如果你无法迁移，请发送电子邮件至 <git@vger.kernel.org> 告知我们你\n"
"仍然需要使用它的原因。"

#: remote.c
#, c-format
msgid "config remote shorthand cannot begin with '/': %s"
msgstr "配置的远程短名称不能以 '/' 开始：%s"

#: remote.c
msgid "more than one receivepack given, using the first"
msgstr "提供了一个以上的 receivepack，使用第一个"

#: remote.c
msgid "more than one uploadpack given, using the first"
msgstr "提供了一个以上的 uploadpack，使用第一个"

#: remote.c
#, c-format
msgid "unrecognized followRemoteHEAD value '%s' ignored"
msgstr "已忽略无法识别的 followRemoteHEAD 值 '%s'"

#: remote.c
#, c-format
msgid "unrecognized value transfer.credentialsInUrl: '%s'"
msgstr "无法识别的 transfer.credentialsInUrl 值：'%s'"

#: remote.c
#, c-format
msgid "URL '%s' uses plaintext credentials"
msgstr "URL '%s' 使用明文认证信息"

#: remote.c
#, c-format
msgid "Cannot fetch both %s and %s to %s"
msgstr "不能同时获取 %s 和 %s 至 %s"

#: remote.c
#, c-format
msgid "%s usually tracks %s, not %s"
msgstr "%s 通常跟踪 %s，而非 %s"

#: remote.c
#, c-format
msgid "%s tracks both %s and %s"
msgstr "%s 同时跟踪 %s 和 %s"

#: remote.c
#, c-format
msgid "src refspec %s does not match any"
msgstr "源引用规格 %s 没有匹配"

#: remote.c
#, c-format
msgid "src refspec %s matches more than one"
msgstr "源引用规格 %s 匹配超过一个"

#. TRANSLATORS: "matches '%s'%" is the <dst> part of "git push
#. <remote> <src>:<dst>" push, and "being pushed ('%s')" is
#. the <src>.
#.
#: remote.c
#, c-format
msgid ""
"The destination you provided is not a full refname (i.e.,\n"
"starting with \"refs/\"). We tried to guess what you meant by:\n"
"\n"
"- Looking for a ref that matches '%s' on the remote side.\n"
"- Checking if the <src> being pushed ('%s')\n"
"  is a ref in \"refs/{heads,tags}/\". If so we add a corresponding\n"
"  refs/{heads,tags}/ prefix on the remote side.\n"
"\n"
"Neither worked, so we gave up. You must fully qualify the ref."
msgstr ""
"您提供的目标不是一个完整的引用名称（即以 \"refs/\" 开头）。我们\n"
"试着猜测您的想法：\n"
"\n"
"- 在远端查询和 '%s' 匹配的引用。\n"
"- 检查要推送的 <src>（'%s'）是不是在 \"refs/{heads,tags}/\" 中的\n"
"  引用。如果是，我们会在对应的远端添加 refs/{heads,tags}/ 前缀。\n"
"\n"
"都不行，所以我们已放弃。您必须给出完整的引用。"

#: remote.c
#, c-format
msgid ""
"The <src> part of the refspec is a commit object.\n"
"Did you mean to create a new branch by pushing to\n"
"'%s:refs/heads/%s'?"
msgstr ""
"引用规格的 <src> 是一个提交对象。您是想创建一个新的分支而向\n"
"'%s:refs/heads/%s' 推送么？"

#: remote.c
#, c-format
msgid ""
"The <src> part of the refspec is a tag object.\n"
"Did you mean to create a new tag by pushing to\n"
"'%s:refs/tags/%s'?"
msgstr ""
"引用规格的 <src> 是一个标签对象。您是想创建一个新的标签而向\n"
"'%s:refs/tags/%s' 推送么？"

#: remote.c
#, c-format
msgid ""
"The <src> part of the refspec is a tree object.\n"
"Did you mean to tag a new tree by pushing to\n"
"'%s:refs/tags/%s'?"
msgstr ""
"引用规格的 <src> 是一个树对象。您是想为这个树对象创建标签而向\n"
"'%s:refs/tags/%s' 推送么？"

#: remote.c
#, c-format
msgid ""
"The <src> part of the refspec is a blob object.\n"
"Did you mean to tag a new blob by pushing to\n"
"'%s:refs/tags/%s'?"
msgstr ""
"引用规格的 <src> 是一个数据对象。您是想为这个数据对象创建标签而向\n"
"'%s:refs/tags/%s' 推送么？"

#: remote.c
#, c-format
msgid "%s cannot be resolved to branch"
msgstr "%s 无法被解析为分支"

#: remote.c
#, c-format
msgid "unable to delete '%s': remote ref does not exist"
msgstr "无法删除 '%s'：远程引用不存在"

#: remote.c
#, c-format
msgid "dst refspec %s matches more than one"
msgstr "目标引用规格 %s 匹配超过一个"

#: remote.c
#, c-format
msgid "dst ref %s receives from more than one src"
msgstr "目标引用 %s 接收超过一个源"

#: remote.c
msgid "HEAD does not point to a branch"
msgstr "HEAD 没有指向一个分支"

#: remote.c
#, c-format
msgid "no such branch: '%s'"
msgstr "没有此分支：'%s'"

#: remote.c
#, c-format
msgid "no upstream configured for branch '%s'"
msgstr "尚未给分支 '%s' 设置上游"

#: remote.c
#, c-format
msgid "upstream branch '%s' not stored as a remote-tracking branch"
msgstr "上游分支 '%s' 没有存储为一个远程跟踪分支"

#: remote.c
#, c-format
msgid "push destination '%s' on remote '%s' has no local tracking branch"
msgstr "推送目标 '%s' 至远程 '%s' 没有本地跟踪分支"

#: remote.c
#, c-format
msgid "branch '%s' has no remote for pushing"
msgstr "分支 '%s' 没有设置要推送的远程服务器"

#: remote.c
#, c-format
msgid "push refspecs for '%s' do not include '%s'"
msgstr "向 '%s' 推送引用规格未包含 '%s'"

#: remote.c
msgid "push has no destination (push.default is 'nothing')"
msgstr "推送无目标（push.default 是 'nothing'）"

#: remote.c
msgid "cannot resolve 'simple' push to a single destination"
msgstr "无法解析 'simple' 推送至一个单独的目标"

#: remote.c
#, c-format
msgid "couldn't find remote ref %s"
msgstr "无法找到远程引用 %s"

#: remote.c
#, c-format
msgid "* Ignoring funny ref '%s' locally"
msgstr "* 在本地忽略可笑的引用 '%s'"

#: remote.c
#, c-format
msgid "Your branch is based on '%s', but the upstream is gone.\n"
msgstr "您的分支基于 '%s'，但此上游分支已经不存在。\n"

#: remote.c
msgid "  (use \"git branch --unset-upstream\" to fixup)\n"
msgstr "  （使用 \"git branch --unset-upstream\" 来修复）\n"

#: remote.c
#, c-format
msgid "Your branch is up to date with '%s'.\n"
msgstr "您的分支与上游分支 '%s' 一致。\n"

#: remote.c
#, c-format
msgid "Your branch and '%s' refer to different commits.\n"
msgstr "您的分支和 '%s' 指向不同的提交。\n"

#: remote.c
#, c-format
msgid "  (use \"%s\" for details)\n"
msgstr "  （使用 \"%s\" 查看详情）\n"

#: remote.c
#, c-format
msgid "Your branch is ahead of '%s' by %d commit.\n"
msgid_plural "Your branch is ahead of '%s' by %d commits.\n"
msgstr[0] "您的分支领先 '%s' 共 %d 个提交。\n"
msgstr[1] "您的分支领先 '%s' 共 %d 个提交。\n"

#: remote.c
msgid "  (use \"git push\" to publish your local commits)\n"
msgstr "  （使用 \"git push\" 来发布您的本地提交）\n"

#: remote.c
#, c-format
msgid "Your branch is behind '%s' by %d commit, and can be fast-forwarded.\n"
msgid_plural ""
"Your branch is behind '%s' by %d commits, and can be fast-forwarded.\n"
msgstr[0] "您的分支落后 '%s' 共 %d 个提交，并且可以快进。\n"
msgstr[1] "您的分支落后 '%s' 共 %d 个提交，并且可以快进。\n"

#  译者：注意保持前导空格
#: remote.c
msgid "  (use \"git pull\" to update your local branch)\n"
msgstr "  （使用 \"git pull\" 来更新您的本地分支）\n"

#: remote.c
#, c-format
msgid ""
"Your branch and '%s' have diverged,\n"
"and have %d and %d different commit each, respectively.\n"
msgid_plural ""
"Your branch and '%s' have diverged,\n"
"and have %d and %d different commits each, respectively.\n"
msgstr[0] ""
"您的分支和 '%s' 出现了偏离，\n"
"并且分别有 %d 和 %d 处不同的提交。\n"
msgstr[1] ""
"您的分支和 '%s' 出现了偏离，\n"
"并且分别有 %d 和 %d 处不同的提交。\n"

#  译者：注意保持前导空格
#: remote.c
msgid ""
"  (use \"git pull\" if you want to integrate the remote branch with yours)\n"
msgstr "  （如果您想将远程分支与您的更改合并，请使用 \"git pull\"）\n"

#: remote.c
#, c-format
msgid "cannot parse expected object name '%s'"
msgstr "无法解析期望的对象名 '%s'"

#: remote.c
#, c-format
msgid "cannot strip one component off url '%s'"
msgstr "无法从 url '%s' 剥离一个组件"

#: replace-object.c
#, c-format
msgid "bad replace ref name: %s"
msgstr "错误的替换引用名称：%s"

#: replace-object.c
#, c-format
msgid "duplicate replace ref: %s"
msgstr "重复的替换引用：%s"

#: replace-object.c
#, c-format
msgid "replace depth too high for object %s"
msgstr "对象 %s 的替换层级太深"

#: rerere.c
msgid "corrupt MERGE_RR"
msgstr "损坏的 MERGE_RR"

#: rerere.c
msgid "unable to write rerere record"
msgstr "无法写入 rerere 记录"

#: rerere.c
#, c-format
msgid "there were errors while writing '%s' (%s)"
msgstr "写入 '%s' (%s) 时出错"

#: rerere.c
#, c-format
msgid "could not parse conflict hunks in '%s'"
msgstr "不能解析 '%s' 中的冲突块"

#: rerere.c
#, c-format
msgid "failed utime() on '%s'"
msgstr "在 '%s' 上调用 utime() 失败"

#: rerere.c
#, c-format
msgid "writing '%s' failed"
msgstr "写入 '%s' 失败"

#: rerere.c
#, c-format
msgid "Staged '%s' using previous resolution."
msgstr "使用之前的解决方案暂存 '%s'。"

#: rerere.c
#, c-format
msgid "Recorded resolution for '%s'."
msgstr "已记录 '%s' 的解决方案。"

#: rerere.c
#, c-format
msgid "Resolved '%s' using previous resolution."
msgstr "使用之前的解决方案解决 '%s'。"

#: rerere.c
#, c-format
msgid "cannot unlink stray '%s'"
msgstr "不能删除 stray '%s'"

#: rerere.c
#, c-format
msgid "Recorded preimage for '%s'"
msgstr "为 '%s' 记录 preimage"

#: rerere.c
#, c-format
msgid "failed to update conflicted state in '%s'"
msgstr "无法更新 '%s' 中的冲突状态"

#: rerere.c
#, c-format
msgid "no remembered resolution for '%s'"
msgstr "没有为 '%s' 记忆的解决方案"

#: rerere.c
#, c-format
msgid "Updated preimage for '%s'"
msgstr "已为 '%s' 更新 preimage"

#: rerere.c
#, c-format
msgid "Forgot resolution for '%s'\n"
msgstr "忘记 '%s' 的解决方案\n"

#: rerere.c
msgid "unable to open rr-cache directory"
msgstr "不能打开 rr-cache 目录"

#: rerere.h
msgid "update the index with reused conflict resolution if possible"
msgstr "如果可能，重用冲突解决更新索引"

#: reset.c
msgid "could not determine HEAD revision"
msgstr "不能确定 HEAD 版本"

#: reset.c sequencer.c
#, c-format
msgid "failed to find tree of %s"
msgstr "无法找到 %s 指向的树"

#: revision.c
#, c-format
msgid "unsupported section for hidden refs: %s"
msgstr "不支持的隐藏引用片段： %s"

#: revision.c
msgid "--exclude-hidden= passed more than once"
msgstr "--exclude-hidden= 传递了不止一次"

#: revision.c
#, c-format
msgid "resolve-undo records `%s` which is missing"
msgstr "resolve-undo 记录 `%s`，现缺失"

#: revision.c
#, c-format
msgid "%s exists but is a symbolic ref"
msgstr "%s 存在但是一个符号引用"

#: revision.c
msgid ""
"--merge requires one of the pseudorefs MERGE_HEAD, CHERRY_PICK_HEAD, "
"REVERT_HEAD or REBASE_HEAD"
msgstr ""
"--merge 选项需要指定 MERGE_HEAD、CHERRY_PICK_HEAD、REVERT_HEAD 或 "
"REBASE_HEAD 中的一个伪引用"

#: revision.c
#, c-format
msgid "could not get commit for --ancestry-path argument %s"
msgstr "无法获得 --ancestry-path 参数 %s 的提交"

#: revision.c
msgid "--unpacked=<packfile> no longer supported"
msgstr "不再支持 --unpacked=<packfile>"

#: revision.c
#, c-format
msgid "invalid option '%s' in --stdin mode"
msgstr "在 --stdin 模式下的无效选项：'%s'"

#: revision.c
msgid "your current branch appears to be broken"
msgstr "您的当前分支好像被损坏"

#: revision.c
#, c-format
msgid "your current branch '%s' does not have any commits yet"
msgstr "您的当前分支 '%s' 尚无任何提交"

#: revision.c
msgid "object filtering requires --objects"
msgstr "对象过滤需要 --objects"

#: revision.c
msgid "-L does not yet support diff formats besides -p and -s"
msgstr "-L 尚不支持 -p 和 -s 之外的差异格式"

#: run-command.c
#, c-format
msgid "cannot create async thread: %s"
msgstr "不能创建 async 线程：%s"

#: scalar.c worktree.c
#, c-format
msgid "'%s' does not exist"
msgstr "'%s' 不存在"

#: scalar.c
#, c-format
msgid "could not switch to '%s'"
msgstr "无法切换到 '%s'"

#: scalar.c
msgid "need a working directory"
msgstr "需要一个工作目录"

#: scalar.c
msgid "Scalar enlistments require a worktree"
msgstr "Scalar 登记需要一个工作树"

#: scalar.c
#, c-format
msgid "could not configure %s=%s"
msgstr "无法配置 %s=%s"

#: scalar.c
msgid "could not configure log.excludeDecoration"
msgstr "无法配置 log.excludeDecoration"

#: scalar.c
msgid "could not add enlistment"
msgstr "无法添加登记"

#: scalar.c
msgid "could not set recommended config"
msgstr "无法设置推荐的配置"

#: scalar.c
msgid "could not turn on maintenance"
msgstr "无法打开维护模式"

#: scalar.c
msgid "could not start the FSMonitor daemon"
msgstr "无法启动 FSMonitor 守护进程"

#: scalar.c
msgid "could not turn off maintenance"
msgstr "无法关闭维护模式"

#: scalar.c
msgid "could not remove enlistment"
msgstr "无法删除登记"

#: scalar.c
#, c-format
msgid "remote HEAD is not a branch: '%.*s'"
msgstr "远程 HEAD 不是一个分支：'%.*s'"

#: scalar.c
msgid "failed to get default branch name from remote; using local default"
msgstr "无法从远程获取默认分支名称；使用本地默认值"

#: scalar.c
msgid "failed to get default branch name"
msgstr "无法获取默认分支名称"

#: scalar.c
msgid "failed to unregister repository"
msgstr "无法取消注册仓库"

#: scalar.c
msgid "failed to stop the FSMonitor daemon"
msgstr "无法停止 FSMonitor 守护进程"

#: scalar.c
msgid "failed to delete enlistment directory"
msgstr "无法删除登记目录"

#: scalar.c
msgid "branch to checkout after clone"
msgstr "克隆后要检出的分支"

#: scalar.c
msgid "when cloning, create full working directory"
msgstr "在克隆时，创建完整的工作目录"

#: scalar.c
msgid "only download metadata for the branch that will be checked out"
msgstr "只下载要检出的分支的元信息"

#: scalar.c
msgid "create repository within 'src' directory"
msgstr "在 'src' 目录中创建仓库"

#: scalar.c
msgid "specify if tags should be fetched during clone"
msgstr "如若应在克隆期间获取标签则指定"

#: scalar.c
msgid ""
"scalar clone [--single-branch] [--branch <main-branch>] [--full-clone]\n"
"\t[--[no-]src] [--[no-]tags] <url> [<enlistment>]"
msgstr ""
"scalar clone [--single-branch] [--branch <main-branch>] [--full-clone]\n"
"\t[--[no-]src] [--[no-]tags] <url> [<登记>]"

#: scalar.c
#, c-format
msgid "cannot deduce worktree name from '%s'"
msgstr "无法从 '%s' 猜测工作区名称"

#: scalar.c
#, c-format
msgid "directory '%s' exists already"
msgstr "目录 '%s' 已存在"

#: scalar.c
#, c-format
msgid "failed to get default branch for '%s'"
msgstr "无法获取 '%s' 的默认分支"

#: scalar.c
#, c-format
msgid "could not configure remote in '%s'"
msgstr "无法在 '%s' 中配置远程"

#: scalar.c
#, c-format
msgid "could not disable tags in '%s'"
msgstr "无法禁用 '%s' 中的标签"

#: scalar.c
#, c-format
msgid "could not configure '%s'"
msgstr "无法配置 '%s'"

#: scalar.c
msgid "partial clone failed; attempting full clone"
msgstr "部分克隆失败；尝试完整克隆"

#: scalar.c
msgid "could not configure for full clone"
msgstr "无法配置完整克隆"

#: scalar.c
msgid "scalar diagnose [<enlistment>]"
msgstr "scalar diagnose [<登记>]"

#: scalar.c
msgid "`scalar list` does not take arguments"
msgstr "`scalar list` 不带参数"

#: scalar.c
msgid "scalar register [<enlistment>]"
msgstr "scalar register [<登记>]"

#: scalar.c
msgid "reconfigure all registered enlistments"
msgstr "重新配置所有注册的登记"

#: scalar.c
msgid "scalar reconfigure [--all | <enlistment>]"
msgstr "scalar reconfigure [--all | <登记>]"

#: scalar.c
msgid "--all or <enlistment>, but not both"
msgstr "--all 或者 <登记>，而不是两个一起"

#: scalar.c
#, c-format
msgid "could not remove stale scalar.repo '%s'"
msgstr "无法删除过期的 scalar.repo '%s'"

#: scalar.c
#, c-format
msgid "removed stale scalar.repo '%s'"
msgstr "已删除过期的 scalar.repo '%s'"

#: scalar.c
#, c-format
msgid "repository at '%s' has different owner"
msgstr "位于 '%s' 处的仓库有不同的所有者"

#: scalar.c
#, c-format
msgid "repository at '%s' has a format issue"
msgstr "位于 '%s' 处的仓库存在格式问题"

#: scalar.c
#, c-format
msgid "repository not found in '%s'"
msgstr "在 '%s' 中找不到仓库"

#: scalar.c
#, c-format
msgid ""
"to unregister this repository from Scalar, run\n"
"\tgit config --global --unset --fixed-value scalar.repo \"%s\""
msgstr ""
"若希望从 Scalar 注销该仓库，执行\n"
"\tgit config --global --unset --fixed-value scalar.repo \"%s\""

#: scalar.c
msgid ""
"scalar run <task> [<enlistment>]\n"
"Tasks:\n"
msgstr ""
"scalar run <任务> [<登记>]\n"
"任务：\n"

#: scalar.c
#, c-format
msgid "no such task: '%s'"
msgstr "没有此任务：'%s'"

#: scalar.c
msgid "scalar unregister [<enlistment>]"
msgstr "scalar unregister [<登记>]"

#: scalar.c
msgid "scalar delete <enlistment>"
msgstr "scalar delete <登记>"

#: scalar.c
msgid "refusing to delete current working directory"
msgstr "拒绝删除当前工作目录"

#: scalar.c
msgid "include Git version"
msgstr "包括 Git 的版本"

#: scalar.c
msgid "include Git's build options"
msgstr "包括 Git 的构建选项"

#: scalar.c
msgid "scalar verbose [-v | --verbose] [--build-options]"
msgstr "scalar verbose [-v | --verbose] [--build-options]"

#: scalar.c
msgid "-C requires a <directory>"
msgstr "-C 需要 <目录>"

#: scalar.c
#, c-format
msgid "could not change to '%s'"
msgstr "无法变更到 '%s'"

#: scalar.c
msgid "-c requires a <key>=<value> argument"
msgstr "-c 需要 <键>=<值> 参数"

#: scalar.c
msgid ""
"scalar [-C <directory>] [-c <key>=<value>] <command> [<options>]\n"
"\n"
"Commands:\n"
msgstr ""
"scalar [-C <目录>] [-c <键>=<值>] <命令> [<选项>]\n"
"\n"
"命令：\n"

#: send-pack.c
msgid "unexpected flush packet while reading remote unpack status"
msgstr "读取远程解包状态时收到意外的 flush 包"

#: send-pack.c
#, c-format
msgid "unable to parse remote unpack status: %s"
msgstr "不能解析远程解包状态：%s"

#: send-pack.c
#, c-format
msgid "remote unpack failed: %s"
msgstr "远程解包失败：%s"

#: send-pack.c
msgid "failed to sign the push certificate"
msgstr "无法为推送证书签名"

#: send-pack.c
msgid "send-pack: unable to fork off fetch subprocess"
msgstr "send-pack：无法派生 fetch 子进程"

#: send-pack.c
msgid "push negotiation failed; proceeding anyway with push"
msgstr "推送协商失败，但还是继续推送"

#: send-pack.c
msgid "the receiving end does not support this repository's hash algorithm"
msgstr "接收端不支持这个仓库的哈希算法"

#: send-pack.c
msgid "the receiving end does not support --signed push"
msgstr "接收端不支持签名推送（--signed）"

#: send-pack.c
msgid ""
"not sending a push certificate since the receiving end does not support --"
"signed push"
msgstr "未发送推送证书，因为接收端不支持签名推送（--signed）"

#: send-pack.c
msgid "the receiving end does not support --atomic push"
msgstr "接收端不支持原子推送（--atomic）"

#: send-pack.c
msgid "the receiving end does not support push options"
msgstr "接收端不支持推送选项"

#: sequencer.c
#, c-format
msgid "invalid commit message cleanup mode '%s'"
msgstr "无效的提交信息清理模式 '%s'"

#: sequencer.c
#, c-format
msgid "could not delete '%s'"
msgstr "无法删除 '%s'"

#: sequencer.c
msgid "revert"
msgstr "还原"

#: sequencer.c
msgid "cherry-pick"
msgstr "拣选"

#: sequencer.c
msgid "rebase"
msgstr "变基"

#: sequencer.c
#, c-format
msgid "unknown action: %d"
msgstr "未知动作：%d"

#: sequencer.c
msgid ""
"Resolve all conflicts manually, mark them as resolved with\n"
"\"git add/rm <conflicted_files>\", then run \"git rebase --continue\".\n"
"You can instead skip this commit: run \"git rebase --skip\".\n"
"To abort and get back to the state before \"git rebase\", run \"git rebase --"
"abort\"."
msgstr ""
"手工解决所有冲突，执行 \"git add/rm <冲突的文件>\" 标记\n"
"冲突已解决，然后执行 \"git rebase --continue\"。您也可以执行\n"
"\"git rebase --skip\" 命令跳过这个提交。如果想要终止执行并回到\n"
"\"git rebase\" 执行之前的状态，执行 \"git rebase --abort\"。"

#: sequencer.c
msgid ""
"after resolving the conflicts, mark the corrected paths\n"
"with 'git add <paths>' or 'git rm <paths>'"
msgstr ""
"冲突解决完毕后，用 'git add <路径>' 或 'git rm <路径>'\n"
"命令标记修正后的文件"

#: sequencer.c
msgid ""
"After resolving the conflicts, mark them with\n"
"\"git add/rm <pathspec>\", then run\n"
"\"git cherry-pick --continue\".\n"
"You can instead skip this commit with \"git cherry-pick --skip\".\n"
"To abort and get back to the state before \"git cherry-pick\",\n"
"run \"git cherry-pick --abort\"."
msgstr ""
"解决所有冲突之后，用 \"git add/rm <路径规格>\" 标记它们，\n"
"然后执行 \"git cherry-pick --continue\"。您也可以执行\n"
"\"git cherry-pick --skip\" 命令跳过这个提交。如果想要终止执行并回到\n"
"执行 \"git cherry-pick\" 之前的状态，执行 \"git cherry-pick --abort\"。"

#: sequencer.c
msgid ""
"After resolving the conflicts, mark them with\n"
"\"git add/rm <pathspec>\", then run\n"
"\"git revert --continue\".\n"
"You can instead skip this commit with \"git revert --skip\".\n"
"To abort and get back to the state before \"git revert\",\n"
"run \"git revert --abort\"."
msgstr ""
"解决所有冲突之后，用 \"git add/rm <路径规格>\" 标记它们，\n"
"然后执行 \"git revert --continue\"。您也可以执行\n"
"\"git revert --skip\" 命令跳过这个提交。如果想要终止执行并回到\n"
"执行 \"git revert\" 之前的状态，执行 \"git revert --abort\"。"

#: sequencer.c
#, c-format
msgid "could not lock '%s'"
msgstr "不能锁定 '%s'"

#: sequencer.c
#, c-format
msgid "could not write eol to '%s'"
msgstr "不能将换行符写入 '%s'"

#: sequencer.c
#, c-format
msgid "failed to finalize '%s'"
msgstr "无法完成 '%s'"

#: sequencer.c
#, c-format
msgid "your local changes would be overwritten by %s."
msgstr "您的本地修改将被%s覆盖。"

#: sequencer.c
msgid "commit your changes or stash them to proceed."
msgstr "提交您的修改或贮藏后再继续。"

#. TRANSLATORS: %s will be "revert", "cherry-pick" or
#. "rebase".
#.
#: sequencer.c
#, c-format
msgid "%s: Unable to write new index file"
msgstr "%s：无法写入新索引文件"

#: sequencer.c
msgid "unable to update cache tree"
msgstr "不能更新缓存树"

#: sequencer.c
msgid "could not resolve HEAD commit"
msgstr "不能解析 HEAD 提交"

#: sequencer.c
#, c-format
msgid "no key present in '%.*s'"
msgstr "在 '%.*s' 中没有 key"

#: sequencer.c
#, c-format
msgid "unable to dequote value of '%s'"
msgstr "无法为 '%s' 的值去引号"

#: sequencer.c
msgid "'GIT_AUTHOR_NAME' already given"
msgstr "已经给出 'GIT_AUTHOR_NAME'"

#: sequencer.c
msgid "'GIT_AUTHOR_EMAIL' already given"
msgstr "已经给出 'GIT_AUTHOR_EMAIL'"

#: sequencer.c
msgid "'GIT_AUTHOR_DATE' already given"
msgstr "已经给出 'GIT_AUTHOR_DATE'"

#: sequencer.c
#, c-format
msgid "unknown variable '%s'"
msgstr "未知变量 '%s'"

#: sequencer.c
msgid "missing 'GIT_AUTHOR_NAME'"
msgstr "缺少 'GIT_AUTHOR_NAME'"

#: sequencer.c
msgid "missing 'GIT_AUTHOR_EMAIL'"
msgstr "缺少 'GIT_AUTHOR_EMAIL'"

#: sequencer.c
msgid "missing 'GIT_AUTHOR_DATE'"
msgstr "缺少 'GIT_AUTHOR_DATE'"

#: sequencer.c
#, c-format
msgid ""
"you have staged changes in your working tree\n"
"If these changes are meant to be squashed into the previous commit, run:\n"
"\n"
"  git commit --amend %s\n"
"\n"
"If they are meant to go into a new commit, run:\n"
"\n"
"  git commit %s\n"
"\n"
"In both cases, once you're done, continue with:\n"
"\n"
"  git rebase --continue\n"
msgstr ""
"您的工作区中存在已暂存的修改\n"
"如果这些修改需要被挤压到前一个提交，执行：\n"
"\n"
"  git commit --amend %s\n"
"\n"
"如果这些修改要形成一个新提交，执行：\n"
"\n"
"  git commit %s\n"
"\n"
"无论哪种情况，当您完成提交，继续执行：\n"
"\n"
"  git rebase --continue\n"

#: sequencer.c
msgid "'prepare-commit-msg' hook failed"
msgstr "'prepare-commit-msg' 钩子失败"

#: sequencer.c
msgid ""
"Your name and email address were configured automatically based\n"
"on your username and hostname. Please check that they are accurate.\n"
"You can suppress this message by setting them explicitly. Run the\n"
"following command and follow the instructions in your editor to edit\n"
"your configuration file:\n"
"\n"
"    git config --global --edit\n"
"\n"
"After doing this, you may fix the identity used for this commit with:\n"
"\n"
"    git commit --amend --reset-author\n"
msgstr ""
"您的姓名和邮件地址基于登录名和主机名进行了自动设置。请检查它们正确\n"
"与否。您可以对其进行设置以免再出现本提示信息。运行如下命令在编辑器\n"
"中编辑您的配置文件：\n"
"\n"
"    git config --global --edit\n"
"\n"
"设置完毕后，您可以用下面的命令来修正本次提交所使用的用户身份：\n"
"\n"
"    git commit --amend --reset-author\n"

#: sequencer.c
msgid ""
"Your name and email address were configured automatically based\n"
"on your username and hostname. Please check that they are accurate.\n"
"You can suppress this message by setting them explicitly:\n"
"\n"
"    git config --global user.name \"Your Name\"\n"
"    git config --global user.email you@example.com\n"
"\n"
"After doing this, you may fix the identity used for this commit with:\n"
"\n"
"    git commit --amend --reset-author\n"
msgstr ""
"您的姓名和邮件地址基于登录名和主机名进行了自动设置。请检查它们正确\n"
"与否。您可以对其进行设置以免再出现本提示信息：\n"
"\n"
"    git config --global user.name \"Your Name\"\n"
"    git config --global user.email you@example.com\n"
"\n"
"设置完毕后，您可以用下面的命令来修正本次提交所使用的用户身份：\n"
"\n"
"    git commit --amend --reset-author\n"

#: sequencer.c
msgid "couldn't look up newly created commit"
msgstr "无法找到新创建的提交"

#: sequencer.c
msgid "could not parse newly created commit"
msgstr "不能解析新创建的提交"

#: sequencer.c
msgid "unable to resolve HEAD after creating commit"
msgstr "创建提交后，不能解析 HEAD"

#: sequencer.c
msgid "detached HEAD"
msgstr "分离头指针"

#  译者：中文字符串拼接，可删除前导空格
#: sequencer.c
msgid " (root-commit)"
msgstr "（根提交）"

#: sequencer.c
msgid "could not parse HEAD"
msgstr "不能解析 HEAD"

#: sequencer.c
#, c-format
msgid "HEAD %s is not a commit!"
msgstr "HEAD %s 不是一个提交！"

#: sequencer.c
msgid "unable to parse commit author"
msgstr "不能解析提交作者"

#: sequencer.c
#, c-format
msgid "unable to read commit message from '%s'"
msgstr "不能从 '%s' 读取提交说明"

#: sequencer.c
#, c-format
msgid "invalid author identity '%s'"
msgstr "无效的作者身份 '%s'"

#: sequencer.c
msgid "corrupt author: missing date information"
msgstr "损坏的作者：缺失日期信息"

#: sequencer.c
#, c-format
msgid "could not update %s"
msgstr "不能更新 %s"

#: sequencer.c
#, c-format
msgid "could not parse parent commit %s"
msgstr "不能解析父提交 %s"

#: sequencer.c
#, c-format
msgid "unknown command: %d"
msgstr "未知命令：%d"

#: sequencer.c
msgid "This is the 1st commit message:"
msgstr "这是第一个提交说明："

#: sequencer.c
#, c-format
msgid "This is the commit message #%d:"
msgstr "这是提交说明 #%d："

#: sequencer.c
msgid "The 1st commit message will be skipped:"
msgstr "第一个提交说明将被跳过："

#: sequencer.c
#, c-format
msgid "The commit message #%d will be skipped:"
msgstr "提交说明 #%d 将被跳过："

#: sequencer.c
#, c-format
msgid "This is a combination of %d commits."
msgstr "这是一个 %d 个提交的组合。"

#: sequencer.c
#, c-format
msgid "cannot write '%s'"
msgstr "不能写 '%s'"

#: sequencer.c
msgid "need a HEAD to fixup"
msgstr "需要一个 HEAD 来修复"

#: sequencer.c
msgid "could not read HEAD"
msgstr "不能读取 HEAD"

#: sequencer.c
msgid "could not read HEAD's commit message"
msgstr "不能读取 HEAD 的提交说明"

#: sequencer.c
#, c-format
msgid "could not read commit message of %s"
msgstr "不能读取 %s 的提交说明"

#: sequencer.c
msgid "your index file is unmerged."
msgstr "您的索引文件未完成合并。"

#: sequencer.c
msgid "cannot fixup root commit"
msgstr "不能修复根提交"

#: sequencer.c
#, c-format
msgid "commit %s is a merge but no -m option was given."
msgstr "提交 %s 是一个合并提交但未提供 -m 选项。"

#: sequencer.c
#, c-format
msgid "commit %s does not have parent %d"
msgstr "提交 %s 没有第 %d 个父提交"

#: sequencer.c
#, c-format
msgid "cannot get commit message for %s"
msgstr "不能得到 %s 的提交说明"

#. TRANSLATORS: The first %s will be a "todo" command like
#. "revert" or "pick", the second %s a SHA1.
#: sequencer.c
#, c-format
msgid "%s: cannot parse parent commit %s"
msgstr "%s：不能解析父提交 %s"

#: sequencer.c
#, c-format
msgid "could not revert %s... %s"
msgstr "不能还原 %s... %s"

#: sequencer.c
#, c-format
msgid "could not apply %s... %s"
msgstr "不能应用 %s... %s"

#: sequencer.c
#, c-format
msgid "dropping %s %s -- patch contents already upstream\n"
msgstr "丢弃 %s %s -- 补丁内容已在上游\n"

#: sequencer.c
#, c-format
msgid "git %s: failed to read the index"
msgstr "git %s：无法读取索引"

#: sequencer.c
#, c-format
msgid "git %s: failed to refresh the index"
msgstr "git %s：无法刷新索引"

#: sequencer.c
#, c-format
msgid "'%s' is not a valid label"
msgstr "'%s' 不是一个有效的标签"

#: sequencer.c
#, c-format
msgid "'%s' is not a valid refname"
msgstr "'%s' 不是一个有效的引用名"

#: sequencer.c
#, c-format
msgid "update-ref requires a fully qualified refname e.g. refs/heads/%s"
msgstr "update-ref 需要一个完整的引用名，例如：refs/heads/%s"

#: sequencer.c
#, c-format
msgid "'%s' does not accept merge commits"
msgstr "'%s' 不接受合并提交"

#. TRANSLATORS: 'pick' and 'merge -C' should not be
#. translated.
#.
#: sequencer.c
msgid ""
"'pick' does not take a merge commit. If you wanted to\n"
"replay the merge, use 'merge -C' on the commit."
msgstr ""
"'pick' 不接受合并提交。如果您想要重放合并，\n"
"请在提交上使用 'merge -C'。"

#. TRANSLATORS: 'reword' and 'merge -c' should not be
#. translated.
#.
#: sequencer.c
msgid ""
"'reword' does not take a merge commit. If you wanted to\n"
"replay the merge and reword the commit message, use\n"
"'merge -c' on the commit"
msgstr ""
"'reword' 不接受合并提交。如果您想重放合并并重写提交消息，\n"
"请在提交上使用 'merge -c'"

#. TRANSLATORS: 'edit', 'merge -C' and 'break' should
#. not be translated.
#.
#: sequencer.c
msgid ""
"'edit' does not take a merge commit. If you wanted to\n"
"replay the merge, use 'merge -C' on the commit, and then\n"
"'break' to give the control back to you so that you can\n"
"do 'git commit --amend && git rebase --continue'."
msgstr ""
"'edit”' 不接受合并提交。如果您想要重放合并，\n"
"请在提交上使用 'merge -C'，然后使用 'break'\n"
"将控制权交还给您，以便您可以执行\n"
"'git commit --amend && git rebase --continue'。"

#: sequencer.c
msgid "cannot squash merge commit into another commit"
msgstr "无法将合并提交压缩到另一个提交中"

#: sequencer.c
#, c-format
msgid "invalid command '%.*s'"
msgstr "无效命令 '%.*s'"

#: sequencer.c
#, c-format
msgid "missing arguments for %s"
msgstr "缺少 %s 的参数"

#: sequencer.c
#, c-format
msgid "could not parse '%s'"
msgstr "无法解析 '%s'"

#: sequencer.c
#, c-format
msgid "invalid line %d: %.*s"
msgstr "无效行 %d：%.*s"

#: sequencer.c
#, c-format
msgid "cannot '%s' without a previous commit"
msgstr "没有父提交的情况下不能 '%s'"

#: sequencer.c
msgid "cancelling a cherry picking in progress"
msgstr "正在取消一个进行中的拣选"

#: sequencer.c
msgid "cancelling a revert in progress"
msgstr "正在取消一个进行中的还原"

#: sequencer.c
msgid "please fix this using 'git rebase --edit-todo'."
msgstr "请用 'git rebase --edit-todo' 来修改。"

#: sequencer.c
#, c-format
msgid "unusable instruction sheet: '%s'"
msgstr "不可用的指令清单：'%s'"

#: sequencer.c
msgid "no commits parsed."
msgstr "没有解析提交。"

#: sequencer.c
msgid "cannot cherry-pick during a revert."
msgstr "不能在回退中执行拣选。"

#: sequencer.c
msgid "cannot revert during a cherry-pick."
msgstr "不能在拣选中执行回退。"

#: sequencer.c
msgid "unusable squash-onto"
msgstr "不可用的 squash-onto"

#: sequencer.c
#, c-format
msgid "malformed options sheet: '%s'"
msgstr "格式错误的选项清单：'%s'"

#: sequencer.c
msgid "empty commit set passed"
msgstr "提供了空的提交集"

#: sequencer.c
msgid "revert is already in progress"
msgstr "一个还原操作已在进行"

#: sequencer.c
#, c-format
msgid "try \"git revert (--continue | %s--abort | --quit)\""
msgstr "尝试 \"git revert (--continue | %s--abort | --quit)\""

#: sequencer.c
msgid "cherry-pick is already in progress"
msgstr "拣选操作已在进行"

#: sequencer.c
#, c-format
msgid "try \"git cherry-pick (--continue | %s--abort | --quit)\""
msgstr "尝试 \"git cherry-pick (--continue | %s--abort | --quit)\""

#: sequencer.c
#, c-format
msgid "could not create sequencer directory '%s'"
msgstr "不能创建序列目录 '%s'"

#: sequencer.c
msgid "no cherry-pick or revert in progress"
msgstr "拣选或还原操作并未进行"

#: sequencer.c
msgid "cannot resolve HEAD"
msgstr "不能解析 HEAD"

#: sequencer.c
msgid "cannot abort from a branch yet to be born"
msgstr "不能从尚未建立的分支终止"

#: sequencer.c
#, c-format
msgid "cannot read '%s': %s"
msgstr "不能读取 '%s'：%s"

#: sequencer.c
msgid "unexpected end of file"
msgstr "意外的文件结束"

#: sequencer.c
#, c-format
msgid "stored pre-cherry-pick HEAD file '%s' is corrupt"
msgstr "保存拣选提交前的 HEAD 文件 '%s' 损坏"

#: sequencer.c
msgid "You seem to have moved HEAD. Not rewinding, check your HEAD!"
msgstr "您好像移动了 HEAD。未能回退，检查您的 HEAD！"

#: sequencer.c
msgid "no revert in progress"
msgstr "没有正在进行的还原"

#: sequencer.c
msgid "no cherry-pick in progress"
msgstr "没有正在进行的拣选"

#: sequencer.c
msgid "failed to skip the commit"
msgstr "无法跳过这个提交"

#: sequencer.c
msgid "there is nothing to skip"
msgstr "没有要跳过的"

#: sequencer.c
#, c-format
msgid ""
"have you committed already?\n"
"try \"git %s --continue\""
msgstr ""
"您已经提交了么？\n"
"试试 \"git %s --continue\""

#: sequencer.c
msgid "cannot read HEAD"
msgstr "不能读取 HEAD"

#: sequencer.c
msgid "could not write commit message file"
msgstr "无法写入提交说明文件"

#: sequencer.c
#, c-format
msgid ""
"You can amend the commit now, with\n"
"\n"
"  git commit --amend %s\n"
"\n"
"Once you are satisfied with your changes, run\n"
"\n"
"  git rebase --continue\n"
msgstr ""
"您现在可以修补这个提交，使用\n"
"\n"
"  git commit --amend %s\n"
"\n"
"当您对变更感到满意，执行\n"
"\n"
"  git rebase --continue\n"

#: sequencer.c
#, c-format
msgid "Could not apply %s... %.*s"
msgstr "不能应用 %s... %.*s"

#: sequencer.c
#, c-format
msgid "Could not merge %.*s"
msgstr "不能合并 %.*s"

#: sequencer.c
#, c-format
msgid "Executing: %s\n"
msgstr "正在执行：%s\n"

#: sequencer.c
#, c-format
msgid ""
"execution failed: %s\n"
"%sYou can fix the problem, and then run\n"
"\n"
"  git rebase --continue\n"
"\n"
msgstr ""
"执行失败：%s\n"
"%s您可以改正该问题，然后运行\n"
"\n"
"  git rebase --continue\n"
"\n"

#: sequencer.c
msgid "and made changes to the index and/or the working tree.\n"
msgstr "并且修改索引和/或工作区。\n"

#: sequencer.c
#, c-format
msgid ""
"execution succeeded: %s\n"
"but left changes to the index and/or the working tree.\n"
"Commit or stash your changes, and then run\n"
"\n"
"  git rebase --continue\n"
"\n"
msgstr ""
"执行成功：%s\n"
"但是在索引和/或工作区中存在变更。\n"
"提交或贮藏修改，然后运行\n"
"\n"
"  git rebase --continue\n"
"\n"

#: sequencer.c
#, c-format
msgid "illegal label name: '%.*s'"
msgstr "非法的标签名称：'%.*s'"

#: sequencer.c
#, c-format
msgid "could not resolve '%s'"
msgstr "无法解析 '%s'"

#: sequencer.c
msgid "writing fake root commit"
msgstr "写伪根提交"

#: sequencer.c
msgid "writing squash-onto"
msgstr "写入 squash-onto"

#: sequencer.c
msgid "cannot merge without a current revision"
msgstr "没有当前版本不能合并"

#: sequencer.c
#, c-format
msgid "unable to parse '%.*s'"
msgstr "无法解析 '%.*s'"

#: sequencer.c
#, c-format
msgid "nothing to merge: '%.*s'"
msgstr "无可用合并：'%.*s'"

#: sequencer.c
msgid "octopus merge cannot be executed on top of a [new root]"
msgstr "章鱼合并不能在一个新的根提交上执行"

#: sequencer.c
#, c-format
msgid "could not get commit message of '%s'"
msgstr "不能获取 '%s' 的提交说明"

#: sequencer.c
#, c-format
msgid "could not even attempt to merge '%.*s'"
msgstr "甚至不能尝试合并 '%.*s'"

#: sequencer.c
msgid "merge: Unable to write new index file"
msgstr "合并：无法写入新索引文件"

#: sequencer.c
#, c-format
msgid ""
"another 'rebase' process appears to be running; '%s.lock' already exists"
msgstr "另一个 'rebase' 进程似乎在运行；'%s.lock' 已存在"

#: sequencer.c
#, c-format
msgid ""
"Updated the following refs with %s:\n"
"%s"
msgstr ""
"已用 %s 更新下列引用：\n"
"%s"

#: sequencer.c
#, c-format
msgid ""
"Failed to update the following refs with %s:\n"
"%s"
msgstr ""
"无法用 %s 更新下列引用：\n"
"%s"

#: sequencer.c
msgid "Cannot autostash"
msgstr "无法自动贮藏"

#: sequencer.c
#, c-format
msgid "Unexpected stash response: '%s'"
msgstr "意外的贮藏响应：'%s'"

#: sequencer.c
#, c-format
msgid "Could not create directory for '%s'"
msgstr "不能为 '%s' 创建目录"

#: sequencer.c
#, c-format
msgid "Created autostash: %s\n"
msgstr "创建了自动贮藏：%s\n"

#: sequencer.c
msgid "could not reset --hard"
msgstr "无法硬性重置（reset --hard）"

#: sequencer.c
#, c-format
msgid "Applied autostash.\n"
msgstr "已应用自动贮藏。\n"

#: sequencer.c
#, c-format
msgid "cannot store %s"
msgstr "不能存储 %s"

#: sequencer.c
#, c-format
msgid ""
"%s\n"
"Your changes are safe in the stash.\n"
"You can run \"git stash pop\" or \"git stash drop\" at any time.\n"
msgstr ""
"%s\n"
"您的修改在贮藏区中很安全。\n"
"您可以在任何时候运行 \"git stash pop\" 或 \"git stash drop\"。\n"

#: sequencer.c
msgid "Applying autostash resulted in conflicts."
msgstr "应用自动贮藏导致冲突。"

#: sequencer.c
msgid "Autostash exists; creating a new stash entry."
msgstr "自动贮藏已经存在；正在创建一个新的贮藏条目。"

#: sequencer.c
msgid "autostash reference is a symref"
msgstr "自动贮藏的引用是一个符号引用"

#: sequencer.c
msgid "could not detach HEAD"
msgstr "不能分离头指针"

#: sequencer.c
#, c-format
msgid "Stopped at HEAD\n"
msgstr "停止在 HEAD\n"

#: sequencer.c
#, c-format
msgid "Stopped at %s\n"
msgstr "停止在 %s\n"

#: sequencer.c
#, c-format
msgid ""
"Could not execute the todo command\n"
"\n"
"    %.*s\n"
"It has been rescheduled; To edit the command before continuing, please\n"
"edit the todo list first:\n"
"\n"
"    git rebase --edit-todo\n"
"    git rebase --continue\n"
msgstr ""
"无法执行待办命令\n"
"\n"
"    %.*s\n"
"已被重新安排，在继续之前编辑命令，请先编辑待办列表：\n"
"\n"
"    git rebase --edit-todo\n"
"    git rebase --continue\n"

#: sequencer.c
#, c-format
msgid "Stopped at %s...  %.*s\n"
msgstr "停止在 %s... %.*s\n"

#: sequencer.c
#, c-format
msgid "Rebasing (%d/%d)%s"
msgstr "正在变基（%d/%d）%s"

#: sequencer.c
#, c-format
msgid "unknown command %d"
msgstr "未知命令 %d"

#: sequencer.c
msgid "could not read orig-head"
msgstr "不能读取 orig-head"

#: sequencer.c
msgid "could not read 'onto'"
msgstr "不能读取 'onto'"

#: sequencer.c
#, c-format
msgid "could not update HEAD to %s"
msgstr "不能更新 HEAD 为 %s"

#: sequencer.c
#, c-format
msgid "Successfully rebased and updated %s.\n"
msgstr "成功变基并更新 %s。\n"

#: sequencer.c
msgid "cannot rebase: You have unstaged changes."
msgstr "不能变基：您有未暂存的变更。"

#: sequencer.c
msgid "cannot amend non-existing commit"
msgstr "不能修补不存在的提交"

#: sequencer.c
#, c-format
msgid "invalid file: '%s'"
msgstr "无效文件：'%s'"

#: sequencer.c
#, c-format
msgid "invalid contents: '%s'"
msgstr "无效内容：'%s'"

#: sequencer.c
msgid ""
"\n"
"You have uncommitted changes in your working tree. Please, commit them\n"
"first and then run 'git rebase --continue' again."
msgstr ""
"\n"
"您的工作区中有未提交的变更。请先提交然后再次运行 'git rebase --continue'。"

#: sequencer.c
#, c-format
msgid "could not write file: '%s'"
msgstr "不能写入文件：'%s'"

#: sequencer.c
msgid "could not remove CHERRY_PICK_HEAD"
msgstr "不能删除 CHERRY_PICK_HEAD"

#: sequencer.c
msgid "could not commit staged changes."
msgstr "不能提交暂存的修改。"

#: sequencer.c
#, c-format
msgid "%s: can't cherry-pick a %s"
msgstr "%s：不能拣选一个%s"

#: sequencer.c
#, c-format
msgid "%s: bad revision"
msgstr "%s：错误的版本"

#: sequencer.c
msgid "can't revert as initial commit"
msgstr "不能作为初始提交回退"

#: sequencer.c
#, c-format
msgid "skipped previously applied commit %s"
msgstr "跳过了先前已应用的提交 %s"

#: sequencer.c
msgid "use --reapply-cherry-picks to include skipped commits"
msgstr "使用 --reapply-cherry-picks 来包括跳过的提交"

#: sequencer.c
msgid "make_script: unhandled options"
msgstr "make_script：有未能处理的选项"

#: sequencer.c
msgid "make_script: error preparing revisions"
msgstr "make_script：准备版本时错误"

#: sequencer.c
msgid "nothing to do"
msgstr "无事可做"

#: sequencer.c
msgid "could not skip unnecessary pick commands"
msgstr "无法跳过不必要的拣选"

#: sequencer.c
msgid "the script was already rearranged."
msgstr "脚本已经重新编排。"

#: sequencer.c
#, c-format
msgid "update-refs file at '%s' is invalid"
msgstr "位于 '%s' 的 update-refs 文件无效"

#: setup.c
#, c-format
msgid "'%s' is outside repository at '%s'"
msgstr "'%s' 在位于 '%s' 的仓库之外"

#: setup.c
#, c-format
msgid ""
"%s: no such path in the working tree.\n"
"Use 'git <command> -- <path>...' to specify paths that do not exist locally."
msgstr ""
"%s：工作区中无此路径。\n"
"使用命令 'git <命令> -- <路径>...' 来指定本地不存在的路径。"

#: setup.c
#, c-format
msgid ""
"ambiguous argument '%s': unknown revision or path not in the working tree.\n"
"Use '--' to separate paths from revisions, like this:\n"
"'git <command> [<revision>...] -- [<file>...]'"
msgstr ""
"有歧义的参数 '%s'：未知的版本或路径不存在于工作区中。\n"
"使用 '--' 来分隔版本和路径，例如：\n"
"'git <命令> [<版本>...] -- [<文件>...]'"

#: setup.c
#, c-format
msgid "option '%s' must come before non-option arguments"
msgstr "选项 '%s' 必须在其他非选项参数之前"

#: setup.c
#, c-format
msgid ""
"ambiguous argument '%s': both revision and filename\n"
"Use '--' to separate paths from revisions, like this:\n"
"'git <command> [<revision>...] -- [<file>...]'"
msgstr ""
"有歧义的参数 '%s'：可同时是版本和文件\n"
"使用 '--' 来分隔版本和路径，例如：\n"
"'git <命令> [<版本>...] -- [<文件>...]'"

#: setup.c
msgid "unable to set up work tree using invalid config"
msgstr "无法使用无效配置来创建工作区"

#: setup.c
#, c-format
msgid "'%s' already specified as '%s'"
msgstr "'%s' 已指定为 '%s'"

#: setup.c
#, c-format
msgid "Expected git repo version <= %d, found %d"
msgstr "期望 git 仓库版本 <= %d，却得到 %d"

#: setup.c
msgid "unknown repository extension found:"
msgid_plural "unknown repository extensions found:"
msgstr[0] "发现未知的仓库扩展："
msgstr[1] "发现未知的仓库扩展："

#: setup.c
msgid "repo version is 0, but v1-only extension found:"
msgid_plural "repo version is 0, but v1-only extensions found:"
msgstr[0] "仓库的版本是 0，但是发现仅用于 v1 的扩展："
msgstr[1] "仓库的版本是 0，但是发现仅用于 v1 的扩展："

#: setup.c
#, c-format
msgid "error opening '%s'"
msgstr "打开 '%s' 出错"

#: setup.c
#, c-format
msgid "too large to be a .git file: '%s'"
msgstr "文件太大，无法作为 .git 文件：'%s'"

#: setup.c
#, c-format
msgid "error reading %s"
msgstr "读取 %s 出错"

#: setup.c
#, c-format
msgid "invalid gitfile format: %s"
msgstr "无效的 gitfile 格式：%s"

#: setup.c
#, c-format
msgid "no path in gitfile: %s"
msgstr "在 gitfile 中没有路径：%s"

#: setup.c
#, c-format
msgid "not a git repository: %s"
msgstr "不是 git 仓库：%s"

#: setup.c
#, c-format
msgid "'$%s' too big"
msgstr "'$%s' 太大"

#: setup.c
#, c-format
msgid "not a git repository: '%s'"
msgstr "不是 git 仓库：'%s'"

#: setup.c
#, c-format
msgid "cannot chdir to '%s'"
msgstr "不能切换目录到 '%s'"

#: setup.c
msgid "cannot come back to cwd"
msgstr "无法返回当前工作目录"

#: setup.c
#, c-format
msgid "failed to stat '%*s%s%s'"
msgstr "无法获取 '%*s%s%s' 状态（stat）"

#: setup.c
#, c-format
msgid "safe.directory '%s' not absolute"
msgstr "safe.directory '%s' 不是绝对路径"

#: setup.c
#, c-format
msgid ""
"detected dubious ownership in repository at '%s'\n"
"%sTo add an exception for this directory, call:\n"
"\n"
"\tgit config --global --add safe.directory %s"
msgstr ""
"在 '%s' 检测到可疑的仓库所有权\n"
"%s要为本仓库创建特例，请运行：\n"
"\n"
"\tgit config --global --add safe.directory %s"

#: setup.c
msgid "Unable to read current working directory"
msgstr "不能读取当前工作目录"

#: setup.c
#, c-format
msgid "cannot change to '%s'"
msgstr "不能切换到 '%s'"

#: setup.c
#, c-format
msgid "not a git repository (or any of the parent directories): %s"
msgstr "不是 git 仓库（或者任何父目录）：%s"

#: setup.c
#, c-format
msgid ""
"not a git repository (or any parent up to mount point %s)\n"
"Stopping at filesystem boundary (GIT_DISCOVERY_ACROSS_FILESYSTEM not set)."
msgstr ""
"不是 git 仓库（或者直至挂载点 %s 的任何父目录）\n"
"停止在文件系统边界（未设置 GIT_DISCOVERY_ACROSS_FILESYSTEM）。"

#: setup.c
#, c-format
msgid "cannot use bare repository '%s' (safe.bareRepository is '%s')"
msgstr "无法使用纯仓库 '%s' （safe.bareRepository 为 '%s'）"

#: setup.c
#, c-format
msgid ""
"problem with core.sharedRepository filemode value (0%.3o).\n"
"The owner of files must always have read and write permissions."
msgstr ""
"参数 core.sharedRepository 的文件属性值有问题（0%.3o）。\n"
"文件属主必须始终拥有读写权限。"

#: setup.c
msgid "fork failed"
msgstr "fork 失败"

#: setup.c
msgid "setsid failed"
msgstr "setsid 失败"

#: setup.c
#, c-format
msgid "cannot stat template '%s'"
msgstr "不能对模版 '%s' 调用 stat"

#: setup.c
#, c-format
msgid "cannot opendir '%s'"
msgstr "不能打开目录 '%s'"

#: setup.c
#, c-format
msgid "cannot readlink '%s'"
msgstr "不能读取链接 '%s'"

#: setup.c
#, c-format
msgid "cannot symlink '%s' '%s'"
msgstr "不能自 '%s' 到 '%s' 创建符号链接"

#: setup.c
#, c-format
msgid "cannot copy '%s' to '%s'"
msgstr "不能拷贝 '%s' 至 '%s'"

#: setup.c
#, c-format
msgid "ignoring template %s"
msgstr "忽略模版 %s"

#: setup.c
#, c-format
msgid "templates not found in %s"
msgstr "没有在 %s 中找到模版"

#: setup.c
#, c-format
msgid "not copying templates from '%s': %s"
msgstr "没有从 '%s' 复制模版：%s"

#: setup.c
#, c-format
msgid "invalid initial branch name: '%s'"
msgstr "无效的初始分支名：'%s'"

#: setup.c
#, c-format
msgid "re-init: ignored --initial-branch=%s"
msgstr "re-init：已忽略 --initial-branch=%s"

#: setup.c
#, c-format
msgid "unable to handle file type %d"
msgstr "不能处理 %d 类型的文件"

#: setup.c
#, c-format
msgid "unable to move %s to %s"
msgstr "不能移动 %s 至 %s"

#: setup.c
msgid "attempt to reinitialize repository with different hash"
msgstr "尝试用不同的哈希算法重新初始化仓库"

#: setup.c
msgid ""
"attempt to reinitialize repository with different reference storage format"
msgstr "尝试使用不同的引用存储格式重新初始化仓库"

#: setup.c
#, c-format
msgid "%s already exists"
msgstr "%s 已经存在"

#: setup.c
#, c-format
msgid "Reinitialized existing shared Git repository in %s%s\n"
msgstr "重新初始化已存在的共享 Git 仓库于 %s%s\n"

#: setup.c
#, c-format
msgid "Reinitialized existing Git repository in %s%s\n"
msgstr "已重新初始化已存在的 Git 仓库于 %s%s\n"

#: setup.c
#, c-format
msgid "Initialized empty shared Git repository in %s%s\n"
msgstr "已初始化空的共享 Git 仓库于 %s%s\n"

#: setup.c
#, c-format
msgid "Initialized empty Git repository in %s%s\n"
msgstr "已初始化空的 Git 仓库于 %s%s\n"

#: sparse-index.c
#, c-format
msgid "index entry is a directory, but not sparse (%08x)"
msgstr "索引条目是一个目录，但不是稀疏的 (%08x)"

#: split-index.c
msgid "cannot use split index with a sparse index"
msgstr "拆分索引无法与稀疏索引一起使用"

#. TRANSLATORS: The first %s is a command like "ls-tree".
#: strbuf.c
#, c-format
msgid "bad %s format: element '%s' does not start with '('"
msgstr "坏的 %s 格式：元素 '%s' 没有以 '(' 开头"

#. TRANSLATORS: The first %s is a command like "ls-tree".
#: strbuf.c
#, c-format
msgid "bad %s format: element '%s' does not end in ')'"
msgstr "坏的 %s 格式：元素 '%s' 没有以 ')' 结尾"

#. TRANSLATORS: %s is a command like "ls-tree".
#: strbuf.c
#, c-format
msgid "bad %s format: %%%.*s"
msgstr "坏的 %s 格式: %%%.*s"

#. TRANSLATORS: IEC 80000-13:2008 gibibyte
#: strbuf.c
#, c-format
msgid "%u.%2.2u GiB"
msgstr "%u.%2.2u GiB"

#. TRANSLATORS: IEC 80000-13:2008 gibibyte/second
#: strbuf.c
#, c-format
msgid "%u.%2.2u GiB/s"
msgstr "%u.%2.2u GiB/s"

#. TRANSLATORS: IEC 80000-13:2008 mebibyte
#: strbuf.c
#, c-format
msgid "%u.%2.2u MiB"
msgstr "%u.%2.2u MiB"

#. TRANSLATORS: IEC 80000-13:2008 mebibyte/second
#: strbuf.c
#, c-format
msgid "%u.%2.2u MiB/s"
msgstr "%u.%2.2u MiB/s"

#. TRANSLATORS: IEC 80000-13:2008 kibibyte
#: strbuf.c
#, c-format
msgid "%u.%2.2u KiB"
msgstr "%u.%2.2u KiB"

#. TRANSLATORS: IEC 80000-13:2008 kibibyte/second
#: strbuf.c
#, c-format
msgid "%u.%2.2u KiB/s"
msgstr "%u.%2.2u KiB/s"

#. TRANSLATORS: IEC 80000-13:2008 byte
#: strbuf.c
#, c-format
msgid "%u byte"
msgid_plural "%u bytes"
msgstr[0] "%u 字节"
msgstr[1] "%u 字节"

#. TRANSLATORS: IEC 80000-13:2008 byte/second
#: strbuf.c
#, c-format
msgid "%u byte/s"
msgid_plural "%u bytes/s"
msgstr[0] "%u 字节/秒"
msgstr[1] "%u 字节/秒"

#: submodule-config.c
#, c-format
msgid "ignoring suspicious submodule name: %s"
msgstr "忽略可疑的子模组名称：%s"

#: submodule-config.c
msgid "negative values not allowed for submodule.fetchJobs"
msgstr "submodule.fetchJobs 不允许为负值"

#: submodule-config.c
#, c-format
msgid "ignoring '%s' which may be interpreted as a command-line option: %s"
msgstr "忽略可能被解析为命令行选项的 '%s'：%s"

#: submodule-config.c
#, c-format
msgid "Could not update .gitmodules entry %s"
msgstr "不能更新 .gitmodules 条目 %s"

#: submodule.c
msgid "Cannot change unmerged .gitmodules, resolve merge conflicts first"
msgstr "无法修改未合并的 .gitmodules，先解决合并冲突"

#: submodule.c
#, c-format
msgid "Could not find section in .gitmodules where path=%s"
msgstr "无法在 .gitmodules 中找到 path=%s 的小节"

#: submodule.c
#, c-format
msgid "Could not remove .gitmodules entry for %s"
msgstr "无法移除 %s 的 .gitmodules 条目"

#: submodule.c
msgid "staging updated .gitmodules failed"
msgstr "将更新后 .gitmodules 添加暂存区失败"

#: submodule.c
#, c-format
msgid "in unpopulated submodule '%s'"
msgstr "位于未检出的子模组 '%s'"

#: submodule.c
#, c-format
msgid "Pathspec '%s' is in submodule '%.*s'"
msgstr "路径规格 '%s' 在子模组 '%.*s' 中"

#: submodule.c
#, c-format
msgid "bad --ignore-submodules argument: %s"
msgstr "坏的 --ignore-submodules 参数：%s"

#: submodule.c
#, c-format
msgid ""
"Submodule in commit %s at path: '%s' collides with a submodule named the "
"same. Skipping it."
msgstr "提交 %s 中位于路径 '%s' 的子模组和同名的子模组冲突。 跳过它。"

#: submodule.c
#, c-format
msgid "submodule entry '%s' (%s) is a %s, not a commit"
msgstr "子模组条目 '%s'（%s）是一个 %s，不是一个提交"

#: submodule.c
#, c-format
msgid ""
"Could not run 'git rev-list <commits> --not --remotes -n 1' command in "
"submodule %s"
msgstr "无法在子模组 %s 中执行 'git rev-list <提交> --not --remotes -n 1'"

#: submodule.c
#, c-format
msgid "process for submodule '%s' failed"
msgstr "处理子模组 '%s' 失败"

#: submodule.c
#, c-format
msgid "Pushing submodule '%s'\n"
msgstr "正在推送子模组 '%s'\n"

#: submodule.c
#, c-format
msgid "Unable to push submodule '%s'\n"
msgstr "无法推送子模组 '%s'\n"

#: submodule.c
#, c-format
msgid "Fetching submodule %s%s\n"
msgstr "正在获取子模组 %s%s\n"

#: submodule.c
#, c-format
msgid "Could not access submodule '%s'\n"
msgstr "无法访问子模组 '%s'\n"

#: submodule.c
#, c-format
msgid "Could not access submodule '%s' at commit %s\n"
msgstr "无法访问子模组 '%s' 提交 %s\n"

#: submodule.c
#, c-format
msgid "Fetching submodule %s%s at commit %s\n"
msgstr "正在获取子模组 %s%s 提交 %s\n"

#: submodule.c
#, c-format
msgid ""
"Errors during submodule fetch:\n"
"%s"
msgstr ""
"获取子模组时的错误：\n"
"%s"

#: submodule.c
#, c-format
msgid "'%s' not recognized as a git repository"
msgstr "无法将 '%s' 识别为 git 仓库"

#: submodule.c
#, c-format
msgid "Could not run 'git status --porcelain=2' in submodule %s"
msgstr "无法在子模组 %s 中执行 'git status --porcelain=2'"

#: submodule.c
#, c-format
msgid "'git status --porcelain=2' failed in submodule %s"
msgstr "在子模组 %s 中执行 'git status --porcelain=2' 失败"

#: submodule.c
#, c-format
msgid "could not start 'git status' in submodule '%s'"
msgstr "无法在子模组 '%s' 中启动 'git status'"

#: submodule.c
#, c-format
msgid "could not run 'git status' in submodule '%s'"
msgstr "无法在子模组 '%s' 中执行 'git status'"

#: submodule.c
#, c-format
msgid "Could not unset core.worktree setting in submodule '%s'"
msgstr "无法在子模组 '%s' 中取消 core.worktree 的设置"

#: submodule.c
#, c-format
msgid "could not recurse into submodule '%s'"
msgstr "无法递归进子模组路径 '%s'"

#: submodule.c
msgid "could not reset submodule index"
msgstr "无法重置子模组索引"

#: submodule.c
#, c-format
msgid "submodule '%s' has dirty index"
msgstr "子模组 '%s' 中有脏索引"

#: submodule.c
#, c-format
msgid "Submodule '%s' could not be updated."
msgstr "子模组 '%s' 无法被更新。"

#: submodule.c
#, c-format
msgid "submodule git dir '%s' is inside git dir '%.*s'"
msgstr "子模组 git 目录 '%s' 位于 git 目录 '%.*s' 中"

#: submodule.c
#, c-format
msgid "expected '%.*s' in submodule path '%s' not to be a symbolic link"
msgstr "期望子模组的父目录 '%.*s' 不是一个符号链接，子模组路径为 '%s'"

#: submodule.c
#, c-format
msgid "expected submodule path '%s' not to be a symbolic link"
msgstr "预期子模组路径 '%s' 不是符号链接"

#: submodule.c
#, c-format
msgid ""
"relocate_gitdir for submodule '%s' with more than one worktree not supported"
msgstr "不支持对有多个工作区的子模组 '%s' 执行 relocate_gitdir"

#: submodule.c
#, c-format
msgid "could not lookup name for submodule '%s'"
msgstr "不能查询子模组 '%s' 的名称"

#: submodule.c
#, c-format
msgid "refusing to move '%s' into an existing git dir"
msgstr "禁止移动 '%s' 到现存 git 目录中"

#: submodule.c
#, c-format
msgid ""
"Migrating git directory of '%s%s' from\n"
"'%s' to\n"
"'%s'\n"
msgstr ""
"将 '%s%s' 的 git 目录从\n"
"'%s' 迁移至\n"
"'%s'\n"

#: submodule.c
msgid "could not start ls-files in .."
msgstr "无法在 .. 中启动 ls-files"

#: submodule.c
#, c-format
msgid "ls-tree returned unexpected return code %d"
msgstr "ls-tree 返回未知返回值 %d"

#: symlinks.c
#, c-format
msgid "failed to lstat '%s'"
msgstr "无法执行 lstat '%s'"

#: t/helper/test-bundle-uri.c
msgid "no remote configured to get bundle URIs from"
msgstr "没有远程被设置为可以获取归档包 URI"

#: t/helper/test-bundle-uri.c
msgid "could not get the bundle-uri list"
msgstr "无法获取 bundle-uri 列表"

#: t/helper/test-cache-tree.c
msgid "test-tool cache-tree <options> (control|prime|update)"
msgstr "test-tool cache-tree <选项> (control|prime|update)"

#: t/helper/test-cache-tree.c
msgid "clear the cache tree before each iteration"
msgstr "在每次迭代前清除缓存树"

#: t/helper/test-cache-tree.c
msgid "number of entries in the cache tree to invalidate (default 0)"
msgstr "缓存树中无效化的条目数量（默认 0）"

#: t/helper/test-path-walk.c
msgid "test-tool path-walk <options> -- <revision-options>"
msgstr "test-tool path-walk <选项> -- <版本选项>"

#: t/helper/test-path-walk.c
msgid "toggle inclusion of blob objects"
msgstr "切换是否包含数据对象"

#: t/helper/test-path-walk.c
msgid "toggle inclusion of commit objects"
msgstr "切换是否包含提交对象"

#: t/helper/test-path-walk.c
msgid "toggle inclusion of tag objects"
msgstr "切换是否包含标签对象"

#: t/helper/test-path-walk.c
msgid "toggle inclusion of tree objects"
msgstr "切换是否包含树对象"

#: t/helper/test-path-walk.c
msgid "toggle pruning of uninteresting paths"
msgstr "切换对无趣路径的修剪"

#: t/helper/test-path-walk.c
msgid "read a pattern list over stdin"
msgstr "从标准输入读取模式列表"

#: t/helper/test-reach.c
#, c-format
msgid "commit %s is not marked reachable"
msgstr "提交 %s 没有标记为可达"

#: t/helper/test-reach.c
msgid "too many commits marked reachable"
msgstr "太多提交标记为可达"

#: t/helper/test-read-midx.c
msgid "could not determine MIDX preferred pack"
msgstr "不能确定多包索引的首选包"

#: t/helper/test-serve-v2.c
msgid "test-tool serve-v2 [<options>]"
msgstr "test-tool serve-v2 [<选项>]"

#: t/helper/test-serve-v2.c
msgid "exit immediately after advertising capabilities"
msgstr "通告能力之后立即退出"

#: t/helper/test-simple-ipc.c
msgid "test-helper simple-ipc is-active    [<name>] [<options>]"
msgstr "test-helper simple-ipc is-active    [<名字>] [<选项>]"

#: t/helper/test-simple-ipc.c
msgid "test-helper simple-ipc run-daemon   [<name>] [<threads>]"
msgstr "test-helper simple-ipc run-daemon   [<名字>] [<线程>]"

#: t/helper/test-simple-ipc.c
msgid "test-helper simple-ipc start-daemon [<name>] [<threads>] [<max-wait>]"
msgstr "test-helper simple-ipc start-daemon [<名字>] [<线程>] [<最大等待>]"

#: t/helper/test-simple-ipc.c
msgid "test-helper simple-ipc stop-daemon  [<name>] [<max-wait>]"
msgstr "test-helper simple-ipc stop-daemon  [<名字>] [<最大等待>]"

#: t/helper/test-simple-ipc.c
msgid "test-helper simple-ipc send         [<name>] [<token>]"
msgstr "test-helper simple-ipc send         [<名字>] [<令牌>]"

#: t/helper/test-simple-ipc.c
msgid "test-helper simple-ipc sendbytes    [<name>] [<bytecount>] [<byte>]"
msgstr "test-helper simple-ipc sendbytes    [<名字>] [<字节数>] [<字节>]"

#: t/helper/test-simple-ipc.c
msgid ""
"test-helper simple-ipc multiple     [<name>] [<threads>] [<bytecount>] "
"[<batchsize>]"
msgstr ""
"test-helper simple-ipc multiple     [<名字>] [<线程>] [<字节计数>] [<批处理大"
"小>]"

#: t/helper/test-simple-ipc.c
msgid "name or pathname of unix domain socket"
msgstr "unix 域套接字的名称或路径名"

#: t/helper/test-simple-ipc.c
msgid "named-pipe name"
msgstr "命名管道的名字"

#: t/helper/test-simple-ipc.c
msgid "number of threads in server thread pool"
msgstr "服务器线程池中的线程数"

#: t/helper/test-simple-ipc.c
msgid "seconds to wait for daemon to start or stop"
msgstr "等待守护进程启动或停止的秒数"

#: t/helper/test-simple-ipc.c
msgid "number of bytes"
msgstr "字节数目"

#: t/helper/test-simple-ipc.c
msgid "number of requests per thread"
msgstr "每个线程的请求数"

#: t/helper/test-simple-ipc.c
msgid "byte"
msgstr "字节"

#: t/helper/test-simple-ipc.c
msgid "ballast character"
msgstr "ballast character"

#: t/helper/test-simple-ipc.c
msgid "token"
msgstr "令牌"

#: t/helper/test-simple-ipc.c
msgid "command token to send to the server"
msgstr "发送到服务器的命令令牌"

#: t/unit-tests/unit-test.c
msgid "unit-test [<options>]"
msgstr "unit-test [<选项>]"

#: t/unit-tests/unit-test.c
msgid "immediately exit upon the first failed test"
msgstr "第一次测试失败后立即退出"

#: t/unit-tests/unit-test.c
msgid "suite[::test]"
msgstr "suite[::测试用例]"

#: t/unit-tests/unit-test.c
msgid "run only test suite or individual test <suite[::test]>"
msgstr "只运行测试套件或单独的测试 <测试套件[::测试用例]>"

#: t/unit-tests/unit-test.c
msgid "suite"
msgstr "测试套件"

#: t/unit-tests/unit-test.c
msgid "exclude test suite <suite>"
msgstr "排除测试套件 <测试套件>"

#: trailer.c
#, c-format
msgid "running trailer command '%s' failed"
msgstr "执行 trailer 命令 '%s' 失败"

#: trailer.c
#, c-format
msgid "unknown value '%s' for key '%s'"
msgstr "键 '%2$s' 的未知取值 '%1$s'"

#: trailer.c
#, c-format
msgid "empty trailer token in trailer '%.*s'"
msgstr "尾注 '%.*s' 的键为空"

#: transport-helper.c
msgid "full write to remote helper failed"
msgstr "完整写入远程助手失败"

#: transport-helper.c
#, c-format
msgid "unable to find remote helper for '%s'"
msgstr "无法为 '%s' 找到远程助手"

#: transport-helper.c
msgid "can't dup helper output fd"
msgstr "无法复制助手输出文件句柄"

#: transport-helper.c
#, c-format
msgid ""
"unknown mandatory capability %s; this remote helper probably needs newer "
"version of Git"
msgstr "未知的强制能力 %s，该远程助手可能需要新版本的Git"

#: transport-helper.c
msgid "this remote helper should implement refspec capability"
msgstr "远程助手需要实现 refspec 能力"

#: transport-helper.c
#, c-format
msgid "%s unexpectedly said: '%s'"
msgstr "%s 意外地说：'%s'"

#: transport-helper.c
#, c-format
msgid "%s also locked %s"
msgstr "%s 也锁定了 %s"

#: transport-helper.c
msgid "couldn't run fast-import"
msgstr "不能执行 fast-import"

#: transport-helper.c
msgid "error while running fast-import"
msgstr "执行 fast-import 出错"

#: transport-helper.c
#, c-format
msgid "could not read ref %s"
msgstr "无法读取引用 %s"

#: transport-helper.c
#, c-format
msgid "unknown response to connect: %s"
msgstr "连接时未知的响应：%s"

#: transport-helper.c
msgid "setting remote service path not supported by protocol"
msgstr "协议不支持设置远程服务路径"

#: transport-helper.c
msgid "invalid remote service path"
msgstr "无效的远程服务路径"

#: transport-helper.c
#, c-format
msgid "can't connect to subservice %s"
msgstr "不能连接到子服务 %s"

#: transport-helper.c transport.c
msgid "--negotiate-only requires protocol v2"
msgstr "--negotiate-only 需要协议 v2"

#: transport-helper.c
msgid "'option' without a matching 'ok/error' directive"
msgstr "'option' 缺乏一个匹配的 'ok/error' 指令"

#: transport-helper.c
#, c-format
msgid "expected ok/error, helper said '%s'"
msgstr "预期 ok/error，助手说 '%s'"

#: transport-helper.c
#, c-format
msgid "helper reported unexpected status of %s"
msgstr "助手报告 %s 的意外状态"

#: transport-helper.c
#, c-format
msgid "helper %s does not support dry-run"
msgstr "助手 %s 不支持 dry-run"

#: transport-helper.c
#, c-format
msgid "helper %s does not support --signed"
msgstr "助手 %s 不支持 --signed"

#: transport-helper.c
#, c-format
msgid "helper %s does not support --signed=if-asked"
msgstr "助手 %s 不支持 --signed=if-asked"

#: transport-helper.c
#, c-format
msgid "helper %s does not support --atomic"
msgstr "助手 %s 不支持 --atomic"

#: transport-helper.c
#, c-format
msgid "helper %s does not support --%s"
msgstr "助手 %s 不支持 --%s"

#: transport-helper.c
#, c-format
msgid "helper %s does not support 'push-option'"
msgstr "助手 %s 不支持 'push-option'"

#: transport-helper.c
msgid "remote-helper doesn't support push; refspec needed"
msgstr "remote-heper 不支持推送，需要引用规格"

#: transport-helper.c
#, c-format
msgid "helper %s does not support '--force'"
msgstr "助手 %s 不支持 '--force'"

#: transport-helper.c
msgid "couldn't run fast-export"
msgstr "无法执行 fast-export"

#: transport-helper.c
msgid "error while running fast-export"
msgstr "执行 fast-export 时出错"

#: transport-helper.c
#, c-format
msgid ""
"No refs in common and none specified; doing nothing.\n"
"Perhaps you should specify a branch.\n"
msgstr ""
"没有共同的引用并且也没有指定，什么也不会做。\n"
"也许您应该指定一个分支。\n"

#: transport-helper.c
#, c-format
msgid "unsupported object format '%s'"
msgstr "不支持的对象格式 '%s'"

#: transport-helper.c
#, c-format
msgid "malformed response in ref list: %s"
msgstr "引用列表中格式错误的响应：%s"

#: transport-helper.c
#, c-format
msgid "read(%s) failed"
msgstr "读取（%s）失败"

#: transport-helper.c
#, c-format
msgid "write(%s) failed"
msgstr "写（%s）失败"

#: transport-helper.c
#, c-format
msgid "%s thread failed"
msgstr "%s 线程失败"

#: transport-helper.c
#, c-format
msgid "%s thread failed to join: %s"
msgstr "%s 线程等待失败：%s"

#: transport-helper.c
#, c-format
msgid "can't start thread for copying data: %s"
msgstr "不能启动线程来拷贝数据：%s"

#: transport-helper.c
#, c-format
msgid "%s process failed to wait"
msgstr "%s 进程等待失败"

#: transport-helper.c
#, c-format
msgid "%s process failed"
msgstr "%s 进程失败"

#: transport-helper.c
msgid "can't start thread for copying data"
msgstr "不能启动线程来拷贝数据"

#: transport.c
#, c-format
msgid "Would set upstream of '%s' to '%s' of '%s'\n"
msgstr "将要设置 '%1$s' 的上游为 '%3$s' 的 '%2$s'\n"

#: transport.c
#, c-format
msgid "could not read bundle '%s'"
msgstr "无法读取归档包 '%s'"

#: transport.c
#, c-format
msgid "transport: invalid depth option '%s'"
msgstr "传输：无效的深度选项 '%s'"

#: transport.c
msgid "see protocol.version in 'git help config' for more details"
msgstr "查看 'git help config' 中的 protocol.version 获取更多信息"

#: transport.c
msgid "server options require protocol version 2 or later"
msgstr "服务端选项需要版本 2 协议或更高"

#: transport.c
msgid "server does not support wait-for-done"
msgstr "服务器不支持 wait-for-done"

#: transport.c
msgid "could not parse transport.color.* config"
msgstr "不能解析 transport.color.* 配置"

#: transport.c
msgid "support for protocol v2 not implemented yet"
msgstr "协议 v2 的支持尚未实现"

#: transport.c
#, c-format
msgid "transport '%s' not allowed"
msgstr "传输 '%s' 不允许"

#: transport.c
msgid "git-over-rsync is no longer supported"
msgstr "不再支持 git-over-rsync"

#: transport.c
#, c-format
msgid ""
"The following submodule paths contain changes that can\n"
"not be found on any remote:\n"
msgstr "下列子模组路径所包含的修改在任何远程源中都找不到：\n"

#: transport.c
#, c-format
msgid ""
"\n"
"Please try\n"
"\n"
"\tgit push --recurse-submodules=on-demand\n"
"\n"
"or cd to the path and use\n"
"\n"
"\tgit push\n"
"\n"
"to push them to a remote.\n"
"\n"
msgstr ""
"\n"
"请尝试\n"
"\n"
"\tgit push --recurse-submodules=on-demand\n"
"\n"
"或者进入到子目录执行\n"
"\n"
"\tgit push\n"
"\n"
"以推送至远程。\n"
"\n"

#: transport.c
msgid "Aborting."
msgstr "正在终止。"

#: transport.c
msgid "failed to push all needed submodules"
msgstr "不能推送全部需要的子模组"

#: transport.c
msgid "bundle-uri operation not supported by protocol"
msgstr "协议不支持 bundle-uri 操作"

#: transport.c
msgid "could not retrieve server-advertised bundle-uri list"
msgstr "无法获取服务器公布的 bundle-uri 列表"

#: transport.c
msgid "operation not supported by protocol"
msgstr "协议不支持该操作"

#: tree-walk.c
msgid "too-short tree object"
msgstr "太短的树对象"

#: tree-walk.c
msgid "malformed mode in tree entry"
msgstr "树对象中的条目模式错误"

#: tree-walk.c
msgid "empty filename in tree entry"
msgstr "树对象条目中空的文件名"

#: tree-walk.c
msgid "too-short tree file"
msgstr "太短的树文件"

#: unpack-trees.c
#, c-format
msgid ""
"Your local changes to the following files would be overwritten by checkout:\n"
"%%sPlease commit your changes or stash them before you switch branches."
msgstr ""
"您对下列文件的本地修改将被检出操作覆盖：\n"
"%%s请在切换分支前提交或贮藏您的修改。"

#: unpack-trees.c
#, c-format
msgid ""
"Your local changes to the following files would be overwritten by checkout:\n"
"%%s"
msgstr ""
"您对下列文件的本地修改将被检出操作覆盖：\n"
"%%s"

#: unpack-trees.c
#, c-format
msgid ""
"Your local changes to the following files would be overwritten by merge:\n"
"%%sPlease commit your changes or stash them before you merge."
msgstr ""
"您对下列文件的本地修改将被合并操作覆盖：\n"
"%%s请在合并前提交或贮藏您的修改。"

#: unpack-trees.c
#, c-format
msgid ""
"Your local changes to the following files would be overwritten by merge:\n"
"%%s"
msgstr ""
"您对下列文件的本地修改将被合并操作覆盖：\n"
"%%s"

#: unpack-trees.c
#, c-format
msgid ""
"Your local changes to the following files would be overwritten by %s:\n"
"%%sPlease commit your changes or stash them before you %s."
msgstr ""
"您对下列文件的本地修改将被 %s 覆盖：\n"
"%%s请在 %s 之前提交或贮藏您的修改。"

#: unpack-trees.c
#, c-format
msgid ""
"Your local changes to the following files would be overwritten by %s:\n"
"%%s"
msgstr ""
"您对下列文件的本地修改将被 %s 覆盖：\n"
"%%s"

#: unpack-trees.c
#, c-format
msgid ""
"Updating the following directories would lose untracked files in them:\n"
"%s"
msgstr ""
"更新如下目录将会丢失其中未跟踪的文件：\n"
"%s"

#: unpack-trees.c
#, c-format
msgid ""
"Refusing to remove the current working directory:\n"
"%s"
msgstr ""
"拒绝删除当前工作目录：\n"
"%s"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be removed by checkout:\n"
"%%sPlease move or remove them before you switch branches."
msgstr ""
"工作区中下列未跟踪的文件将会因为检出操作而被删除：\n"
"%%s请在切换分支之前移动或删除。"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be removed by checkout:\n"
"%%s"
msgstr ""
"工作区中下列未跟踪的文件将会因为检出操作而被删除：\n"
"%%s"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be removed by merge:\n"
"%%sPlease move or remove them before you merge."
msgstr ""
"工作区中下列未跟踪的文件将会因为合并操作而被删除：\n"
"%%s请在合并前移动或删除。"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be removed by merge:\n"
"%%s"
msgstr ""
"工作区中下列未跟踪的文件将会因为合并操作而被删除：\n"
"%%s"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be removed by %s:\n"
"%%sPlease move or remove them before you %s."
msgstr ""
"工作区中下列未跟踪的文件将会因为 %s 操作而被删除：\n"
"%%s请在 %s 前移动或删除。"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be removed by %s:\n"
"%%s"
msgstr ""
"工作区中下列未跟踪的文件将会因为 %s 操作而被删除：\n"
"%%s"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be overwritten by "
"checkout:\n"
"%%sPlease move or remove them before you switch branches."
msgstr ""
"工作区中下列未跟踪的文件将会因为检出操作而被覆盖：\n"
"%%s请在切换分支前移动或删除。"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be overwritten by "
"checkout:\n"
"%%s"
msgstr ""
"工作区中下列未跟踪的文件将会因为检出操作而被覆盖：\n"
"%%s"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be overwritten by merge:\n"
"%%sPlease move or remove them before you merge."
msgstr ""
"工作区中下列未跟踪的文件将会因为合并操作而被覆盖：\n"
"%%s请在合并前移动或删除。"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be overwritten by merge:\n"
"%%s"
msgstr ""
"工作区中下列未跟踪的文件将会因为合并操作而被覆盖：\n"
"%%s"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be overwritten by %s:\n"
"%%sPlease move or remove them before you %s."
msgstr ""
"工作区中下列未跟踪的文件将会因为 %s 操作而被覆盖：\n"
"%%s请在 %s 前移动或删除。"

#: unpack-trees.c
#, c-format
msgid ""
"The following untracked working tree files would be overwritten by %s:\n"
"%%s"
msgstr ""
"工作区中下列未跟踪的文件将会因为 %s 操作而被覆盖：\n"
"%%s"

#: unpack-trees.c
#, c-format
msgid "Entry '%s' overlaps with '%s'.  Cannot bind."
msgstr "条目 '%s' 和 '%s' 重叠。无法合并。"

#: unpack-trees.c
#, c-format
msgid ""
"Cannot update submodule:\n"
"%s"
msgstr ""
"无法更新子模组：\n"
"%s"

#: unpack-trees.c
#, c-format
msgid ""
"The following paths are not up to date and were left despite sparse "
"patterns:\n"
"%s"
msgstr ""
"尽管存在稀疏检出模板，以下路径不是最新，因而保留：\n"
"%s"

#: unpack-trees.c
#, c-format
msgid ""
"The following paths are unmerged and were left despite sparse patterns:\n"
"%s"
msgstr ""
"尽管存在稀疏检出模板，以下路径处于未合并状态，因而保留：\n"
"%s"

#: unpack-trees.c
#, c-format
msgid ""
"The following paths were already present and thus not updated despite sparse "
"patterns:\n"
"%s"
msgstr ""
"尽管存在稀疏检出模板，以下路径已经存在，因而未更新：\n"
"%s"

#: unpack-trees.c
#, c-format
msgid "Aborting\n"
msgstr "正在终止\n"

#: unpack-trees.c
#, c-format
msgid ""
"After fixing the above paths, you may want to run `git sparse-checkout "
"reapply`.\n"
msgstr "在修复上述路径之后，您可能要执行 `git sparse-checkout reapply`。\n"

#: unpack-trees.c
msgid "Updating files"
msgstr "正在更新文件"

#: unpack-trees.c
msgid ""
"the following paths have collided (e.g. case-sensitive paths\n"
"on a case-insensitive filesystem) and only one from the same\n"
"colliding group is in the working tree:\n"
msgstr ""
"以下路径发生碰撞（如：在不区分大小写的文件系统上的区分大小写的路径），\n"
"并且碰撞组中只有一个文件存在工作区中：\n"

#: unpack-trees.c
msgid "Updating index flags"
msgstr "正在更新索引标志"

#: unpack-trees.c
#, c-format
msgid "worktree and untracked commit have duplicate entries: %s"
msgstr "工作树和未跟踪提交具有重复条目：%s"

#: upload-pack.c
msgid "expected flush after fetch arguments"
msgstr "在 fetch 参数之后应该有一个 flush 包"

#: urlmatch.c
msgid "invalid URL scheme name or missing '://' suffix"
msgstr "无效的 URL 方案名称或丢失 '://' 后缀"

#: urlmatch.c
#, c-format
msgid "invalid %XX escape sequence"
msgstr "无效的 %XX 转义序列"

#: urlmatch.c
msgid "missing host and scheme is not 'file:'"
msgstr "缺失主机名且 URL 方案不是 'file:'"

#: urlmatch.c
msgid "a 'file:' URL may not have a port number"
msgstr "一个 'file:' URL 不应该包含端口号"

#: urlmatch.c
msgid "invalid characters in host name"
msgstr "主机名中包含无效的字符"

#: urlmatch.c
msgid "invalid port number"
msgstr "无效的端口号"

#: urlmatch.c
msgid "invalid '..' path segment"
msgstr "无效的 '..' 路径片段"

#: usage.c
#, c-format
msgid "error: unable to format message: %s\n"
msgstr "错误：无法格式化消息：%s\n"

#: usage.c
msgid "usage: "
msgstr "用法："

#: usage.c
msgid "fatal: "
msgstr "致命错误："

#: usage.c
msgid "error: "
msgstr "错误："

#: usage.c
msgid "warning: "
msgstr "警告："

#: version.c
#, c-format
msgid "uname() failed with error '%s' (%d)\n"
msgstr "uname() 失败，错误为 '%s'（%d）\n"

#: walker.c
msgid "Fetching objects"
msgstr "正在获取对象"

#: worktree.c
#, c-format
msgid "'%s' at main working tree is not the repository directory"
msgstr "在主工作区的 '%s' 不是仓库目录"

#: worktree.c
#, c-format
msgid "'%s' file does not contain absolute path to the working tree location"
msgstr "文件 '%s' 不包含工作区的绝对路径"

#: worktree.c
#, c-format
msgid "'%s' is not a .git file, error code %d"
msgstr "'%s' 不是一个 .git 文件，错误码 %d"

#: worktree.c
#, c-format
msgid "'%s' does not point back to '%s'"
msgstr "'%s' 没有指回到 '%s'"

#: worktree.c
msgid "not a directory"
msgstr "不是一个目录"

#: worktree.c
msgid ".git is not a file"
msgstr ".git 不是一个文件"

#: worktree.c
msgid ".git file broken"
msgstr ".git 文件损坏"

#: worktree.c
msgid ".git file incorrect"
msgstr ".git 文件不正确"

#: worktree.c
msgid ".git file absolute/relative path mismatch"
msgstr ".git 文件绝对/相对路径不匹配"

#: worktree.c
msgid "not a valid path"
msgstr "不是一个有效的路径"

#: worktree.c
msgid "unable to locate repository; .git is not a file"
msgstr "无法定位仓库，.git 不是一个文件"

#: worktree.c
msgid "unable to locate repository; .git file does not reference a repository"
msgstr "无法定位仓库，.git 文件没有指向一个仓库"

#: worktree.c
msgid "unable to locate repository; .git file broken"
msgstr "无法定位仓库，.git 文件损坏"

#: worktree.c
msgid "gitdir unreadable"
msgstr "gitdir 不可读"

#: worktree.c
msgid "gitdir absolute/relative path mismatch"
msgstr "gitdir 绝对/相对路径不匹配"

#: worktree.c
msgid "gitdir incorrect"
msgstr "gitdir 不正确"

#: worktree.c
msgid "not a valid directory"
msgstr "不是一个有效的目录"

#: worktree.c
msgid "gitdir file does not exist"
msgstr "gitdir 文件不存在"

#: worktree.c
#, c-format
msgid "unable to read gitdir file (%s)"
msgstr "无法读取 gitdir 文件（%s）"

#: worktree.c
#, c-format
msgid "short read (expected %<PRIuMAX> bytes, read %<PRIuMAX>)"
msgstr "读取过短（期望 %<PRIuMAX> 字节，读取 %<PRIuMAX>）"

#: worktree.c
msgid "invalid gitdir file"
msgstr "无效的 gitdir 文件"

#: worktree.c
msgid "gitdir file points to non-existent location"
msgstr "gitdir 文件指向一个不存在的位置"

#: worktree.c
#, c-format
msgid "unable to set %s in '%s'"
msgstr "无法在 '%2$s' 中设置 %1$s"

#: worktree.c
#, c-format
msgid "unable to unset %s in '%s'"
msgstr "无法在 '%2$s' 中取消设置 %1$s"

#: worktree.c
msgid "failed to set extensions.worktreeConfig setting"
msgstr "无法设置 extensions.worktreeConfig"

#: worktree.c
msgid "unable to upgrade repository format to support relative worktrees"
msgstr "无法升级仓库格式以支持相对工作区"

#: worktree.c
msgid "unable to set extensions.relativeWorktrees setting"
msgstr "无法设定 extensions.relativeWorktrees 的设置"

#: wrapper.c
#, c-format
msgid "could not setenv '%s'"
msgstr "无法设置环境变量 '%s'"

#: wrapper.c
#, c-format
msgid "unable to create '%s'"
msgstr "无法创建 '%s'"

#: wrapper.c
#, c-format
msgid "could not open '%s' for reading and writing"
msgstr "无法打开 '%s' 进行读写"

#: wrapper.c
#, c-format
msgid "unable to access '%s'"
msgstr "不能访问 '%s'"

#: wrapper.c
msgid "unable to get current working directory"
msgstr "不能获取当前工作目录"

#: wrapper.c
msgid "unable to get random bytes"
msgstr "无法获取随机字节"

#: wt-status.c
msgid "Unmerged paths:"
msgstr "未合并的路径："

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git restore --staged <file>...\" to unstage)"
msgstr "  （使用 \"git restore --staged <文件>...\" 以取消暂存）"

#  译者：注意保持前导空格
#: wt-status.c
#, c-format
msgid "  (use \"git restore --source=%s --staged <file>...\" to unstage)"
msgstr "  （使用 \"git restore --source=%s --staged <文件>...\" 以取消暂存）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git rm --cached <file>...\" to unstage)"
msgstr "  （使用 \"git rm --cached <文件>...\" 以取消暂存）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git add <file>...\" to mark resolution)"
msgstr "  （使用 \"git add <文件>...\" 标记解决方案）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git add/rm <file>...\" as appropriate to mark resolution)"
msgstr "  （酌情使用 \"git add/rm <文件>...\" 标记解决方案）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git rm <file>...\" to mark resolution)"
msgstr "  （使用 \"git rm <文件>...\" 标记解决方案）"

#: wt-status.c
msgid "Changes to be committed:"
msgstr "要提交的变更："

#: wt-status.c
msgid "Changes not staged for commit:"
msgstr "尚未暂存以备提交的变更："

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git add <file>...\" to update what will be committed)"
msgstr "  （使用 \"git add <文件>...\" 更新要提交的内容）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git add/rm <file>...\" to update what will be committed)"
msgstr "  （使用 \"git add/rm <文件>...\" 更新要提交的内容）"

#  译者：注意保持前导空格
#: wt-status.c
msgid ""
"  (use \"git restore <file>...\" to discard changes in working directory)"
msgstr "  （使用 \"git restore <文件>...\" 丢弃工作区的改动）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (commit or discard the untracked or modified content in submodules)"
msgstr "  （提交或丢弃子模组中未跟踪或修改的内容）"

#  译者：注意保持前导空格
#: wt-status.c
#, c-format
msgid "  (use \"git %s <file>...\" to include in what will be committed)"
msgstr "  （使用 \"git %s <文件>...\" 以包含要提交的内容）"

#: wt-status.c
msgid "both deleted:"
msgstr "双方删除："

#: wt-status.c
msgid "added by us:"
msgstr "由我们添加："

#: wt-status.c
msgid "deleted by them:"
msgstr "由他们删除："

#: wt-status.c
msgid "added by them:"
msgstr "由他们添加："

#: wt-status.c
msgid "deleted by us:"
msgstr "由我们删除："

#: wt-status.c
msgid "both added:"
msgstr "双方添加："

#: wt-status.c
msgid "both modified:"
msgstr "双方修改："

#: wt-status.c
msgid "new file:"
msgstr "新文件："

#: wt-status.c
msgid "copied:"
msgstr "拷贝："

#: wt-status.c
msgid "deleted:"
msgstr "删除："

#: wt-status.c
msgid "modified:"
msgstr "修改："

#: wt-status.c
msgid "renamed:"
msgstr "重命名："

#: wt-status.c
msgid "typechange:"
msgstr "类型变更："

#: wt-status.c
msgid "unknown:"
msgstr "未知："

#: wt-status.c
msgid "unmerged:"
msgstr "未合并："

#  译者：末尾两个字节可能被删减，如果翻译为中文标点会出现半个汉字
#: wt-status.c
msgid "new commits, "
msgstr "新提交, "

#  译者：末尾两个字节可能被删减，如果翻译为中文标点会出现半个汉字
#: wt-status.c
msgid "modified content, "
msgstr "修改的内容, "

#  译者：末尾两个字节可能被删减，如果翻译为中文标点会出现半个汉字
#: wt-status.c
msgid "untracked content, "
msgstr "未跟踪的内容, "

#: wt-status.c
#, c-format
msgid "Your stash currently has %d entry"
msgid_plural "Your stash currently has %d entries"
msgstr[0] "您的贮藏区当前有 %d 条记录"
msgstr[1] "您的贮藏区当前有 %d 条记录"

#: wt-status.c
msgid "Submodules changed but not updated:"
msgstr "子模组已修改但尚未更新："

#: wt-status.c
msgid "Submodule changes to be committed:"
msgstr "要提交的子模组变更："

#: wt-status.c
msgid ""
"Do not modify or remove the line above.\n"
"Everything below it will be ignored."
msgstr ""
"不要改动或删除上面的一行。\n"
"其下所有内容都将被忽略。"

#: wt-status.c
#, c-format
msgid ""
"\n"
"It took %.2f seconds to compute the branch ahead/behind values.\n"
"You can use '--no-ahead-behind' to avoid this.\n"
msgstr ""
"\n"
"花了 %.2f 秒才计算出分支的领先/落后范围。\n"
"为避免，您可以使用 '--no-ahead-behind'。\n"

#: wt-status.c
msgid "You have unmerged paths."
msgstr "您有尚未合并的路径。"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (fix conflicts and run \"git commit\")"
msgstr "  （解决冲突并运行 \"git commit\"）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git merge --abort\" to abort the merge)"
msgstr "  （使用 \"git merge --abort\" 终止合并）"

#: wt-status.c
msgid "All conflicts fixed but you are still merging."
msgstr "所有冲突已解决但您仍处于合并中。"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git commit\" to conclude merge)"
msgstr "  （使用 \"git commit\" 结束合并）"

#: wt-status.c
msgid "You are in the middle of an am session."
msgstr "您正处于 am 操作过程中。"

#: wt-status.c
msgid "The current patch is empty."
msgstr "当前的补丁为空。"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (fix conflicts and then run \"git am --continue\")"
msgstr "  （解决冲突，然后运行 \"git am --continue\"）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git am --skip\" to skip this patch)"
msgstr "  （使用 \"git am --skip\" 跳过此补丁）"

#  译者：注意保持前导空格
#: wt-status.c
msgid ""
"  (use \"git am --allow-empty\" to record this patch as an empty commit)"
msgstr "  （使用 \"git am --allow-empty\" 将这个补丁记录为空提交）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git am --abort\" to restore the original branch)"
msgstr "  （使用 \"git am --abort\" 恢复原有分支）"

#: wt-status.c
msgid "git-rebase-todo is missing."
msgstr "git-rebase-todo 丢失。"

#: wt-status.c
msgid "No commands done."
msgstr "没有命令被执行。"

#: wt-status.c
#, c-format
msgid "Last command done (%<PRIuMAX> command done):"
msgid_plural "Last commands done (%<PRIuMAX> commands done):"
msgstr[0] "最后完成的命令（%<PRIuMAX> 条命令被执行）："
msgstr[1] "最后完成的命令（%<PRIuMAX> 条命令被执行）："

#: wt-status.c
#, c-format
msgid "  (see more in file %s)"
msgstr "  （更多参见文件 %s）"

#: wt-status.c
msgid "No commands remaining."
msgstr "未剩下任何命令。"

#: wt-status.c
#, c-format
msgid "Next command to do (%<PRIuMAX> remaining command):"
msgid_plural "Next commands to do (%<PRIuMAX> remaining commands):"
msgstr[0] "接下来要执行的命令（剩余 %<PRIuMAX> 条命令）："
msgstr[1] "接下来要执行的命令（剩余 %<PRIuMAX> 条命令）："

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git rebase --edit-todo\" to view and edit)"
msgstr "  （使用 \"git rebase --edit-todo\" 来查看和编辑）"

#: wt-status.c
#, c-format
msgid "You are currently rebasing branch '%s' on '%s'."
msgstr "您在执行将分支 '%s' 变基到 '%s' 的操作。"

#: wt-status.c
msgid "You are currently rebasing."
msgstr "您在执行变基操作。"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (fix conflicts and then run \"git rebase --continue\")"
msgstr "  （解决冲突，然后运行 \"git rebase --continue\"）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git rebase --skip\" to skip this patch)"
msgstr "  （使用 \"git rebase --skip\" 跳过此补丁）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git rebase --abort\" to check out the original branch)"
msgstr "  （使用 \"git rebase --abort\" 以检出原有分支）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (all conflicts fixed: run \"git rebase --continue\")"
msgstr "  （所有冲突已解决：运行 \"git rebase --continue\"）"

#: wt-status.c
#, c-format
msgid ""
"You are currently splitting a commit while rebasing branch '%s' on '%s'."
msgstr "您在执行将分支 '%s' 变基到 '%s' 的操作时拆分提交。"

#: wt-status.c
msgid "You are currently splitting a commit during a rebase."
msgstr "您在执行变基操作时拆分提交。"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (Once your working directory is clean, run \"git rebase --continue\")"
msgstr "  （一旦您工作目录提交干净后，运行 \"git rebase --continue\"）"

#: wt-status.c
#, c-format
msgid "You are currently editing a commit while rebasing branch '%s' on '%s'."
msgstr "您在执行将分支 '%s' 变基到 '%s' 的操作时编辑提交。"

#: wt-status.c
msgid "You are currently editing a commit during a rebase."
msgstr "您在执行变基操作时编辑提交。"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git commit --amend\" to amend the current commit)"
msgstr "  （使用 \"git commit --amend\" 修补当前提交）"

#  译者：注意保持前导空格
#: wt-status.c
msgid ""
"  (use \"git rebase --continue\" once you are satisfied with your changes)"
msgstr "  （当您对您的修改满意后执行 \"git rebase --continue\"）"

#: wt-status.c
msgid "Cherry-pick currently in progress."
msgstr "拣选操作正在进行中。"

#: wt-status.c
#, c-format
msgid "You are currently cherry-picking commit %s."
msgstr "您在执行拣选提交 %s 的操作。"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (fix conflicts and run \"git cherry-pick --continue\")"
msgstr "  （解决冲突并运行 \"git cherry-pick --continue\"）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (run \"git cherry-pick --continue\" to continue)"
msgstr "  （执行 \"git cherry-pick --continue\" 以继续）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (all conflicts fixed: run \"git cherry-pick --continue\")"
msgstr "  （所有冲突已解决：运行 \"git cherry-pick --continue\"）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git cherry-pick --skip\" to skip this patch)"
msgstr "  （使用 \"git cherry-pick --skip\" 跳过此补丁）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git cherry-pick --abort\" to cancel the cherry-pick operation)"
msgstr "  （使用 \"git cherry-pick --abort\" 以取消拣选操作）"

#: wt-status.c
msgid "Revert currently in progress."
msgstr "还原操作正在行中。"

#: wt-status.c
#, c-format
msgid "You are currently reverting commit %s."
msgstr "您在执行反转提交 %s 的操作。"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (fix conflicts and run \"git revert --continue\")"
msgstr "  （解决冲突并执行 \"git revert --continue\"）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (run \"git revert --continue\" to continue)"
msgstr "  （执行 \"git revert --continue\" 以继续）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (all conflicts fixed: run \"git revert --continue\")"
msgstr "  （所有冲突已解决：执行 \"git revert --continue\"）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git revert --skip\" to skip this patch)"
msgstr "  （使用 \"git revert --skip\" 跳过此补丁）"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git revert --abort\" to cancel the revert operation)"
msgstr "  （使用 \"git revert --abort\" 以取消反转提交操作）"

#: wt-status.c
#, c-format
msgid "You are currently bisecting, started from branch '%s'."
msgstr "您在执行从分支 '%s' 开始的二分查找操作。"

#: wt-status.c
msgid "You are currently bisecting."
msgstr "您在执行二分查找操作。"

#  译者：注意保持前导空格
#: wt-status.c
msgid "  (use \"git bisect reset\" to get back to the original branch)"
msgstr "  （使用 \"git bisect reset\" 以回到原有分支）"

#: wt-status.c
msgid "You are in a sparse checkout."
msgstr "您处于一个稀疏检出中。"

#: wt-status.c
#, c-format
msgid "You are in a sparse checkout with %d%% of tracked files present."
msgstr "您处于稀疏检出状态，包含 %d%% 的跟踪文件"

#: wt-status.c
msgid "On branch "
msgstr "位于分支 "

#: wt-status.c
msgid "interactive rebase in progress; onto "
msgstr "交互式变基操作正在进行中；至 "

#: wt-status.c
msgid "rebase in progress; onto "
msgstr "变基操作正在进行中；至 "

#: wt-status.c
msgid "HEAD detached at "
msgstr "头指针分离于 "

#: wt-status.c
msgid "HEAD detached from "
msgstr "头指针分离自 "

#: wt-status.c
msgid "Not currently on any branch."
msgstr "当前不在任何分支上。"

#: wt-status.c
msgid "Initial commit"
msgstr "初始提交"

#: wt-status.c
msgid "No commits yet"
msgstr "尚无提交"

#: wt-status.c
msgid "Untracked files"
msgstr "未跟踪的文件"

#: wt-status.c
msgid "Ignored files"
msgstr "忽略的文件"

#: wt-status.c
#, c-format
msgid ""
"It took %.2f seconds to enumerate untracked files,\n"
"but the results were cached, and subsequent runs may be faster."
msgstr ""
"枚举未追踪的文件花了 %.2f 秒，\n"
"结果已被缓存，后续的执行会更快。"

#: wt-status.c
#, c-format
msgid "It took %.2f seconds to enumerate untracked files."
msgstr "枚举未追踪的文件花了 %.2f 秒。"

#: wt-status.c
msgid "See 'git help status' for information on how to improve this."
msgstr "参见 'git help status' 来获取如何改善的信息。"

#: wt-status.c
#, c-format
msgid "Untracked files not listed%s"
msgstr "未跟踪的文件没有列出%s"

#  译者：中文字符串拼接，可删除前导空格
#: wt-status.c
msgid " (use -u option to show untracked files)"
msgstr "（使用 -u 参数显示未跟踪的文件）"

#: wt-status.c
msgid "No changes"
msgstr "没有修改"

#: wt-status.c
#, c-format
msgid "no changes added to commit (use \"git add\" and/or \"git commit -a\")\n"
msgstr "修改尚未加入提交（使用 \"git add\" 和/或 \"git commit -a\"）\n"

#: wt-status.c
#, c-format
msgid "no changes added to commit\n"
msgstr "修改尚未加入提交\n"

#: wt-status.c
#, c-format
msgid ""
"nothing added to commit but untracked files present (use \"git add\" to "
"track)\n"
msgstr "提交为空，但是存在尚未跟踪的文件（使用 \"git add\" 建立跟踪）\n"

#: wt-status.c
#, c-format
msgid "nothing added to commit but untracked files present\n"
msgstr "提交为空，但是存在尚未跟踪的文件\n"

#: wt-status.c
#, c-format
msgid "nothing to commit (create/copy files and use \"git add\" to track)\n"
msgstr "无文件要提交（创建/拷贝文件并使用 \"git add\" 建立跟踪）\n"

#: wt-status.c
#, c-format
msgid "nothing to commit\n"
msgstr "无文件要提交\n"

#: wt-status.c
#, c-format
msgid "nothing to commit (use -u to show untracked files)\n"
msgstr "无文件要提交（使用 -u 显示未跟踪的文件）\n"

#: wt-status.c
#, c-format
msgid "nothing to commit, working tree clean\n"
msgstr "无文件要提交，干净的工作区\n"

#: wt-status.c
msgid "No commits yet on "
msgstr "尚无提交在 "

#: wt-status.c
msgid "HEAD (no branch)"
msgstr "HEAD（非分支）"

#: wt-status.c
msgid "different"
msgstr "不同"

#  译者：注意保持句尾空格
#: wt-status.c
msgid "behind "
msgstr "落后 "

#: wt-status.c
msgid "ahead "
msgstr "领先 "

#. TRANSLATORS: the action is e.g. "pull with rebase"
#: wt-status.c
#, c-format
msgid "cannot %s: You have unstaged changes."
msgstr "不能%s：您有未暂存的变更。"

#: wt-status.c
msgid "additionally, your index contains uncommitted changes."
msgstr "另外，您的索引中包含未提交的变更。"

#: wt-status.c
#, c-format
msgid "cannot %s: Your index contains uncommitted changes."
msgstr "不能%s：您的索引中包含未提交的变更。"

#: xdiff-interface.c
#, c-format
msgid "unknown style '%s' given for '%s'"
msgstr "'%2$s' 的未知风格取值 '%1$s'"

#: git-merge-octopus.sh git-merge-resolve.sh
msgid ""
"Error: Your local changes to the following files would be overwritten by "
"merge"
msgstr "错误：您对下列文件的本地修改将被合并操作覆盖"

#: git-merge-octopus.sh
msgid "Automated merge did not work."
msgstr "自动合并未生效。"

#: git-merge-octopus.sh
msgid "Should not be doing an octopus."
msgstr "不应该执行章鱼式合并。"

#: git-merge-octopus.sh
#, sh-format
msgid "Unable to find common commit with $pretty_name"
msgstr "无法找到和 $pretty_name 的基线提交"

#: git-merge-octopus.sh
#, sh-format
msgid "Already up to date with $pretty_name"
msgstr "已经和 $pretty_name 保持一致"

#: git-merge-octopus.sh
#, sh-format
msgid "Fast-forwarding to: $pretty_name"
msgstr "快进至：$pretty_name"

#: git-merge-octopus.sh
#, sh-format
msgid "Trying simple merge with $pretty_name"
msgstr "尝试和 $pretty_name 的简单合并"

#: git-merge-octopus.sh
msgid "Simple merge did not work, trying automatic merge."
msgstr "简单合并未生效，尝试自动合并。"

#: git-sh-setup.sh
#, sh-format
msgid "usage: $dashless $USAGE"
msgstr "用法：$dashless $USAGE"

#: git-sh-setup.sh
#, sh-format
msgid "Cannot chdir to $cdup, the toplevel of the working tree"
msgstr "不能切换目录到 $cdup，工作区的顶级目录"

#: git-sh-setup.sh
#, sh-format
msgid "fatal: $program_name cannot be used without a working tree."
msgstr "致命错误：$program_name 不能在没有工作区的情况下使用"

#: git-sh-setup.sh
msgid "Cannot rewrite branches: You have unstaged changes."
msgstr "不能重写分支：您有未暂存的变更。"

#: git-sh-setup.sh
#, sh-format
msgid "Cannot $action: You have unstaged changes."
msgstr "不能 $action：您有未暂存的变更。"

#: git-sh-setup.sh
#, sh-format
msgid "Cannot $action: Your index contains uncommitted changes."
msgstr "不能 $action：您的索引中包含未提交的变更。"

#: git-sh-setup.sh
msgid "Additionally, your index contains uncommitted changes."
msgstr "而且您的索引中包含未提交的变更。"

#: git-sh-setup.sh
msgid "You need to run this command from the toplevel of the working tree."
msgstr "您需要在工作区的顶级目录中运行这个命令。"

#: git-sh-setup.sh
msgid "Unable to determine absolute path of git directory"
msgstr "不能确定 git 目录的绝对路径"

#: git-send-email.perl
msgid "local zone differs from GMT by a non-minute interval\n"
msgstr "本地时间和 GMT 有不到一分钟间隔\n"

#: git-send-email.perl
msgid "local time offset greater than or equal to 24 hours\n"
msgstr "本地时间偏移量大于等于 24 小时\n"

#: git-send-email.perl
#, perl-format
msgid "fatal: command '%s' died with exit code %d"
msgstr "致命错误：命令 '%s' 已终止，退出代码为 %d"

#: git-send-email.perl
msgid "the editor exited uncleanly, aborting everything"
msgstr "编辑器非正常退出，终止所有操作"

#: git-send-email.perl
#, perl-format
msgid ""
"'%s' contains an intermediate version of the email you were composing.\n"
msgstr "'%s' 包含您正在编写的一个中间版本的邮件。\n"

#: git-send-email.perl
#, perl-format
msgid "'%s.final' contains the composed email.\n"
msgstr "'%s.final' 包含编辑的邮件。\n"

#: git-send-email.perl
msgid "--dump-aliases incompatible with other options\n"
msgstr "--dump-aliases 和其它选项不兼容\n"

#: git-send-email.perl
msgid "--dump-aliases and --translate-aliases are mutually exclusive\n"
msgstr "--dump-aliases 和 --translate-aliases 是互斥的\n"

#: git-send-email.perl
msgid ""
"fatal: found configuration options for 'sendmail'\n"
"git-send-email is configured with the sendemail.* options - note the 'e'.\n"
"Set sendemail.forbidSendmailVariables to false to disable this check.\n"
msgstr ""
"致命错误：发现 'sendmail' 配置选项\n"
"git-send-email 通过 sendemail.* 选项进行设置，注意字母 'e'。\n"
"设置 sendemail.forbidSendmailVariables 为 false 来禁用这项检查。\n"

#: git-send-email.perl
msgid "Cannot run git format-patch from outside a repository\n"
msgstr "不能在仓库之外运行 git format-patch\n"

#: git-send-email.perl
msgid ""
"`batch-size` and `relogin` must be specified together (via command-line or "
"configuration option)\n"
msgstr "`batch-size` 和 `relogin` 必须同时定义（通过命令行或者配置选项）\n"

#: git-send-email.perl
#, perl-format
msgid "Unknown --suppress-cc field: '%s'\n"
msgstr "未知的 --suppress-cc 字段：'%s'\n"

#: git-send-email.perl
#, perl-format
msgid "Unknown --confirm setting: '%s'\n"
msgstr "未知的 --confirm 设置：'%s'\n"

#: git-send-email.perl
#, perl-format
msgid "warning: sendmail alias with quotes is not supported: %s\n"
msgstr "警告：不支持带引号的 sendmail 别名：%s\n"

#: git-send-email.perl
#, perl-format
msgid "warning: `:include:` not supported: %s\n"
msgstr "警告：不支持 `:include:`：%s\n"

#: git-send-email.perl
#, perl-format
msgid "warning: `/file` or `|pipe` redirection not supported: %s\n"
msgstr "警告：不支持 `/file` 或 `|pipe` 重定向：%s\n"

#: git-send-email.perl
#, perl-format
msgid "warning: sendmail line is not recognized: %s\n"
msgstr "警告：不能识别的 sendmail 行：%s\n"

#: git-send-email.perl
#, perl-format
msgid ""
"File '%s' exists but it could also be the range of commits\n"
"to produce patches for.  Please disambiguate by...\n"
"\n"
"    * Saying \"./%s\" if you mean a file; or\n"
"    * Giving --format-patch option if you mean a range.\n"
msgstr ""
"存在文件 '%s' 但是它也可能是一个用于产生补丁列表的提交范围。请用如下方法消除"
"歧义：\n"
"\n"
"    * 如果含义为一个文件，使用 \"./%s\"，或者\n"
"    * 如果含义为一个范围，使用 --format-patch 选项。\n"

#: git-send-email.perl
#, perl-format
msgid "Failed to opendir %s: %s"
msgstr "无法打开目录 %s: %s"

#: git-send-email.perl
msgid ""
"\n"
"No patch files specified!\n"
"\n"
msgstr ""
"\n"
"未指定补丁文件！\n"
"\n"

#: git-send-email.perl
#, perl-format
msgid "No subject line in %s?"
msgstr "在 %s 中没有标题行？"

#: git-send-email.perl
#, perl-format
msgid "Failed to open for writing %s: %s"
msgstr "为写入打开 %s 失败: %s"

#: git-send-email.perl
msgid ""
"Lines beginning in \"GIT:\" will be removed.\n"
"Consider including an overall diffstat or table of contents\n"
"for the patch you are writing.\n"
"\n"
"Clear the body content if you don't wish to send a summary.\n"
msgstr ""
"以 \"GIT:\" 开头的行将被删除。\n"
"考虑包含一个整体的差异统计或者您正在写的补丁的目录。\n"
"\n"
"如果您不想发送摘要，清除内容。\n"

#: git-send-email.perl
#, perl-format
msgid "Failed to open %s.final: %s"
msgstr "无法打开 %s.final: %s"

#: git-send-email.perl
#, perl-format
msgid "Failed to open %s: %s"
msgstr "无法打开 %s: %s"

#: git-send-email.perl
msgid "Summary email is empty, skipping it\n"
msgstr "摘要邮件为空，跳过\n"

#. TRANSLATORS: please keep [y/N] as is.
#: git-send-email.perl
#, perl-format
msgid "Are you sure you want to use <%s> [y/N]? "
msgstr "您确认要使用 <%s> [y/N]？"

#: git-send-email.perl
msgid ""
"The following files are 8bit, but do not declare a Content-Transfer-"
"Encoding.\n"
msgstr "如下文件含 8bit 内容，但没有声明一个 Content-Transfer-Encoding。\n"

#: git-send-email.perl
msgid "Which 8bit encoding should I declare [UTF-8]? "
msgstr "要声明 8bit 为什么样的编码格式 [UTF-8]？"

#: git-send-email.perl
#, perl-format
msgid ""
"Refusing to send because the patch\n"
"\t%s\n"
"has the template subject '*** SUBJECT HERE ***'. Pass --force if you really "
"want to send.\n"
msgstr ""
"拒绝发送，因为补丁\n"
"\t%s\n"
"包含模版标题 '*** SUBJECT HERE ***'。如果确实想要发送，使用参数 --force。\n"

#: git-send-email.perl
msgid "To whom should the emails be sent (if anyone)?"
msgstr "邮件将要发送给谁？"

#: git-send-email.perl
#, perl-format
msgid "fatal: alias '%s' expands to itself\n"
msgstr "致命错误：别名 '%s' 扩展为它自己\n"

#: git-send-email.perl
msgid "Message-ID to be used as In-Reply-To for the first email (if any)? "
msgstr "Message-ID 被用作第一封邮件的 In-Reply-To ？"

#: git-send-email.perl
#, perl-format
msgid "error: unable to extract a valid address from: %s\n"
msgstr "错误：不能从 %s 中提取一个有效的邮件地址\n"

#. TRANSLATORS: Make sure to include [q] [d] [e] in your
#. translation. The program will only accept English input
#. at this point.
#: git-send-email.perl
msgid "What to do with this address? ([q]uit|[d]rop|[e]dit): "
msgstr "如何处理这个地址？([q]uit|[d]rop|[e]dit)："

#: git-send-email.perl
#, perl-format
msgid "CA path \"%s\" does not exist"
msgstr "CA 路径 \"%s\" 不存在"

#: git-send-email.perl
msgid ""
"    The Cc list above has been expanded by additional\n"
"    addresses found in the patch commit message. By default\n"
"    send-email prompts before sending whenever this occurs.\n"
"    This behavior is controlled by the sendemail.confirm\n"
"    configuration setting.\n"
"\n"
"    For additional information, run 'git send-email --help'.\n"
"    To retain the current behavior, but squelch this message,\n"
"    run 'git config --global sendemail.confirm auto'.\n"
"\n"
msgstr ""
"    以上的抄送列表（Cc）已经用补丁提交信息中发现的地址进行\n"
"    了扩展。缺省 send-email 会给出提示。这个行为可以通过\n"
"    sendemail.confirm 配置设置。\n"
"\n"
"    更多信息，执行 'git send-email --help'。\n"
"    要保持当前行为，但不显示此信息，运行 'git config --global\n"
"    sendemail.confirm auto'。\n"
"\n"

#. TRANSLATORS: Make sure to include [y] [n] [e] [q] [a] in your
#. translation. The program will only accept English input
#. at this point.
#: git-send-email.perl
msgid "Send this email? ([y]es|[n]o|[e]dit|[q]uit|[a]ll): "
msgstr "发送这封邮件？([y]es|[n]o|[e]dit|[q]uit|[a]ll): "

#: git-send-email.perl
msgid "Send this email reply required"
msgstr "发送要求的邮件回复"

#: git-send-email.perl
msgid "The required SMTP server is not properly defined."
msgstr "要求的 SMTP 服务器未被正确定义。"

#: git-send-email.perl
#, perl-format
msgid "Server does not support STARTTLS! %s"
msgstr "服务器不支持 STARTTLS！%s"

#: git-send-email.perl
#, perl-format
msgid "STARTTLS failed! %s"
msgstr "STARTTLS 失败！%s"

#: git-send-email.perl
msgid "Unable to initialize SMTP properly. Check config and use --smtp-debug."
msgstr "无法正确地初始化 SMTP。检查配置并使用 --smtp-debug。"

#: git-send-email.perl
#, perl-format
msgid "Failed to send %s\n"
msgstr "无法发送 %s\n"

#: git-send-email.perl
#, perl-format
msgid "Dry-Sent %s"
msgstr "演习发送 %s"

#: git-send-email.perl
#, perl-format
msgid "Sent %s"
msgstr "已发送 %s"

#: git-send-email.perl
msgid "Dry-OK. Log says:"
msgstr "演习成功。日志说："

#: git-send-email.perl
msgid "OK. Log says:"
msgstr "成功。日志说："

#: git-send-email.perl
msgid "Result: "
msgstr "结果："

#: git-send-email.perl
msgid "Result: OK"
msgstr "结果：成功"

#: git-send-email.perl
#, perl-format
msgid "can't open file %s"
msgstr "无法打开文件 %s"

#: git-send-email.perl
#, perl-format
msgid "(mbox) Adding cc: %s from line '%s'\n"
msgstr "(mbox) 添加 cc：%s 自行 '%s'\n"

#: git-send-email.perl
#, perl-format
msgid "(mbox) Adding to: %s from line '%s'\n"
msgstr "(mbox) 添加 to：%s 自行 '%s'\n"

#: git-send-email.perl
#, perl-format
msgid "(non-mbox) Adding cc: %s from line '%s'\n"
msgstr "(non-mbox) 添加 cc：%s 自行 '%s'\n"

#: git-send-email.perl
#, perl-format
msgid "(body) Adding cc: %s from line '%s'\n"
msgstr "(body) 添加 cc: %s 自行 '%s'\n"

#: git-send-email.perl
#, perl-format
msgid "(%s) Could not execute '%s'"
msgstr "(%s) 不能执行 '%s'"

#: git-send-email.perl
#, perl-format
msgid "(%s) Malformed output from '%s'"
msgstr "(%s) 非法的输出信息，来自于: '%s'"

#: git-send-email.perl
#, perl-format
msgid "(%s) failed to close pipe to '%s'"
msgstr "(%s) 无法关闭管道至 '%s'"

#: git-send-email.perl
#, perl-format
msgid "(%s) Adding %s: %s from: '%s'\n"
msgstr "(%s) 添加 %s: %s 自：'%s'\n"

#: git-send-email.perl
msgid "cannot send message as 7bit"
msgstr "不能以 7bit 形式发送信息"

#: git-send-email.perl
msgid "invalid transfer encoding"
msgstr "无效的传送编码"

#: git-send-email.perl
#, perl-format
msgid ""
"fatal: %s: rejected by %s hook\n"
"%s\n"
"warning: no patches were sent\n"
msgstr ""
"致命错误：%s：被 %s 钩子拒绝\n"
"%s\n"
"警告：补丁未能发送\n"

#: git-send-email.perl
#, perl-format
msgid "unable to open %s: %s\n"
msgstr "不能打开 %s：%s\n"

#: git-send-email.perl
#, perl-format
msgid ""
"fatal: %s:%d is longer than 998 characters\n"
"warning: no patches were sent\n"
msgstr ""
"致命错误：%s:%d 超过 998 字符\n"
"警告：补丁未能发送\n"

#: git-send-email.perl
#, perl-format
msgid "Skipping %s with backup suffix '%s'.\n"
msgstr "略过 %s 含备份后缀 '%s'。\n"

#. TRANSLATORS: please keep "[y|N]" as is.
#: git-send-email.perl
#, perl-format
msgid "Do you really want to send %s? [y|N]: "
msgstr "您真的要发送 %s？[y|N]："
