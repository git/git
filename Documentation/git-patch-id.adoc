git-patch-id(1)
===============

NAME
----
git-patch-id - Compute unique IDs for patches

SYNOPSIS
--------
[synopsis]
git patch-id [--stable | --unstable | --verbatim]

DESCRIPTION
-----------
Read patches from standard input and compute the patch IDs.

A "patch ID" is nothing but a sum of SHA-1 of the file diffs associated with a
patch, with line numbers ignored.  As such, it's "reasonably stable", but at
the same time also reasonably unique, i.e., two patches that have the same
"patch ID" are almost guaranteed to be the same thing.

The main usecase for this command is to look for likely duplicate commits.

When dealing with `git diff-tree --patch` output, it takes advantage of
the fact that the patch is prefixed with the object name of the
commit, and outputs two 40-byte hexadecimal strings.  The first
string is the patch ID, and the second string is the commit ID.
This can be used to make a mapping from patch ID to commit ID for a
set or range of commits.

OPTIONS
-------

`--verbatim`::
	Calculate the patch ID of the input as it is given, do not strip
	any whitespace. Implies `--stable` and forbids `--unstable`.
+
This is the default if `patchid.verbatim` is `true`.

`--stable`::
	Use a "stable" sum of hashes as the patch ID. With this option:
+
--
- Reordering file diffs that make up a patch does not affect the ID.
  In particular, two patches produced by comparing the same two trees
  with two different settings for `-O<orderfile>` result in the same
  patch ID signature, thereby allowing the computed result to be used
  as a key to index some meta-information about the change between
  the two trees.

- The result is different from the value produced by Git 1.9 and older
  or produced when an "unstable" hash (see `--unstable` below) is
  configured - even when used on a diff output taken without any use
  of `-O<orderfile>`, thereby making existing databases storing such
  "unstable" or historical patch IDs unusable.

- All whitespace within the patch is ignored and does not affect the ID.
--
+
This is the default if `patchid.stable` is set to `true`.

`--unstable`::
	Use an "unstable" hash as the patch ID. With this option,
	the result produced is compatible with the patch ID value produced
	by Git 1.9 and older and whitespace is ignored.  Users with pre-existing
	databases storing patch IDs produced by Git 1.9 and older (who do not deal
	with reordered patches) may want to use this option.
+
This is the default.

EXAMPLES
--------

linkgit:git-cherry[1] shows what commits from a branch have patch ID
equivalent commits in some upstream branch. But it only tells you
whether such a commit exists or not. What if you wanted to know the
relevant commits in the upstream? We can use this command to make a
mapping between your branch and the upstream branch:

----
#!/bin/sh

upstream="$1"
branch="$2"
test -z "$branch" && branch=HEAD
limit="$3"
if test -n "$limit"
then
    tail_opts="$limit".."$upstream"
else
    since=$(git log --format=%aI "$upstream".."$branch" | tail -1)
    tail_opts=--since="$since"' '"$upstream"
fi
for_branch=$(mktemp)
for_upstream=$(mktemp)

git rev-list --no-merges "$upstream".."$branch" |
    git diff-tree --patch --stdin |
    git patch-id  --stable | sort >"$for_branch"
git rev-list --no-merges $tail_opts |
    git diff-tree --patch --stdin |
    git patch-id  --stable | sort >"$for_upstream"
join -a1 "$for_branch" "$for_upstream" | cut -d' ' -f2,3
rm "$for_branch"
rm "$for_upstream"
----

Now the first column shows the commit from your branch and the second
column shows the patch ID equivalent commit, if it exists.

SEE ALSO
--------
linkgit:git-cherry[1]

GIT
---
Part of the linkgit:git[1] suite
