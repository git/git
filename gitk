#!/bin/sh
# Tcl ignores the next line -*- tcl -*- \
exec wish "$0" -- "${1+$@}"

# Copyright (C) 2005 Paul Mackerras.  All rights reserved.
# This program is free software; it may be used, copied, modified
# and distributed under the terms of the GNU General Public Licence,
# either version 2, or (at your option) any later version.

proc gitdir {} {
    global env
    if {[info exists env(GIT_DIR)]} {
	return $env(GIT_DIR)
    } else {
	return ".git"
    }
}

proc getcommits {rargs} {
    global commits commfd phase canv mainfont env
    global startmsecs nextupdate
    global ctext maincursor textcursor leftover

    # check that we can find a .git directory somewhere...
    set gitdir [gitdir]
    if {![file isdirectory $gitdir]} {
	error_popup "Cannot find the git directory \"$gitdir\"."
	exit 1
    }
    set commits {}
    set phase getcommits
    set startmsecs [clock clicks -milliseconds]
    set nextupdate [expr $startmsecs + 100]
    if [catch {
	set parse_args [concat --default HEAD $rargs]
	set parsed_args [split [eval exec git-rev-parse $parse_args] "\n"]
    }] {
	# if git-rev-parse failed for some reason...
	if {$rargs == {}} {
	    set rargs HEAD
	}
	set parsed_args $rargs
    }
    if [catch {
	set commfd [open "|git-rev-list --header --topo-order $parsed_args" r]
    } err] {
	puts stderr "Error executing git-rev-list: $err"
	exit 1
    }
    set leftover {}
    fconfigure $commfd -blocking 0 -translation lf
    fileevent $commfd readable "getcommitlines $commfd"
    $canv delete all
    $canv create text 3 3 -anchor nw -text "Reading commits..." \
	-font $mainfont -tags textitems
    . config -cursor watch
    settextcursor watch
}

proc getcommitlines {commfd}  {
    global commits parents cdate children nchildren
    global commitlisted phase commitinfo nextupdate
    global stopped redisplaying leftover

    set stuff [read $commfd]
    if {$stuff == {}} {
	if {![eof $commfd]} return
	# set it blocking so we wait for the process to terminate
	fconfigure $commfd -blocking 1
	if {![catch {close $commfd} err]} {
	    after idle finishcommits
	    return
	}
	if {[string range $err 0 4] == "usage"} {
	    set err \
{Gitk: error reading commits: bad arguments to git-rev-list.
(Note: arguments to gitk are passed to git-rev-list
to allow selection of commits to be displayed.)}
	} else {
	    set err "Error reading commits: $err"
	}
	error_popup $err
	exit 1
    }
    set start 0
    while 1 {
	set i [string first "\0" $stuff $start]
	if {$i < 0} {
	    append leftover [string range $stuff $start end]
	    return
	}
	set cmit [string range $stuff $start [expr {$i - 1}]]
	if {$start == 0} {
	    set cmit "$leftover$cmit"
	    set leftover {}
	}
	set start [expr {$i + 1}]
	if {![regexp {^([0-9a-f]{40})\n} $cmit match id]} {
	    set shortcmit $cmit
	    if {[string length $shortcmit] > 80} {
		set shortcmit "[string range $shortcmit 0 80]..."
	    }
	    error_popup "Can't parse git-rev-list output: {$shortcmit}"
	    exit 1
	}
	set cmit [string range $cmit 41 end]
	lappend commits $id
	set commitlisted($id) 1
	parsecommit $id $cmit 1
	drawcommit $id
	if {[clock clicks -milliseconds] >= $nextupdate} {
	    doupdate
	}
	while {$redisplaying} {
	    set redisplaying 0
	    if {$stopped == 1} {
		set stopped 0
		set phase "getcommits"
		foreach id $commits {
		    drawcommit $id
		    if {$stopped} break
		    if {[clock clicks -milliseconds] >= $nextupdate} {
			doupdate
		    }
		}
	    }
	}
    }
}

proc doupdate {} {
    global commfd nextupdate

    incr nextupdate 100
    fileevent $commfd readable {}
    update
    fileevent $commfd readable "getcommitlines $commfd"
}

proc readcommit {id} {
    if [catch {set contents [exec git-cat-file commit $id]}] return
    parsecommit $id $contents 0
}

proc parsecommit {id contents listed} {
    global commitinfo children nchildren parents nparents cdate ncleft

    set inhdr 1
    set comment {}
    set headline {}
    set auname {}
    set audate {}
    set comname {}
    set comdate {}
    if {![info exists nchildren($id)]} {
	set children($id) {}
	set nchildren($id) 0
	set ncleft($id) 0
    }
    set parents($id) {}
    set nparents($id) 0
    foreach line [split $contents "\n"] {
	if {$inhdr} {
	    if {$line == {}} {
		set inhdr 0
	    } else {
		set tag [lindex $line 0]
		if {$tag == "parent"} {
		    set p [lindex $line 1]
		    if {![info exists nchildren($p)]} {
			set children($p) {}
			set nchildren($p) 0
			set ncleft($p) 0
		    }
		    lappend parents($id) $p
		    incr nparents($id)
		    # sometimes we get a commit that lists a parent twice...
		    if {$listed && [lsearch -exact $children($p) $id] < 0} {
			lappend children($p) $id
			incr nchildren($p)
			incr ncleft($p)
		    }
		} elseif {$tag == "author"} {
		    set x [expr {[llength $line] - 2}]
		    set audate [lindex $line $x]
		    set auname [lrange $line 1 [expr {$x - 1}]]
		} elseif {$tag == "committer"} {
		    set x [expr {[llength $line] - 2}]
		    set comdate [lindex $line $x]
		    set comname [lrange $line 1 [expr {$x - 1}]]
		}
	    }
	} else {
	    if {$comment == {}} {
		set headline [string trim $line]
	    } else {
		append comment "\n"
	    }
	    if {!$listed} {
		# git-rev-list indents the comment by 4 spaces;
		# if we got this via git-cat-file, add the indentation
		append comment "    "
	    }
	    append comment $line
	}
    }
    if {$audate != {}} {
	set audate [clock format $audate -format "%Y-%m-%d %H:%M:%S"]
    }
    if {$comdate != {}} {
	set cdate($id) $comdate
	set comdate [clock format $comdate -format "%Y-%m-%d %H:%M:%S"]
    }
    set commitinfo($id) [list $headline $auname $audate \
			     $comname $comdate $comment]
}

proc readrefs {} {
    global tagids idtags headids idheads
    set tags [glob -nocomplain -types f [gitdir]/refs/tags/*]
    foreach f $tags {
	catch {
	    set fd [open $f r]
	    set line [read $fd]
	    if {[regexp {^[0-9a-f]{40}} $line id]} {
		set direct [file tail $f]
		set tagids($direct) $id
		lappend idtags($id) $direct
		set contents [split [exec git-cat-file tag $id] "\n"]
		set obj {}
		set type {}
		set tag {}
		foreach l $contents {
		    if {$l == {}} break
		    switch -- [lindex $l 0] {
			"object" {set obj [lindex $l 1]}
			"type" {set type [lindex $l 1]}
			"tag" {set tag [string range $l 4 end]}
		    }
		}
		if {$obj != {} && $type == "commit" && $tag != {}} {
		    set tagids($tag) $obj
		    lappend idtags($obj) $tag
		}
	    }
	    close $fd
	}
    }
    set heads [glob -nocomplain -types f [gitdir]/refs/heads/*]
    foreach f $heads {
	catch {
	    set fd [open $f r]
	    set line [read $fd 40]
	    if {[regexp {^[0-9a-f]{40}} $line id]} {
		set head [file tail $f]
		set headids($head) $line
		lappend idheads($line) $head
	    }
	    close $fd
	}
    }
}

proc error_popup msg {
    set w .error
    toplevel $w
    wm transient $w .
    message $w.m -text $msg -justify center -aspect 400
    pack $w.m -side top -fill x -padx 20 -pady 20
    button $w.ok -text OK -command "destroy $w"
    pack $w.ok -side bottom -fill x
    bind $w <Visibility> "grab $w; focus $w"
    tkwait window $w
}

proc makewindow {} {
    global canv canv2 canv3 linespc charspc ctext cflist textfont
    global findtype findtypemenu findloc findstring fstring geometry
    global entries sha1entry sha1string sha1but
    global maincursor textcursor curtextcursor
    global rowctxmenu gaudydiff mergemax

    menu .bar
    .bar add cascade -label "File" -menu .bar.file
    menu .bar.file
    .bar.file add command -label "Quit" -command doquit
    menu .bar.help
    .bar add cascade -label "Help" -menu .bar.help
    .bar.help add command -label "About gitk" -command about
    . configure -menu .bar

    if {![info exists geometry(canv1)]} {
	set geometry(canv1) [expr 45 * $charspc]
	set geometry(canv2) [expr 30 * $charspc]
	set geometry(canv3) [expr 15 * $charspc]
	set geometry(canvh) [expr 25 * $linespc + 4]
	set geometry(ctextw) 80
	set geometry(ctexth) 30
	set geometry(cflistw) 30
    }
    panedwindow .ctop -orient vertical
    if {[info exists geometry(width)]} {
	.ctop conf -width $geometry(width) -height $geometry(height)
	set texth [expr {$geometry(height) - $geometry(canvh) - 56}]
	set geometry(ctexth) [expr {($texth - 8) /
				    [font metrics $textfont -linespace]}]
    }
    frame .ctop.top
    frame .ctop.top.bar
    pack .ctop.top.bar -side bottom -fill x
    set cscroll .ctop.top.csb
    scrollbar $cscroll -command {allcanvs yview} -highlightthickness 0
    pack $cscroll -side right -fill y
    panedwindow .ctop.top.clist -orient horizontal -sashpad 0 -handlesize 4
    pack .ctop.top.clist -side top -fill both -expand 1
    .ctop add .ctop.top
    set canv .ctop.top.clist.canv
    canvas $canv -height $geometry(canvh) -width $geometry(canv1) \
	-bg white -bd 0 \
	-yscrollincr $linespc -yscrollcommand "$cscroll set"
    .ctop.top.clist add $canv
    set canv2 .ctop.top.clist.canv2
    canvas $canv2 -height $geometry(canvh) -width $geometry(canv2) \
	-bg white -bd 0 -yscrollincr $linespc
    .ctop.top.clist add $canv2
    set canv3 .ctop.top.clist.canv3
    canvas $canv3 -height $geometry(canvh) -width $geometry(canv3) \
	-bg white -bd 0 -yscrollincr $linespc
    .ctop.top.clist add $canv3
    bind .ctop.top.clist <Configure> {resizeclistpanes %W %w}

    set sha1entry .ctop.top.bar.sha1
    set entries $sha1entry
    set sha1but .ctop.top.bar.sha1label
    button $sha1but -text "SHA1 ID: " -state disabled -relief flat \
	-command gotocommit -width 8
    $sha1but conf -disabledforeground [$sha1but cget -foreground]
    pack .ctop.top.bar.sha1label -side left
    entry $sha1entry -width 40 -font $textfont -textvariable sha1string
    trace add variable sha1string write sha1change
    pack $sha1entry -side left -pady 2

    image create bitmap bm-left -data {
	#define left_width 16
	#define left_height 16
	static unsigned char left_bits[] = {
	0x00, 0x00, 0xc0, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x1c, 0x00,
	0x0e, 0x00, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x0e, 0x00, 0x1c, 0x00,
	0x38, 0x00, 0x70, 0x00, 0xe0, 0x00, 0xc0, 0x01};
    }
    image create bitmap bm-right -data {
	#define right_width 16
	#define right_height 16
	static unsigned char right_bits[] = {
	0x00, 0x00, 0xc0, 0x01, 0x80, 0x03, 0x00, 0x07, 0x00, 0x0e, 0x00, 0x1c,
	0x00, 0x38, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x00, 0x38, 0x00, 0x1c,
	0x00, 0x0e, 0x00, 0x07, 0x80, 0x03, 0xc0, 0x01};
    }
    button .ctop.top.bar.leftbut -image bm-left -command goback \
	-state disabled -width 26
    pack .ctop.top.bar.leftbut -side left -fill y
    button .ctop.top.bar.rightbut -image bm-right -command goforw \
	-state disabled -width 26
    pack .ctop.top.bar.rightbut -side left -fill y

    button .ctop.top.bar.findbut -text "Find" -command dofind
    pack .ctop.top.bar.findbut -side left
    set findstring {}
    set fstring .ctop.top.bar.findstring
    lappend entries $fstring
    entry $fstring -width 30 -font $textfont -textvariable findstring
    pack $fstring -side left -expand 1 -fill x
    set findtype Exact
    set findtypemenu [tk_optionMenu .ctop.top.bar.findtype \
			  findtype Exact IgnCase Regexp]
    set findloc "All fields"
    tk_optionMenu .ctop.top.bar.findloc findloc "All fields" Headline \
	Comments Author Committer Files Pickaxe
    pack .ctop.top.bar.findloc -side right
    pack .ctop.top.bar.findtype -side right
    # for making sure type==Exact whenever loc==Pickaxe
    trace add variable findloc write findlocchange

    panedwindow .ctop.cdet -orient horizontal
    .ctop add .ctop.cdet
    frame .ctop.cdet.left
    set ctext .ctop.cdet.left.ctext
    text $ctext -bg white -state disabled -font $textfont \
	-width $geometry(ctextw) -height $geometry(ctexth) \
	-yscrollcommand ".ctop.cdet.left.sb set"
    scrollbar .ctop.cdet.left.sb -command "$ctext yview"
    pack .ctop.cdet.left.sb -side right -fill y
    pack $ctext -side left -fill both -expand 1
    .ctop.cdet add .ctop.cdet.left

    $ctext tag conf filesep -font [concat $textfont bold] -back "#aaaaaa"
    if {$gaudydiff} {
	$ctext tag conf hunksep -back blue -fore white
	$ctext tag conf d0 -back "#ff8080"
	$ctext tag conf d1 -back green
    } else {
	$ctext tag conf hunksep -fore blue
	$ctext tag conf d0 -fore red
	$ctext tag conf d1 -fore "#00a000"
	$ctext tag conf m0 -fore red
	$ctext tag conf m1 -fore blue
	$ctext tag conf m2 -fore green
	$ctext tag conf m3 -fore purple
	$ctext tag conf m4 -fore brown
	$ctext tag conf mmax -fore darkgrey
	set mergemax 5
	$ctext tag conf mresult -font [concat $textfont bold]
	$ctext tag conf msep -font [concat $textfont bold]
	$ctext tag conf found -back yellow
    }

    frame .ctop.cdet.right
    set cflist .ctop.cdet.right.cfiles
    listbox $cflist -bg white -selectmode extended -width $geometry(cflistw) \
	-yscrollcommand ".ctop.cdet.right.sb set"
    scrollbar .ctop.cdet.right.sb -command "$cflist yview"
    pack .ctop.cdet.right.sb -side right -fill y
    pack $cflist -side left -fill both -expand 1
    .ctop.cdet add .ctop.cdet.right
    bind .ctop.cdet <Configure> {resizecdetpanes %W %w}

    pack .ctop -side top -fill both -expand 1

    bindall <1> {selcanvline %W %x %y}
    #bindall <B1-Motion> {selcanvline %W %x %y}
    bindall <ButtonRelease-4> "allcanvs yview scroll -5 units"
    bindall <ButtonRelease-5> "allcanvs yview scroll 5 units"
    bindall <2> "allcanvs scan mark 0 %y"
    bindall <B2-Motion> "allcanvs scan dragto 0 %y"
    bind . <Key-Up> "selnextline -1"
    bind . <Key-Down> "selnextline 1"
    bind . <Key-Prior> "allcanvs yview scroll -1 pages"
    bind . <Key-Next> "allcanvs yview scroll 1 pages"
    bindkey <Key-Delete> "$ctext yview scroll -1 pages"
    bindkey <Key-BackSpace> "$ctext yview scroll -1 pages"
    bindkey <Key-space> "$ctext yview scroll 1 pages"
    bindkey p "selnextline -1"
    bindkey n "selnextline 1"
    bindkey b "$ctext yview scroll -1 pages"
    bindkey d "$ctext yview scroll 18 units"
    bindkey u "$ctext yview scroll -18 units"
    bindkey / {findnext 1}
    bindkey <Key-Return> {findnext 0}
    bindkey ? findprev
    bindkey f nextfile
    bind . <Control-q> doquit
    bind . <Control-f> dofind
    bind . <Control-g> {findnext 0}
    bind . <Control-r> findprev
    bind . <Control-equal> {incrfont 1}
    bind . <Control-KP_Add> {incrfont 1}
    bind . <Control-minus> {incrfont -1}
    bind . <Control-KP_Subtract> {incrfont -1}
    bind $cflist <<ListboxSelect>> listboxsel
    bind . <Destroy> {savestuff %W}
    bind . <Button-1> "click %W"
    bind $fstring <Key-Return> dofind
    bind $sha1entry <Key-Return> gotocommit
    bind $sha1entry <<PasteSelection>> clearsha1

    set maincursor [. cget -cursor]
    set textcursor [$ctext cget -cursor]
    set curtextcursor $textcursor

    set rowctxmenu .rowctxmenu
    menu $rowctxmenu -tearoff 0
    $rowctxmenu add command -label "Diff this -> selected" \
	-command {diffvssel 0}
    $rowctxmenu add command -label "Diff selected -> this" \
	-command {diffvssel 1}
    $rowctxmenu add command -label "Make patch" -command mkpatch
    $rowctxmenu add command -label "Create tag" -command mktag
    $rowctxmenu add command -label "Write commit to file" -command writecommit
}

# when we make a key binding for the toplevel, make sure
# it doesn't get triggered when that key is pressed in the
# find string entry widget.
proc bindkey {ev script} {
    global entries
    bind . $ev $script
    set escript [bind Entry $ev]
    if {$escript == {}} {
	set escript [bind Entry <Key>]
    }
    foreach e $entries {
	bind $e $ev "$escript; break"
    }
}

# set the focus back to the toplevel for any click outside
# the entry widgets
proc click {w} {
    global entries
    foreach e $entries {
	if {$w == $e} return
    }
    focus .
}

proc savestuff {w} {
    global canv canv2 canv3 ctext cflist mainfont textfont
    global stuffsaved findmergefiles gaudydiff maxgraphpct

    if {$stuffsaved} return
    if {![winfo viewable .]} return
    catch {
	set f [open "~/.gitk-new" w]
	puts $f [list set mainfont $mainfont]
	puts $f [list set textfont $textfont]
	puts $f [list set findmergefiles $findmergefiles]
	puts $f [list set gaudydiff $gaudydiff]
	puts $f [list set maxgraphpct $maxgraphpct]
	puts $f "set geometry(width) [winfo width .ctop]"
	puts $f "set geometry(height) [winfo height .ctop]"
	puts $f "set geometry(canv1) [expr [winfo width $canv]-2]"
	puts $f "set geometry(canv2) [expr [winfo width $canv2]-2]"
	puts $f "set geometry(canv3) [expr [winfo width $canv3]-2]"
	puts $f "set geometry(canvh) [expr [winfo height $canv]-2]"
	set wid [expr {([winfo width $ctext] - 8) \
			   / [font measure $textfont "0"]}]
	puts $f "set geometry(ctextw) $wid"
	set wid [expr {([winfo width $cflist] - 11) \
			   / [font measure [$cflist cget -font] "0"]}]
	puts $f "set geometry(cflistw) $wid"
	close $f
	file rename -force "~/.gitk-new" "~/.gitk"
    }
    set stuffsaved 1
}

proc resizeclistpanes {win w} {
    global oldwidth
    if [info exists oldwidth($win)] {
	set s0 [$win sash coord 0]
	set s1 [$win sash coord 1]
	if {$w < 60} {
	    set sash0 [expr {int($w/2 - 2)}]
	    set sash1 [expr {int($w*5/6 - 2)}]
	} else {
	    set factor [expr {1.0 * $w / $oldwidth($win)}]
	    set sash0 [expr {int($factor * [lindex $s0 0])}]
	    set sash1 [expr {int($factor * [lindex $s1 0])}]
	    if {$sash0 < 30} {
		set sash0 30
	    }
	    if {$sash1 < $sash0 + 20} {
		set sash1 [expr $sash0 + 20]
	    }
	    if {$sash1 > $w - 10} {
		set sash1 [expr $w - 10]
		if {$sash0 > $sash1 - 20} {
		    set sash0 [expr $sash1 - 20]
		}
	    }
	}
	$win sash place 0 $sash0 [lindex $s0 1]
	$win sash place 1 $sash1 [lindex $s1 1]
    }
    set oldwidth($win) $w
}

proc resizecdetpanes {win w} {
    global oldwidth
    if [info exists oldwidth($win)] {
	set s0 [$win sash coord 0]
	if {$w < 60} {
	    set sash0 [expr {int($w*3/4 - 2)}]
	} else {
	    set factor [expr {1.0 * $w / $oldwidth($win)}]
	    set sash0 [expr {int($factor * [lindex $s0 0])}]
	    if {$sash0 < 45} {
		set sash0 45
	    }
	    if {$sash0 > $w - 15} {
		set sash0 [expr $w - 15]
	    }
	}
	$win sash place 0 $sash0 [lindex $s0 1]
    }
    set oldwidth($win) $w
}

proc allcanvs args {
    global canv canv2 canv3
    eval $canv $args
    eval $canv2 $args
    eval $canv3 $args
}

proc bindall {event action} {
    global canv canv2 canv3
    bind $canv $event $action
    bind $canv2 $event $action
    bind $canv3 $event $action
}

proc about {} {
    set w .about
    if {[winfo exists $w]} {
	raise $w
	return
    }
    toplevel $w
    wm title $w "About gitk"
    message $w.m -text {
Gitk version 1.2

Copyright © 2005 Paul Mackerras

Use and redistribute under the terms of the GNU General Public License} \
	    -justify center -aspect 400
    pack $w.m -side top -fill x -padx 20 -pady 20
    button $w.ok -text Close -command "destroy $w"
    pack $w.ok -side bottom
}

proc assigncolor {id} {
    global commitinfo colormap commcolors colors nextcolor
    global parents nparents children nchildren
    global cornercrossings crossings

    if [info exists colormap($id)] return
    set ncolors [llength $colors]
    if {$nparents($id) <= 1 && $nchildren($id) == 1} {
	set child [lindex $children($id) 0]
	if {[info exists colormap($child)]
	    && $nparents($child) == 1} {
	    set colormap($id) $colormap($child)
	    return
	}
    }
    set badcolors {}
    if {[info exists cornercrossings($id)]} {
	foreach x $cornercrossings($id) {
	    if {[info exists colormap($x)]
		&& [lsearch -exact $badcolors $colormap($x)] < 0} {
		lappend badcolors $colormap($x)
	    }
	}
	if {[llength $badcolors] >= $ncolors} {
	    set badcolors {}
	}
    }
    set origbad $badcolors
    if {[llength $badcolors] < $ncolors - 1} {
	if {[info exists crossings($id)]} {
	    foreach x $crossings($id) {
		if {[info exists colormap($x)]
		    && [lsearch -exact $badcolors $colormap($x)] < 0} {
		    lappend badcolors $colormap($x)
		}
	    }
	    if {[llength $badcolors] >= $ncolors} {
		set badcolors $origbad
	    }
	}
	set origbad $badcolors
    }
    if {[llength $badcolors] < $ncolors - 1} {
	foreach child $children($id) {
	    if {[info exists colormap($child)]
		&& [lsearch -exact $badcolors $colormap($child)] < 0} {
		lappend badcolors $colormap($child)
	    }
	    if {[info exists parents($child)]} {
		foreach p $parents($child) {
		    if {[info exists colormap($p)]
			&& [lsearch -exact $badcolors $colormap($p)] < 0} {
			lappend badcolors $colormap($p)
		    }
		}
	    }
	}
	if {[llength $badcolors] >= $ncolors} {
	    set badcolors $origbad
	}
    }
    for {set i 0} {$i <= $ncolors} {incr i} {
	set c [lindex $colors $nextcolor]
	if {[incr nextcolor] >= $ncolors} {
	    set nextcolor 0
	}
	if {[lsearch -exact $badcolors $c]} break
    }
    set colormap($id) $c
}

proc initgraph {} {
    global canvy canvy0 lineno numcommits lthickness nextcolor linespc
    global mainline sidelines
    global nchildren ncleft

    allcanvs delete all
    set nextcolor 0
    set canvy $canvy0
    set lineno -1
    set numcommits 0
    set lthickness [expr {int($linespc / 9) + 1}]
    catch {unset mainline}
    catch {unset sidelines}
    foreach id [array names nchildren] {
	set ncleft($id) $nchildren($id)
    }
}

proc bindline {t id} {
    global canv

    $canv bind $t <Enter> "lineenter %x %y $id"
    $canv bind $t <Motion> "linemotion %x %y $id"
    $canv bind $t <Leave> "lineleave $id"
    $canv bind $t <Button-1> "lineclick %x %y $id"
}

proc drawcommitline {level} {
    global parents children nparents nchildren todo
    global canv canv2 canv3 mainfont namefont canvy linespc
    global lineid linehtag linentag linedtag commitinfo
    global colormap numcommits currentparents dupparents
    global oldlevel oldnlines oldtodo
    global idtags idline idheads
    global lineno lthickness mainline sidelines
    global commitlisted rowtextx idpos

    incr numcommits
    incr lineno
    set id [lindex $todo $level]
    set lineid($lineno) $id
    set idline($id) $lineno
    set ofill [expr {[info exists commitlisted($id)]? "blue": "white"}]
    if {![info exists commitinfo($id)]} {
	readcommit $id
	if {![info exists commitinfo($id)]} {
	    set commitinfo($id) {"No commit information available"}
	    set nparents($id) 0
	}
    }
    assigncolor $id
    set currentparents {}
    set dupparents {}
    if {[info exists commitlisted($id)] && [info exists parents($id)]} {
	foreach p $parents($id) {
	    if {[lsearch -exact $currentparents $p] < 0} {
		lappend currentparents $p
	    } else {
		# remember that this parent was listed twice
		lappend dupparents $p
	    }
	}
    }
    set x [xcoord $level $level $lineno]
    set y1 $canvy
    set canvy [expr $canvy + $linespc]
    allcanvs conf -scrollregion \
	[list 0 0 0 [expr $y1 + 0.5 * $linespc + 2]]
    if {[info exists mainline($id)]} {
	lappend mainline($id) $x $y1
	set t [$canv create line $mainline($id) \
		   -width $lthickness -fill $colormap($id)]
	$canv lower $t
	bindline $t $id
    }
    if {[info exists sidelines($id)]} {
	foreach ls $sidelines($id) {
	    set coords [lindex $ls 0]
	    set thick [lindex $ls 1]
	    set t [$canv create line $coords -fill $colormap($id) \
		       -width [expr {$thick * $lthickness}]]
	    $canv lower $t
	    bindline $t $id
	}
    }
    set orad [expr {$linespc / 3}]
    set t [$canv create oval [expr $x - $orad] [expr $y1 - $orad] \
	       [expr $x + $orad - 1] [expr $y1 + $orad - 1] \
	       -fill $ofill -outline black -width 1]
    $canv raise $t
    $canv bind $t <1> {selcanvline {} %x %y}
    set xt [xcoord [llength $todo] $level $lineno]
    if {[llength $currentparents] > 2} {
	set xt [expr {$xt + ([llength $currentparents] - 2) * $linespc}]
    }
    set rowtextx($lineno) $xt
    set idpos($id) [list $x $xt $y1]
    if {[info exists idtags($id)] || [info exists idheads($id)]} {
	set xt [drawtags $id $x $xt $y1]
    }
    set headline [lindex $commitinfo($id) 0]
    set name [lindex $commitinfo($id) 1]
    set date [lindex $commitinfo($id) 2]
    set linehtag($lineno) [$canv create text $xt $y1 -anchor w \
			       -text $headline -font $mainfont ]
    $canv bind $linehtag($lineno) <Button-3> "rowmenu %X %Y $id"
    set linentag($lineno) [$canv2 create text 3 $y1 -anchor w \
			       -text $name -font $namefont]
    set linedtag($lineno) [$canv3 create text 3 $y1 -anchor w \
			       -text $date -font $mainfont]
}

proc drawtags {id x xt y1} {
    global idtags idheads
    global linespc lthickness
    global canv mainfont

    set marks {}
    set ntags 0
    if {[info exists idtags($id)]} {
	set marks $idtags($id)
	set ntags [llength $marks]
    }
    if {[info exists idheads($id)]} {
	set marks [concat $marks $idheads($id)]
    }
    if {$marks eq {}} {
	return $xt
    }

    set delta [expr {int(0.5 * ($linespc - $lthickness))}]
    set yt [expr $y1 - 0.5 * $linespc]
    set yb [expr $yt + $linespc - 1]
    set xvals {}
    set wvals {}
    foreach tag $marks {
	set wid [font measure $mainfont $tag]
	lappend xvals $xt
	lappend wvals $wid
	set xt [expr {$xt + $delta + $wid + $lthickness + $linespc}]
    }
    set t [$canv create line $x $y1 [lindex $xvals end] $y1 \
	       -width $lthickness -fill black -tags tag.$id]
    $canv lower $t
    foreach tag $marks x $xvals wid $wvals {
	set xl [expr $x + $delta]
	set xr [expr $x + $delta + $wid + $lthickness]
	if {[incr ntags -1] >= 0} {
	    # draw a tag
	    $canv create polygon $x [expr $yt + $delta] $xl $yt\
		$xr $yt $xr $yb $xl $yb $x [expr $yb - $delta] \
		-width 1 -outline black -fill yellow -tags tag.$id
	} else {
	    # draw a head
	    set xl [expr $xl - $delta/2]
	    $canv create polygon $x $yt $xr $yt $xr $yb $x $yb \
		-width 1 -outline black -fill green -tags tag.$id
	}
	$canv create text $xl $y1 -anchor w -text $tag \
	    -font $mainfont -tags tag.$id
    }
    return $xt
}

proc updatetodo {level noshortcut} {
    global currentparents ncleft todo
    global mainline oldlevel oldtodo oldnlines
    global canvy linespc mainline
    global commitinfo lineno xspc1

    set oldlevel $level
    set oldtodo $todo
    set oldnlines [llength $todo]
    if {!$noshortcut && [llength $currentparents] == 1} {
	set p [lindex $currentparents 0]
	if {$ncleft($p) == 1 && [lsearch -exact $todo $p] < 0} {
	    set ncleft($p) 0
	    set x [xcoord $level $level $lineno]
	    set y [expr $canvy - $linespc]
	    set mainline($p) [list $x $y]
	    set todo [lreplace $todo $level $level $p]
	    set xspc1([expr {$lineno + 1}]) $xspc1($lineno)
	    return 0
	}
    }

    set todo [lreplace $todo $level $level]
    set i $level
    foreach p $currentparents {
	incr ncleft($p) -1
	set k [lsearch -exact $todo $p]
	if {$k < 0} {
	    set todo [linsert $todo $i $p]
	    incr i
	}
    }
    return 1
}

proc notecrossings {id lo hi corner} {
    global oldtodo crossings cornercrossings

    for {set i $lo} {[incr i] < $hi} {} {
	set p [lindex $oldtodo $i]
	if {$p == {}} continue
	if {$i == $corner} {
	    if {![info exists cornercrossings($id)]
		|| [lsearch -exact $cornercrossings($id) $p] < 0} {
		lappend cornercrossings($id) $p
	    }
	    if {![info exists cornercrossings($p)]
		|| [lsearch -exact $cornercrossings($p) $id] < 0} {
		lappend cornercrossings($p) $id
	    }
	} else {
	    if {![info exists crossings($id)]
		|| [lsearch -exact $crossings($id) $p] < 0} {
		lappend crossings($id) $p
	    }
	    if {![info exists crossings($p)]
		|| [lsearch -exact $crossings($p) $id] < 0} {
		lappend crossings($p) $id
	    }
	}
    }
}

proc xcoord {i level ln} {
    global canvx0 xspc1 xspc2

    set x [expr {$canvx0 + $i * $xspc1($ln)}]
    if {$i > 0 && $i == $level} {
	set x [expr {$x + 0.5 * ($xspc2 - $xspc1($ln))}]
    } elseif {$i > $level} {
	set x [expr {$x + $xspc2 - $xspc1($ln)}]
    }
    return $x
}

proc drawslants {level} {
    global canv mainline sidelines canvx0 canvy xspc1 xspc2 lthickness
    global oldlevel oldtodo todo currentparents dupparents
    global lthickness linespc canvy colormap lineno geometry
    global maxgraphpct

    # decide on the line spacing for the next line
    set lj [expr {$lineno + 1}]
    set maxw [expr {$maxgraphpct * $geometry(canv1) / 100}]
    set n [llength $todo]
    if {$n <= 1 || $canvx0 + $n * $xspc2 <= $maxw} {
	set xspc1($lj) $xspc2
    } else {
	set xspc1($lj) [expr {($maxw - $canvx0 - $xspc2) / ($n - 1)}]
	if {$xspc1($lj) < $lthickness} {
	    set xspc1($lj) $lthickness
	}
    }
    
    set y1 [expr $canvy - $linespc]
    set y2 $canvy
    set i -1
    foreach id $oldtodo {
	incr i
	if {$id == {}} continue
	set xi [xcoord $i $oldlevel $lineno]
	if {$i == $oldlevel} {
	    foreach p $currentparents {
		set j [lsearch -exact $todo $p]
		set coords [list $xi $y1]
		set xj [xcoord $j $level $lj]
		if {$xj < $xi - $linespc} {
		    lappend coords [expr {$xj + $linespc}] $y1
		    notecrossings $p $j $i [expr {$j + 1}]
		} elseif {$xj > $xi + $linespc} {
		    lappend coords [expr {$xj - $linespc}] $y1
		    notecrossings $p $i $j [expr {$j - 1}]
		}
		if {[lsearch -exact $dupparents $p] >= 0} {
		    # draw a double-width line to indicate the doubled parent
		    lappend coords $xj $y2
		    lappend sidelines($p) [list $coords 2]
		    if {![info exists mainline($p)]} {
			set mainline($p) [list $xj $y2]
		    }
		} else {
		    # normal case, no parent duplicated
		    set yb $y2
		    set dx [expr {abs($xi - $xj)}]
		    if {0 && $dx < $linespc} {
			set yb [expr {$y1 + $dx}]
		    }
		    if {![info exists mainline($p)]} {
			if {$xi != $xj} {
			    lappend coords $xj $yb
			}
			set mainline($p) $coords
		    } else {
			lappend coords $xj $yb
			if {$yb < $y2} {
			    lappend coords $xj $y2
			}
			lappend sidelines($p) [list $coords 1]
		    }
		}
	    }
	} else {
	    set j $i
	    if {[lindex $todo $i] != $id} {
		set j [lsearch -exact $todo $id]
	    }
	    if {$j != $i || $xspc1($lineno) != $xspc1($lj)
		|| ($oldlevel <= $i && $i <= $level)
		|| ($level <= $i && $i <= $oldlevel)} {
		set xj [xcoord $j $level $lj]
		set dx [expr {abs($xi - $xj)}]
		set yb $y2
		if {0 && $dx < $linespc} {
		    set yb [expr {$y1 + $dx}]
		}
		lappend mainline($id) $xi $y1 $xj $yb
	    }
	}
    }
}

proc decidenext {{noread 0}} {
    global parents children nchildren ncleft todo
    global canv canv2 canv3 mainfont namefont canvy linespc
    global datemode cdate
    global commitinfo
    global currentparents oldlevel oldnlines oldtodo
    global lineno lthickness

    # remove the null entry if present
    set nullentry [lsearch -exact $todo {}]
    if {$nullentry >= 0} {
	set todo [lreplace $todo $nullentry $nullentry]
    }

    # choose which one to do next time around
    set todol [llength $todo]
    set level -1
    set latest {}
    for {set k $todol} {[incr k -1] >= 0} {} {
	set p [lindex $todo $k]
	if {$ncleft($p) == 0} {
	    if {$datemode} {
		if {![info exists commitinfo($p)]} {
		    if {$noread} {
			return {}
		    }
		    readcommit $p
		}
		if {$latest == {} || $cdate($p) > $latest} {
		    set level $k
		    set latest $cdate($p)
		}
	    } else {
		set level $k
		break
	    }
	}
    }
    if {$level < 0} {
	if {$todo != {}} {
	    puts "ERROR: none of the pending commits can be done yet:"
	    foreach p $todo {
		puts "  $p ($ncleft($p))"
	    }
	}
	return -1
    }

    # If we are reducing, put in a null entry
    if {$todol < $oldnlines} {
	if {$nullentry >= 0} {
	    set i $nullentry
	    while {$i < $todol
		   && [lindex $oldtodo $i] == [lindex $todo $i]} {
		incr i
	    }
	} else {
	    set i $oldlevel
	    if {$level >= $i} {
		incr i
	    }
	}
	if {$i < $todol} {
	    set todo [linsert $todo $i {}]
	    if {$level >= $i} {
		incr level
	    }
	}
    }
    return $level
}

proc drawcommit {id} {
    global phase todo nchildren datemode nextupdate
    global startcommits

    if {$phase != "incrdraw"} {
	set phase incrdraw
	set todo $id
	set startcommits $id
	initgraph
	drawcommitline 0
	updatetodo 0 $datemode
    } else {
	if {$nchildren($id) == 0} {
	    lappend todo $id
	    lappend startcommits $id
	}
	set level [decidenext 1]
	if {$level == {} || $id != [lindex $todo $level]} {
	    return
	}
	while 1 {
	    drawslants $level
	    drawcommitline $level
	    if {[updatetodo $level $datemode]} {
		set level [decidenext 1]
		if {$level == {}} break
	    }
	    set id [lindex $todo $level]
	    if {![info exists commitlisted($id)]} {
		break
	    }
	    if {[clock clicks -milliseconds] >= $nextupdate} {
		doupdate
		if {$stopped} break
	    }
	}
    }
}

proc finishcommits {} {
    global phase
    global startcommits
    global canv mainfont ctext maincursor textcursor

    if {$phase != "incrdraw"} {
	$canv delete all
	$canv create text 3 3 -anchor nw -text "No commits selected" \
	    -font $mainfont -tags textitems
	set phase {}
    } else {
	set level [decidenext]
	drawslants $level
	drawrest $level [llength $startcommits]
    }
    . config -cursor $maincursor
    settextcursor $textcursor
}

# Don't change the text pane cursor if it is currently the hand cursor,
# showing that we are over a sha1 ID link.
proc settextcursor {c} {
    global ctext curtextcursor

    if {[$ctext cget -cursor] == $curtextcursor} {
	$ctext config -cursor $c
    }
    set curtextcursor $c
}

proc drawgraph {} {
    global nextupdate startmsecs startcommits todo

    if {$startcommits == {}} return
    set startmsecs [clock clicks -milliseconds]
    set nextupdate [expr $startmsecs + 100]
    initgraph
    set todo [lindex $startcommits 0]
    drawrest 0 1
}

proc drawrest {level startix} {
    global phase stopped redisplaying selectedline
    global datemode currentparents todo
    global numcommits
    global nextupdate startmsecs startcommits idline

    if {$level >= 0} {
	set phase drawgraph
	set startid [lindex $startcommits $startix]
	set startline -1
	if {$startid != {}} {
	    set startline $idline($startid)
	}
	while 1 {
	    if {$stopped} break
	    drawcommitline $level
	    set hard [updatetodo $level $datemode]
	    if {$numcommits == $startline} {
		lappend todo $startid
		set hard 1
		incr startix
		set startid [lindex $startcommits $startix]
		set startline -1
		if {$startid != {}} {
		    set startline $idline($startid)
		}
	    }
	    if {$hard} {
		set level [decidenext]
		if {$level < 0} break
		drawslants $level
	    }
	    if {[clock clicks -milliseconds] >= $nextupdate} {
		update
		incr nextupdate 100
	    }
	}
    }
    set phase {}
    set drawmsecs [expr [clock clicks -milliseconds] - $startmsecs]
    #puts "overall $drawmsecs ms for $numcommits commits"
    if {$redisplaying} {
	if {$stopped == 0 && [info exists selectedline]} {
	    selectline $selectedline 0
	}
	if {$stopped == 1} {
	    set stopped 0
	    after idle drawgraph
	} else {
	    set redisplaying 0
	}
    }
}

proc findmatches {f} {
    global findtype foundstring foundstrlen
    if {$findtype == "Regexp"} {
	set matches [regexp -indices -all -inline $foundstring $f]
    } else {
	if {$findtype == "IgnCase"} {
	    set str [string tolower $f]
	} else {
	    set str $f
	}
	set matches {}
	set i 0
	while {[set j [string first $foundstring $str $i]] >= 0} {
	    lappend matches [list $j [expr $j+$foundstrlen-1]]
	    set i [expr $j + $foundstrlen]
	}
    }
    return $matches
}

proc dofind {} {
    global findtype findloc findstring markedmatches commitinfo
    global numcommits lineid linehtag linentag linedtag
    global mainfont namefont canv canv2 canv3 selectedline
    global matchinglines foundstring foundstrlen

    stopfindproc
    unmarkmatches
    focus .
    set matchinglines {}
    if {$findloc == "Pickaxe"} {
	findpatches
	return
    }
    if {$findtype == "IgnCase"} {
	set foundstring [string tolower $findstring]
    } else {
	set foundstring $findstring
    }
    set foundstrlen [string length $findstring]
    if {$foundstrlen == 0} return
    if {$findloc == "Files"} {
	findfiles
	return
    }
    if {![info exists selectedline]} {
	set oldsel -1
    } else {
	set oldsel $selectedline
    }
    set didsel 0
    set fldtypes {Headline Author Date Committer CDate Comment}
    for {set l 0} {$l < $numcommits} {incr l} {
	set id $lineid($l)
	set info $commitinfo($id)
	set doesmatch 0
	foreach f $info ty $fldtypes {
	    if {$findloc != "All fields" && $findloc != $ty} {
		continue
	    }
	    set matches [findmatches $f]
	    if {$matches == {}} continue
	    set doesmatch 1
	    if {$ty == "Headline"} {
		markmatches $canv $l $f $linehtag($l) $matches $mainfont
	    } elseif {$ty == "Author"} {
		markmatches $canv2 $l $f $linentag($l) $matches $namefont
	    } elseif {$ty == "Date"} {
		markmatches $canv3 $l $f $linedtag($l) $matches $mainfont
	    }
	}
	if {$doesmatch} {
	    lappend matchinglines $l
	    if {!$didsel && $l > $oldsel} {
		findselectline $l
		set didsel 1
	    }
	}
    }
    if {$matchinglines == {}} {
	bell
    } elseif {!$didsel} {
	findselectline [lindex $matchinglines 0]
    }
}

proc findselectline {l} {
    global findloc commentend ctext
    selectline $l 1
    if {$findloc == "All fields" || $findloc == "Comments"} {
	# highlight the matches in the comments
	set f [$ctext get 1.0 $commentend]
	set matches [findmatches $f]
	foreach match $matches {
	    set start [lindex $match 0]
	    set end [expr [lindex $match 1] + 1]
	    $ctext tag add found "1.0 + $start c" "1.0 + $end c"
	}
    }
}

proc findnext {restart} {
    global matchinglines selectedline
    if {![info exists matchinglines]} {
	if {$restart} {
	    dofind
	}
	return
    }
    if {![info exists selectedline]} return
    foreach l $matchinglines {
	if {$l > $selectedline} {
	    findselectline $l
	    return
	}
    }
    bell
}

proc findprev {} {
    global matchinglines selectedline
    if {![info exists matchinglines]} {
	dofind
	return
    }
    if {![info exists selectedline]} return
    set prev {}
    foreach l $matchinglines {
	if {$l >= $selectedline} break
	set prev $l
    }
    if {$prev != {}} {
	findselectline $prev
    } else {
	bell
    }
}

proc findlocchange {name ix op} {
    global findloc findtype findtypemenu
    if {$findloc == "Pickaxe"} {
	set findtype Exact
	set state disabled
    } else {
	set state normal
    }
    $findtypemenu entryconf 1 -state $state
    $findtypemenu entryconf 2 -state $state
}

proc stopfindproc {{done 0}} {
    global findprocpid findprocfile findids
    global ctext findoldcursor phase maincursor textcursor
    global findinprogress

    catch {unset findids}
    if {[info exists findprocpid]} {
	if {!$done} {
	    catch {exec kill $findprocpid}
	}
	catch {close $findprocfile}
	unset findprocpid
    }
    if {[info exists findinprogress]} {
	unset findinprogress
	if {$phase != "incrdraw"} {
	    . config -cursor $maincursor
	    settextcursor $textcursor
	}
    }
}

proc findpatches {} {
    global findstring selectedline numcommits
    global findprocpid findprocfile
    global finddidsel ctext lineid findinprogress
    global findinsertpos

    if {$numcommits == 0} return

    # make a list of all the ids to search, starting at the one
    # after the selected line (if any)
    if {[info exists selectedline]} {
	set l $selectedline
    } else {
	set l -1
    }
    set inputids {}
    for {set i 0} {$i < $numcommits} {incr i} {
	if {[incr l] >= $numcommits} {
	    set l 0
	}
	append inputids $lineid($l) "\n"
    }

    if {[catch {
	set f [open [list | git-diff-tree --stdin -s -r -S$findstring \
			 << $inputids] r]
    } err]} {
	error_popup "Error starting search process: $err"
	return
    }

    set findinsertpos end
    set findprocfile $f
    set findprocpid [pid $f]
    fconfigure $f -blocking 0
    fileevent $f readable readfindproc
    set finddidsel 0
    . config -cursor watch
    settextcursor watch
    set findinprogress 1
}

proc readfindproc {} {
    global findprocfile finddidsel
    global idline matchinglines findinsertpos

    set n [gets $findprocfile line]
    if {$n < 0} {
	if {[eof $findprocfile]} {
	    stopfindproc 1
	    if {!$finddidsel} {
		bell
	    }
	}
	return
    }
    if {![regexp {^[0-9a-f]{40}} $line id]} {
	error_popup "Can't parse git-diff-tree output: $line"
	stopfindproc
	return
    }
    if {![info exists idline($id)]} {
	puts stderr "spurious id: $id"
	return
    }
    set l $idline($id)
    insertmatch $l $id
}

proc insertmatch {l id} {
    global matchinglines findinsertpos finddidsel

    if {$findinsertpos == "end"} {
	if {$matchinglines != {} && $l < [lindex $matchinglines 0]} {
	    set matchinglines [linsert $matchinglines 0 $l]
	    set findinsertpos 1
	} else {
	    lappend matchinglines $l
	}
    } else {
	set matchinglines [linsert $matchinglines $findinsertpos $l]
	incr findinsertpos
    }
    markheadline $l $id
    if {!$finddidsel} {
	findselectline $l
	set finddidsel 1
    }
}

proc findfiles {} {
    global selectedline numcommits lineid ctext
    global ffileline finddidsel parents nparents
    global findinprogress findstartline findinsertpos
    global treediffs fdiffids fdiffsneeded fdiffpos
    global findmergefiles

    if {$numcommits == 0} return

    if {[info exists selectedline]} {
	set l [expr {$selectedline + 1}]
    } else {
	set l 0
    }
    set ffileline $l
    set findstartline $l
    set diffsneeded {}
    set fdiffsneeded {}
    while 1 {
	set id $lineid($l)
	if {$findmergefiles || $nparents($id) == 1} {
	    foreach p $parents($id) {
		if {![info exists treediffs([list $id $p])]} {
		    append diffsneeded "$id $p\n"
		    lappend fdiffsneeded [list $id $p]
		}
	    }
	}
	if {[incr l] >= $numcommits} {
	    set l 0
	}
	if {$l == $findstartline} break
    }

    # start off a git-diff-tree process if needed
    if {$diffsneeded ne {}} {
	if {[catch {
	    set df [open [list | git-diff-tree -r --stdin << $diffsneeded] r]
	} err ]} {
	    error_popup "Error starting search process: $err"
	    return
	}
	catch {unset fdiffids}
	set fdiffpos 0
	fconfigure $df -blocking 0
	fileevent $df readable [list readfilediffs $df]
    }

    set finddidsel 0
    set findinsertpos end
    set id $lineid($l)
    set p [lindex $parents($id) 0]
    . config -cursor watch
    settextcursor watch
    set findinprogress 1
    findcont [list $id $p]
    update
}

proc readfilediffs {df} {
    global findids fdiffids fdiffs

    set n [gets $df line]
    if {$n < 0} {
	if {[eof $df]} {
	    donefilediff
	    if {[catch {close $df} err]} {
		stopfindproc
		bell
		error_popup "Error in git-diff-tree: $err"
	    } elseif {[info exists findids]} {
		set ids $findids
		stopfindproc
		bell
		error_popup "Couldn't find diffs for {$ids}"
	    }
	}
	return
    }
    if {[regexp {^([0-9a-f]{40}) \(from ([0-9a-f]{40})\)} $line match id p]} {
	# start of a new string of diffs
	donefilediff
	set fdiffids [list $id $p]
	set fdiffs {}
    } elseif {[string match ":*" $line]} {
	lappend fdiffs [lindex $line 5]
    }
}

proc donefilediff {} {
    global fdiffids fdiffs treediffs findids
    global fdiffsneeded fdiffpos

    if {[info exists fdiffids]} {
	while {[lindex $fdiffsneeded $fdiffpos] ne $fdiffids
	       && $fdiffpos < [llength $fdiffsneeded]} {
	    # git-diff-tree doesn't output anything for a commit
	    # which doesn't change anything
	    set nullids [lindex $fdiffsneeded $fdiffpos]
	    set treediffs($nullids) {}
	    if {[info exists findids] && $nullids eq $findids} {
		unset findids
		findcont $nullids
	    }
	    incr fdiffpos
	}
	incr fdiffpos

	if {![info exists treediffs($fdiffids)]} {
	    set treediffs($fdiffids) $fdiffs
	}
	if {[info exists findids] && $fdiffids eq $findids} {
	    unset findids
	    findcont $fdiffids
	}
    }
}

proc findcont {ids} {
    global findids treediffs parents nparents
    global ffileline findstartline finddidsel
    global lineid numcommits matchinglines findinprogress
    global findmergefiles

    set id [lindex $ids 0]
    set p [lindex $ids 1]
    set pi [lsearch -exact $parents($id) $p]
    set l $ffileline
    while 1 {
	if {$findmergefiles || $nparents($id) == 1} {
	    if {![info exists treediffs($ids)]} {
		set findids $ids
		set ffileline $l
		return
	    }
	    set doesmatch 0
	    foreach f $treediffs($ids) {
		set x [findmatches $f]
		if {$x != {}} {
		    set doesmatch 1
		    break
		}
	    }
	    if {$doesmatch} {
		insertmatch $l $id
		set pi $nparents($id)
	    }
	} else {
	    set pi $nparents($id)
	}
	if {[incr pi] >= $nparents($id)} {
	    set pi 0
	    if {[incr l] >= $numcommits} {
		set l 0
	    }
	    if {$l == $findstartline} break
	    set id $lineid($l)
	}
	set p [lindex $parents($id) $pi]
	set ids [list $id $p]
    }
    stopfindproc
    if {!$finddidsel} {
	bell
    }
}

# mark a commit as matching by putting a yellow background
# behind the headline
proc markheadline {l id} {
    global canv mainfont linehtag commitinfo

    set bbox [$canv bbox $linehtag($l)]
    set t [$canv create rect $bbox -outline {} -tags matches -fill yellow]
    $canv lower $t
}

# mark the bits of a headline, author or date that match a find string
proc markmatches {canv l str tag matches font} {
    set bbox [$canv bbox $tag]
    set x0 [lindex $bbox 0]
    set y0 [lindex $bbox 1]
    set y1 [lindex $bbox 3]
    foreach match $matches {
	set start [lindex $match 0]
	set end [lindex $match 1]
	if {$start > $end} continue
	set xoff [font measure $font [string range $str 0 [expr $start-1]]]
	set xlen [font measure $font [string range $str 0 [expr $end]]]
	set t [$canv create rect [expr $x0+$xoff] $y0 [expr $x0+$xlen+2] $y1 \
		   -outline {} -tags matches -fill yellow]
	$canv lower $t
    }
}

proc unmarkmatches {} {
    global matchinglines findids
    allcanvs delete matches
    catch {unset matchinglines}
    catch {unset findids}
}

proc selcanvline {w x y} {
    global canv canvy0 ctext linespc selectedline
    global lineid linehtag linentag linedtag rowtextx
    set ymax [lindex [$canv cget -scrollregion] 3]
    if {$ymax == {}} return
    set yfrac [lindex [$canv yview] 0]
    set y [expr {$y + $yfrac * $ymax}]
    set l [expr {int(($y - $canvy0) / $linespc + 0.5)}]
    if {$l < 0} {
	set l 0
    }
    if {$w eq $canv} {
	if {![info exists rowtextx($l)] || $x < $rowtextx($l)} return
    }
    unmarkmatches
    selectline $l 1
}

proc selectline {l isnew} {
    global canv canv2 canv3 ctext commitinfo selectedline
    global lineid linehtag linentag linedtag
    global canvy0 linespc parents nparents
    global cflist currentid sha1entry
    global commentend idtags idline
    global history historyindex

    $canv delete hover
    if {![info exists lineid($l)] || ![info exists linehtag($l)]} return
    $canv delete secsel
    set t [eval $canv create rect [$canv bbox $linehtag($l)] -outline {{}} \
	       -tags secsel -fill [$canv cget -selectbackground]]
    $canv lower $t
    $canv2 delete secsel
    set t [eval $canv2 create rect [$canv2 bbox $linentag($l)] -outline {{}} \
	       -tags secsel -fill [$canv2 cget -selectbackground]]
    $canv2 lower $t
    $canv3 delete secsel
    set t [eval $canv3 create rect [$canv3 bbox $linedtag($l)] -outline {{}} \
	       -tags secsel -fill [$canv3 cget -selectbackground]]
    $canv3 lower $t
    set y [expr {$canvy0 + $l * $linespc}]
    set ymax [lindex [$canv cget -scrollregion] 3]
    set ytop [expr {$y - $linespc - 1}]
    set ybot [expr {$y + $linespc + 1}]
    set wnow [$canv yview]
    set wtop [expr [lindex $wnow 0] * $ymax]
    set wbot [expr [lindex $wnow 1] * $ymax]
    set wh [expr {$wbot - $wtop}]
    set newtop $wtop
    if {$ytop < $wtop} {
	if {$ybot < $wtop} {
	    set newtop [expr {$y - $wh / 2.0}]
	} else {
	    set newtop $ytop
	    if {$newtop > $wtop - $linespc} {
		set newtop [expr {$wtop - $linespc}]
	    }
	}
    } elseif {$ybot > $wbot} {
	if {$ytop > $wbot} {
	    set newtop [expr {$y - $wh / 2.0}]
	} else {
	    set newtop [expr {$ybot - $wh}]
	    if {$newtop < $wtop + $linespc} {
		set newtop [expr {$wtop + $linespc}]
	    }
	}
    }
    if {$newtop != $wtop} {
	if {$newtop < 0} {
	    set newtop 0
	}
	allcanvs yview moveto [expr $newtop * 1.0 / $ymax]
    }

    if {$isnew && (![info exists selectedline] || $selectedline != $l)} {
	if {$historyindex < [llength $history]} {
	    set history [lreplace $history $historyindex end $l]
	} else {
	    lappend history $l
	}
	incr historyindex
	if {$historyindex > 1} {
	    .ctop.top.bar.leftbut conf -state normal
	} else {
	    .ctop.top.bar.leftbut conf -state disabled
	}
	.ctop.top.bar.rightbut conf -state disabled
    }

    set selectedline $l

    set id $lineid($l)
    set currentid $id
    $sha1entry delete 0 end
    $sha1entry insert 0 $id
    $sha1entry selection from 0
    $sha1entry selection to end

    $ctext conf -state normal
    $ctext delete 0.0 end
    $ctext mark set fmark.0 0.0
    $ctext mark gravity fmark.0 left
    set info $commitinfo($id)
    $ctext insert end "Author: [lindex $info 1]  [lindex $info 2]\n"
    $ctext insert end "Committer: [lindex $info 3]  [lindex $info 4]\n"
    if {[info exists idtags($id)]} {
	$ctext insert end "Tags:"
	foreach tag $idtags($id) {
	    $ctext insert end " $tag"
	}
	$ctext insert end "\n"
    }
 
    set commentstart [$ctext index "end - 1c"]
    set comment {}
    foreach p $parents($id) {
	set l "..."
	if {[info exists commitinfo($p)]} {
	    set l [lindex $commitinfo($p) 0]
	    if {[string length $l] > 32} {
		set l "[string range $l 0 28] ..."
	    }
	}
	append comment "Parent: $p  ($l)\n"
    }
    append comment "\n"
    append comment [lindex $info 5]
    $ctext insert end $comment
    $ctext insert end "\n"

    # make anything that looks like a SHA1 ID be a clickable link
    set links [regexp -indices -all -inline {[0-9a-f]{40}} $comment]
    set i 0
    foreach l $links {
	set s [lindex $l 0]
	set e [lindex $l 1]
	set linkid [string range $comment $s $e]
	if {![info exists idline($linkid)]} continue
	incr e
	$ctext tag add link "$commentstart + $s c" "$commentstart + $e c"
	$ctext tag add link$i "$commentstart + $s c" "$commentstart + $e c"
	$ctext tag bind link$i <1> [list selectline $idline($linkid) 1]
	incr i
    }
    $ctext tag conf link -foreground blue -underline 1
    $ctext tag bind link <Enter> { %W configure -cursor hand2 }
    $ctext tag bind link <Leave> { %W configure -cursor $curtextcursor }

    $ctext tag delete Comments
    $ctext tag remove found 1.0 end
    $ctext conf -state disabled
    set commentend [$ctext index "end - 1c"]

    $cflist delete 0 end
    $cflist insert end "Comments"
    if {$nparents($id) == 1} {
	startdiff [concat $id $parents($id)]
    } elseif {$nparents($id) > 1} {
	mergediff $id
    }
}

proc selnextline {dir} {
    global selectedline
    if {![info exists selectedline]} return
    set l [expr $selectedline + $dir]
    unmarkmatches
    selectline $l 1
}

proc goback {} {
    global history historyindex

    if {$historyindex > 1} {
	incr historyindex -1
	selectline [lindex $history [expr {$historyindex - 1}]] 0
	.ctop.top.bar.rightbut conf -state normal
    }
    if {$historyindex <= 1} {
	.ctop.top.bar.leftbut conf -state disabled
    }
}

proc goforw {} {
    global history historyindex

    if {$historyindex < [llength $history]} {
	set l [lindex $history $historyindex]
	incr historyindex
	selectline $l 0
	.ctop.top.bar.leftbut conf -state normal
    }
    if {$historyindex >= [llength $history]} {
	.ctop.top.bar.rightbut conf -state disabled
    }
}

proc mergediff {id} {
    global parents diffmergeid diffmergegca mergefilelist diffpindex

    set diffmergeid $id
    set diffpindex -1
    set diffmergegca [findgca $parents($id)]
    if {[info exists mergefilelist($id)]} {
	if {$mergefilelist($id) ne {}} {
	    showmergediff
	}
    } else {
	contmergediff {}
    }
}

proc findgca {ids} {
    set gca {}
    foreach id $ids {
	if {$gca eq {}} {
	    set gca $id
	} else {
	    if {[catch {
		set gca [exec git-merge-base $gca $id]
	    } err]} {
		return {}
	    }
	}
    }
    return $gca
}

proc contmergediff {ids} {
    global diffmergeid diffpindex parents nparents diffmergegca
    global treediffs mergefilelist diffids treepending

    # diff the child against each of the parents, and diff
    # each of the parents against the GCA.
    while 1 {
	if {[lindex $ids 0] == $diffmergeid && $diffmergegca ne {}} {
	    set ids [list [lindex $ids 1] $diffmergegca]
	} else {
	    if {[incr diffpindex] >= $nparents($diffmergeid)} break
	    set p [lindex $parents($diffmergeid) $diffpindex]
	    set ids [list $diffmergeid $p]
	}
	if {![info exists treediffs($ids)]} {
	    set diffids $ids
	    if {![info exists treepending]} {
		gettreediffs $ids
	    }
	    return
	}
    }

    # If a file in some parent is different from the child and also
    # different from the GCA, then it's interesting.
    # If we don't have a GCA, then a file is interesting if it is
    # different from the child in all the parents.
    if {$diffmergegca ne {}} {
	set files {}
	foreach p $parents($diffmergeid) {
	    set gcadiffs $treediffs([list $p $diffmergegca])
	    foreach f $treediffs([list $diffmergeid $p]) {
		if {[lsearch -exact $files $f] < 0
		    && [lsearch -exact $gcadiffs $f] >= 0} {
		    lappend files $f
		}
	    }
	}
	set files [lsort $files]
    } else {
	set p [lindex $parents($diffmergeid) 0]
	set files $treediffs([list $diffmergeid $p])
	for {set i 1} {$i < $nparents($diffmergeid) && $files ne {}} {incr i} {
	    set p [lindex $parents($diffmergeid) $i]
	    set df $treediffs([list $diffmergeid $p])
	    set nf {}
	    foreach f $files {
		if {[lsearch -exact $df $f] >= 0} {
		    lappend nf $f
		}
	    }
	    set files $nf
	}
    }

    set mergefilelist($diffmergeid) $files
    if {$files ne {}} {
	showmergediff
    }
}

proc showmergediff {} {
    global cflist diffmergeid mergefilelist parents
    global diffopts diffinhunk currentfile currenthunk filelines
    global diffblocked groupfilelast mergefds groupfilenum grouphunks

    set files $mergefilelist($diffmergeid)
    foreach f $files {
	$cflist insert end $f
    }
    set env(GIT_DIFF_OPTS) $diffopts
    set flist {}
    catch {unset currentfile}
    catch {unset currenthunk}
    catch {unset filelines}
    catch {unset groupfilenum}
    catch {unset grouphunks}
    set groupfilelast -1
    foreach p $parents($diffmergeid) {
	set cmd [list | git-diff-tree -p $p $diffmergeid]
	set cmd [concat $cmd $mergefilelist($diffmergeid)]
	if {[catch {set f [open $cmd r]} err]} {
	    error_popup "Error getting diffs: $err"
	    foreach f $flist {
		catch {close $f}
	    }
	    return
	}
	lappend flist $f
	set ids [list $diffmergeid $p]
	set mergefds($ids) $f
	set diffinhunk($ids) 0
	set diffblocked($ids) 0
	fconfigure $f -blocking 0
	fileevent $f readable [list getmergediffline $f $ids $diffmergeid]
    }
}

proc getmergediffline {f ids id} {
    global diffmergeid diffinhunk diffoldlines diffnewlines
    global currentfile currenthunk
    global diffoldstart diffnewstart diffoldlno diffnewlno
    global diffblocked mergefilelist
    global noldlines nnewlines difflcounts filelines

    set n [gets $f line]
    if {$n < 0} {
	if {![eof $f]} return
    }

    if {!([info exists diffmergeid] && $diffmergeid == $id)} {
	if {$n < 0} {
	    close $f
	}
	return
    }

    if {$diffinhunk($ids) != 0} {
	set fi $currentfile($ids)
	if {$n > 0 && [regexp {^[-+ \\]} $line match]} {
	    # continuing an existing hunk
	    set line [string range $line 1 end]
	    set p [lindex $ids 1]
	    if {$match eq "-" || $match eq " "} {
		set filelines($p,$fi,$diffoldlno($ids)) $line
		incr diffoldlno($ids)
	    }
	    if {$match eq "+" || $match eq " "} {
		set filelines($id,$fi,$diffnewlno($ids)) $line
		incr diffnewlno($ids)
	    }
	    if {$match eq " "} {
		if {$diffinhunk($ids) == 2} {
		    lappend difflcounts($ids) \
			[list $noldlines($ids) $nnewlines($ids)]
		    set noldlines($ids) 0
		    set diffinhunk($ids) 1
		}
		incr noldlines($ids)
	    } elseif {$match eq "-" || $match eq "+"} {
		if {$diffinhunk($ids) == 1} {
		    lappend difflcounts($ids) [list $noldlines($ids)]
		    set noldlines($ids) 0
		    set nnewlines($ids) 0
		    set diffinhunk($ids) 2
		}
		if {$match eq "-"} {
		    incr noldlines($ids)
		} else {
		    incr nnewlines($ids)
		}
	    }
	    # and if it's \ No newline at end of line, then what?
	    return
	}
	# end of a hunk
	if {$diffinhunk($ids) == 1 && $noldlines($ids) != 0} {
	    lappend difflcounts($ids) [list $noldlines($ids)]
	} elseif {$diffinhunk($ids) == 2
		  && ($noldlines($ids) != 0 || $nnewlines($ids) != 0)} {
	    lappend difflcounts($ids) [list $noldlines($ids) $nnewlines($ids)]
	}
	set currenthunk($ids) [list $currentfile($ids) \
				   $diffoldstart($ids) $diffnewstart($ids) \
				   $diffoldlno($ids) $diffnewlno($ids) \
				   $difflcounts($ids)]
	set diffinhunk($ids) 0
	# -1 = need to block, 0 = unblocked, 1 = is blocked
	set diffblocked($ids) -1
	processhunks
	if {$diffblocked($ids) == -1} {
	    fileevent $f readable {}
	    set diffblocked($ids) 1
	}
    }

    if {$n < 0} {
	# eof
	if {!$diffblocked($ids)} {
	    close $f
	    set currentfile($ids) [llength $mergefilelist($diffmergeid)]
	    set currenthunk($ids) [list $currentfile($ids) 0 0 0 0 {}]
	    processhunks
	}
    } elseif {[regexp {^diff --git a/(.*) b/} $line match fname]} {
	# start of a new file
	set currentfile($ids) \
	    [lsearch -exact $mergefilelist($diffmergeid) $fname]
    } elseif {[regexp {^@@ -([0-9]+),([0-9]+) \+([0-9]+),([0-9]+) @@(.*)} \
		   $line match f1l f1c f2l f2c rest]} {
	if {[info exists currentfile($ids)] && $currentfile($ids) >= 0} {
	    # start of a new hunk
	    if {$f1l == 0 && $f1c == 0} {
		set f1l 1
	    }
	    if {$f2l == 0 && $f2c == 0} {
		set f2l 1
	    }
	    set diffinhunk($ids) 1
	    set diffoldstart($ids) $f1l
	    set diffnewstart($ids) $f2l
	    set diffoldlno($ids) $f1l
	    set diffnewlno($ids) $f2l
	    set difflcounts($ids) {}
	    set noldlines($ids) 0
	    set nnewlines($ids) 0
	}
    }
}

proc processhunks {} {
    global diffmergeid parents nparents currenthunk
    global mergefilelist diffblocked mergefds
    global grouphunks grouplinestart grouplineend groupfilenum

    set nfiles [llength $mergefilelist($diffmergeid)]
    while 1 {
	set fi $nfiles
	set lno 0
	# look for the earliest hunk
	foreach p $parents($diffmergeid) {
	    set ids [list $diffmergeid $p]
	    if {![info exists currenthunk($ids)]} return
	    set i [lindex $currenthunk($ids) 0]
	    set l [lindex $currenthunk($ids) 2]
	    if {$i < $fi || ($i == $fi && $l < $lno)} {
		set fi $i
		set lno $l
		set pi $p
	    }
	}

	if {$fi < $nfiles} {
	    set ids [list $diffmergeid $pi]
	    set hunk $currenthunk($ids)
	    unset currenthunk($ids)
	    if {$diffblocked($ids) > 0} {
		fileevent $mergefds($ids) readable \
		    [list getmergediffline $mergefds($ids) $ids $diffmergeid]
	    }
	    set diffblocked($ids) 0

	    if {[info exists groupfilenum] && $groupfilenum == $fi
		&& $lno <= $grouplineend} {
		# add this hunk to the pending group
		lappend grouphunks($pi) $hunk
		set endln [lindex $hunk 4]
		if {$endln > $grouplineend} {
		    set grouplineend $endln
		}
		continue
	    }
	}

	# succeeding stuff doesn't belong in this group, so
	# process the group now
	if {[info exists groupfilenum]} {
	    processgroup
	    unset groupfilenum
	    unset grouphunks
	}

	if {$fi >= $nfiles} break

	# start a new group
	set groupfilenum $fi
	set grouphunks($pi) [list $hunk]
	set grouplinestart $lno
	set grouplineend [lindex $hunk 4]
    }
}

proc processgroup {} {
    global groupfilelast groupfilenum difffilestart
    global mergefilelist diffmergeid ctext filelines
    global parents diffmergeid diffoffset
    global grouphunks grouplinestart grouplineend nparents
    global mergemax

    $ctext conf -state normal
    set id $diffmergeid
    set f $groupfilenum
    if {$groupfilelast != $f} {
	$ctext insert end "\n"
	set here [$ctext index "end - 1c"]
	set difffilestart($f) $here
	set mark fmark.[expr {$f + 1}]
	$ctext mark set $mark $here
	$ctext mark gravity $mark left
	set header [lindex $mergefilelist($id) $f]
	set l [expr {(78 - [string length $header]) / 2}]
	set pad [string range "----------------------------------------" 1 $l]
	$ctext insert end "$pad $header $pad\n" filesep
	set groupfilelast $f
	foreach p $parents($id) {
	    set diffoffset($p) 0
	}
    }

    $ctext insert end "@@" msep
    set nlines [expr {$grouplineend - $grouplinestart}]
    set events {}
    set pnum 0
    foreach p $parents($id) {
	set startline [expr {$grouplinestart + $diffoffset($p)}]
	set ol $startline
	set nl $grouplinestart
	if {[info exists grouphunks($p)]} {
	    foreach h $grouphunks($p) {
		set l [lindex $h 2]
		if {$nl < $l} {
		    for {} {$nl < $l} {incr nl} {
			set filelines($p,$f,$ol) $filelines($id,$f,$nl)
			incr ol
		    }
		}
		foreach chunk [lindex $h 5] {
		    if {[llength $chunk] == 2} {
			set olc [lindex $chunk 0]
			set nlc [lindex $chunk 1]
			set nnl [expr {$nl + $nlc}]
			lappend events [list $nl $nnl $pnum $olc $nlc]
			incr ol $olc
			set nl $nnl
		    } else {
			incr ol [lindex $chunk 0]
			incr nl [lindex $chunk 0]
		    }
		}
	    }
	}
	if {$nl < $grouplineend} {
	    for {} {$nl < $grouplineend} {incr nl} {
		set filelines($p,$f,$ol) $filelines($id,$f,$nl)
		incr ol
	    }
	}
	set nlines [expr {$ol - $startline}]
	$ctext insert end " -$startline,$nlines" msep
	incr pnum
    }

    set nlines [expr {$grouplineend - $grouplinestart}]
    $ctext insert end " +$grouplinestart,$nlines @@\n" msep

    set events [lsort -integer -index 0 $events]
    set nevents [llength $events]
    set nmerge $nparents($diffmergeid)
    set l $grouplinestart
    for {set i 0} {$i < $nevents} {set i $j} {
	set nl [lindex $events $i 0]
	while {$l < $nl} {
	    $ctext insert end " $filelines($id,$f,$l)\n"
	    incr l
	}
	set e [lindex $events $i]
	set enl [lindex $e 1]
	set j $i
	set active {}
	while 1 {
	    set pnum [lindex $e 2]
	    set olc [lindex $e 3]
	    set nlc [lindex $e 4]
	    if {![info exists delta($pnum)]} {
		set delta($pnum) [expr {$olc - $nlc}]
		lappend active $pnum
	    } else {
		incr delta($pnum) [expr {$olc - $nlc}]
	    }
	    if {[incr j] >= $nevents} break
	    set e [lindex $events $j]
	    if {[lindex $e 0] >= $enl} break
	    if {[lindex $e 1] > $enl} {
		set enl [lindex $e 1]
	    }
	}
	set nlc [expr {$enl - $l}]
	set ncol mresult
	set bestpn -1
	if {[llength $active] == $nmerge - 1} {
	    # no diff for one of the parents, i.e. it's identical
	    for {set pnum 0} {$pnum < $nmerge} {incr pnum} {
		if {![info exists delta($pnum)]} {
		    if {$pnum < $mergemax} {
			lappend ncol m$pnum
		    } else {
			lappend ncol mmax
		    }
		    break
		}
	    }
	} elseif {[llength $active] == $nmerge} {
	    # all parents are different, see if one is very similar
	    set bestsim 30
	    for {set pnum 0} {$pnum < $nmerge} {incr pnum} {
		set sim [similarity $pnum $l $nlc $f \
			     [lrange $events $i [expr {$j-1}]]]
		if {$sim > $bestsim} {
		    set bestsim $sim
		    set bestpn $pnum
		}
	    }
	    if {$bestpn >= 0} {
		lappend ncol m$bestpn
	    }
	}
	set pnum -1
	foreach p $parents($id) {
	    incr pnum
	    if {![info exists delta($pnum)] || $pnum == $bestpn} continue
	    set olc [expr {$nlc + $delta($pnum)}]
	    set ol [expr {$l + $diffoffset($p)}]
	    incr diffoffset($p) $delta($pnum)
	    unset delta($pnum)
	    for {} {$olc > 0} {incr olc -1} {
		$ctext insert end "-$filelines($p,$f,$ol)\n" m$pnum
		incr ol
	    }
	}
	set endl [expr {$l + $nlc}]
	if {$bestpn >= 0} {
	    # show this pretty much as a normal diff
	    set p [lindex $parents($id) $bestpn]
	    set ol [expr {$l + $diffoffset($p)}]
	    incr diffoffset($p) $delta($bestpn)
	    unset delta($bestpn)
	    for {set k $i} {$k < $j} {incr k} {
		set e [lindex $events $k]
		if {[lindex $e 2] != $bestpn} continue
		set nl [lindex $e 0]
		set ol [expr {$ol + $nl - $l}]
		for {} {$l < $nl} {incr l} {
		    $ctext insert end "+$filelines($id,$f,$l)\n" $ncol
		}
		set c [lindex $e 3]
		for {} {$c > 0} {incr c -1} {
		    $ctext insert end "-$filelines($p,$f,$ol)\n" m$bestpn
		    incr ol
		}
		set nl [lindex $e 1]
		for {} {$l < $nl} {incr l} {
		    $ctext insert end "+$filelines($id,$f,$l)\n" mresult
		}
	    }
	}
	for {} {$l < $endl} {incr l} {
	    $ctext insert end "+$filelines($id,$f,$l)\n" $ncol
	}
    }
    while {$l < $grouplineend} {
	$ctext insert end " $filelines($id,$f,$l)\n"
	incr l
    }
    $ctext conf -state disabled
}

proc similarity {pnum l nlc f events} {
    global diffmergeid parents diffoffset filelines

    set id $diffmergeid
    set p [lindex $parents($id) $pnum]
    set ol [expr {$l + $diffoffset($p)}]
    set endl [expr {$l + $nlc}]
    set same 0
    set diff 0
    foreach e $events {
	if {[lindex $e 2] != $pnum} continue
	set nl [lindex $e 0]
	set ol [expr {$ol + $nl - $l}]
	for {} {$l < $nl} {incr l} {
	    incr same [string length $filelines($id,$f,$l)]
	    incr same
	}
	set oc [lindex $e 3]
	for {} {$oc > 0} {incr oc -1} {
	    incr diff [string length $filelines($p,$f,$ol)]
	    incr diff
	    incr ol
	}
	set nl [lindex $e 1]
	for {} {$l < $nl} {incr l} {
	    incr diff [string length $filelines($id,$f,$l)]
	    incr diff
	}
    }
    for {} {$l < $endl} {incr l} {
	incr same [string length $filelines($id,$f,$l)]
	incr same
    }
    if {$same == 0} {
	return 0
    }
    return [expr {200 * $same / (2 * $same + $diff)}]
}

proc startdiff {ids} {
    global treediffs diffids treepending diffmergeid

    set diffids $ids
    catch {unset diffmergeid}
    if {![info exists treediffs($ids)]} {
	if {![info exists treepending]} {
	    gettreediffs $ids
	}
    } else {
	addtocflist $ids
    }
}

proc addtocflist {ids} {
    global treediffs cflist
    foreach f $treediffs($ids) {
	$cflist insert end $f
    }
    getblobdiffs $ids
}

proc gettreediffs {ids} {
    global treediff parents treepending
    set treepending $ids
    set treediff {}
    set id [lindex $ids 0]
    set p [lindex $ids 1]
    if [catch {set gdtf [open "|git-diff-tree -r $p $id" r]}] return
    fconfigure $gdtf -blocking 0
    fileevent $gdtf readable [list gettreediffline $gdtf $ids]
}

proc gettreediffline {gdtf ids} {
    global treediff treediffs treepending diffids diffmergeid

    set n [gets $gdtf line]
    if {$n < 0} {
	if {![eof $gdtf]} return
	close $gdtf
	set treediffs($ids) $treediff
	unset treepending
	if {$ids != $diffids} {
	    gettreediffs $diffids
	} else {
	    if {[info exists diffmergeid]} {
		contmergediff $ids
	    } else {
		addtocflist $ids
	    }
	}
	return
    }
    set file [lindex $line 5]
    lappend treediff $file
}

proc getblobdiffs {ids} {
    global diffopts blobdifffd diffids env curdifftag curtagstart
    global difffilestart nextupdate diffinhdr treediffs

    set id [lindex $ids 0]
    set p [lindex $ids 1]
    set env(GIT_DIFF_OPTS) $diffopts
    set cmd [list | git-diff-tree -r -p -C $p $id]
    if {[catch {set bdf [open $cmd r]} err]} {
	puts "error getting diffs: $err"
	return
    }
    set diffinhdr 0
    fconfigure $bdf -blocking 0
    set blobdifffd($ids) $bdf
    set curdifftag Comments
    set curtagstart 0.0
    catch {unset difffilestart}
    fileevent $bdf readable [list getblobdiffline $bdf $diffids]
    set nextupdate [expr {[clock clicks -milliseconds] + 100}]
}

proc getblobdiffline {bdf ids} {
    global diffids blobdifffd ctext curdifftag curtagstart
    global diffnexthead diffnextnote difffilestart
    global nextupdate diffinhdr treediffs
    global gaudydiff

    set n [gets $bdf line]
    if {$n < 0} {
	if {[eof $bdf]} {
	    close $bdf
	    if {$ids == $diffids && $bdf == $blobdifffd($ids)} {
		$ctext tag add $curdifftag $curtagstart end
	    }
	}
	return
    }
    if {$ids != $diffids || $bdf != $blobdifffd($ids)} {
	return
    }
    $ctext conf -state normal
    if {[regexp {^diff --git a/(.*) b/(.*)} $line match fname newname]} {
	# start of a new file
	$ctext insert end "\n"
	$ctext tag add $curdifftag $curtagstart end
	set curtagstart [$ctext index "end - 1c"]
	set header $newname
	set here [$ctext index "end - 1c"]
	set i [lsearch -exact $treediffs($diffids) $fname]
	if {$i >= 0} {
	    set difffilestart($i) $here
	    incr i
	    $ctext mark set fmark.$i $here
	    $ctext mark gravity fmark.$i left
	}
	if {$newname != $fname} {
	    set i [lsearch -exact $treediffs($diffids) $newname]
	    if {$i >= 0} {
		set difffilestart($i) $here
		incr i
		$ctext mark set fmark.$i $here
		$ctext mark gravity fmark.$i left
	    }
	}
	set curdifftag "f:$fname"
	$ctext tag delete $curdifftag
	set l [expr {(78 - [string length $header]) / 2}]
	set pad [string range "----------------------------------------" 1 $l]
	$ctext insert end "$pad $header $pad\n" filesep
	set diffinhdr 1
    } elseif {[regexp {^(---|\+\+\+)} $line]} {
	set diffinhdr 0
    } elseif {[regexp {^@@ -([0-9]+),([0-9]+) \+([0-9]+),([0-9]+) @@(.*)} \
		   $line match f1l f1c f2l f2c rest]} {
	if {$gaudydiff} {
	    $ctext insert end "\t" hunksep
	    $ctext insert end "    $f1l    " d0 "    $f2l    " d1
	    $ctext insert end "    $rest \n" hunksep
	} else {
	    $ctext insert end "$line\n" hunksep
	}
	set diffinhdr 0
    } else {
	set x [string range $line 0 0]
	if {$x == "-" || $x == "+"} {
	    set tag [expr {$x == "+"}]
	    if {$gaudydiff} {
		set line [string range $line 1 end]
	    }
	    $ctext insert end "$line\n" d$tag
	} elseif {$x == " "} {
	    if {$gaudydiff} {
		set line [string range $line 1 end]
	    }
	    $ctext insert end "$line\n"
	} elseif {$diffinhdr || $x == "\\"} {
	    # e.g. "\ No newline at end of file"
	    $ctext insert end "$line\n" filesep
	} else {
	    # Something else we don't recognize
	    if {$curdifftag != "Comments"} {
		$ctext insert end "\n"
		$ctext tag add $curdifftag $curtagstart end
		set curtagstart [$ctext index "end - 1c"]
		set curdifftag Comments
	    }
	    $ctext insert end "$line\n" filesep
	}
    }
    $ctext conf -state disabled
    if {[clock clicks -milliseconds] >= $nextupdate} {
	incr nextupdate 100
	fileevent $bdf readable {}
	update
	fileevent $bdf readable "getblobdiffline $bdf {$ids}"
    }
}

proc nextfile {} {
    global difffilestart ctext
    set here [$ctext index @0,0]
    for {set i 0} {[info exists difffilestart($i)]} {incr i} {
	if {[$ctext compare $difffilestart($i) > $here]} {
	    if {![info exists pos]
		|| [$ctext compare $difffilestart($i) < $pos]} {
		set pos $difffilestart($i)
	    }
	}
    }
    if {[info exists pos]} {
	$ctext yview $pos
    }
}

proc listboxsel {} {
    global ctext cflist currentid
    if {![info exists currentid]} return
    set sel [lsort [$cflist curselection]]
    if {$sel eq {}} return
    set first [lindex $sel 0]
    catch {$ctext yview fmark.$first}
}

proc setcoords {} {
    global linespc charspc canvx0 canvy0 mainfont
    global xspc1 xspc2

    set linespc [font metrics $mainfont -linespace]
    set charspc [font measure $mainfont "m"]
    set canvy0 [expr 3 + 0.5 * $linespc]
    set canvx0 [expr 3 + 0.5 * $linespc]
    set xspc1(0) $linespc
    set xspc2 $linespc
}

proc redisplay {} {
    global selectedline stopped redisplaying phase
    if {$stopped > 1} return
    if {$phase == "getcommits"} return
    set redisplaying 1
    if {$phase == "drawgraph" || $phase == "incrdraw"} {
	set stopped 1
    } else {
	drawgraph
    }
}

proc incrfont {inc} {
    global mainfont namefont textfont selectedline ctext canv phase
    global stopped entries
    unmarkmatches
    set mainfont [lreplace $mainfont 1 1 [expr {[lindex $mainfont 1] + $inc}]]
    set namefont [lreplace $namefont 1 1 [expr {[lindex $namefont 1] + $inc}]]
    set textfont [lreplace $textfont 1 1 [expr {[lindex $textfont 1] + $inc}]]
    setcoords
    $ctext conf -font $textfont
    $ctext tag conf filesep -font [concat $textfont bold]
    foreach e $entries {
	$e conf -font $mainfont
    }
    if {$phase == "getcommits"} {
	$canv itemconf textitems -font $mainfont
    }
    redisplay
}

proc clearsha1 {} {
    global sha1entry sha1string
    if {[string length $sha1string] == 40} {
	$sha1entry delete 0 end
    }
}

proc sha1change {n1 n2 op} {
    global sha1string currentid sha1but
    if {$sha1string == {}
	|| ([info exists currentid] && $sha1string == $currentid)} {
	set state disabled
    } else {
	set state normal
    }
    if {[$sha1but cget -state] == $state} return
    if {$state == "normal"} {
	$sha1but conf -state normal -relief raised -text "Goto: "
    } else {
	$sha1but conf -state disabled -relief flat -text "SHA1 ID: "
    }
}

proc gotocommit {} {
    global sha1string currentid idline tagids
    global lineid numcommits

    if {$sha1string == {}
	|| ([info exists currentid] && $sha1string == $currentid)} return
    if {[info exists tagids($sha1string)]} {
	set id $tagids($sha1string)
    } else {
	set id [string tolower $sha1string]
	if {[regexp {^[0-9a-f]{4,39}$} $id]} {
	    set matches {}
	    for {set l 0} {$l < $numcommits} {incr l} {
		if {[string match $id* $lineid($l)]} {
		    lappend matches $lineid($l)
		}
	    }
	    if {$matches ne {}} {
		if {[llength $matches] > 1} {
		    error_popup "Short SHA1 id $id is ambiguous"
		    return
		}
		set id [lindex $matches 0]
	    }
	}
    }
    if {[info exists idline($id)]} {
	selectline $idline($id) 1
	return
    }
    if {[regexp {^[0-9a-fA-F]{4,}$} $sha1string]} {
	set type "SHA1 id"
    } else {
	set type "Tag"
    }
    error_popup "$type $sha1string is not known"
}

proc lineenter {x y id} {
    global hoverx hovery hoverid hovertimer
    global commitinfo canv

    if {![info exists commitinfo($id)]} return
    set hoverx $x
    set hovery $y
    set hoverid $id
    if {[info exists hovertimer]} {
	after cancel $hovertimer
    }
    set hovertimer [after 500 linehover]
    $canv delete hover
}

proc linemotion {x y id} {
    global hoverx hovery hoverid hovertimer

    if {[info exists hoverid] && $id == $hoverid} {
	set hoverx $x
	set hovery $y
	if {[info exists hovertimer]} {
	    after cancel $hovertimer
	}
	set hovertimer [after 500 linehover]
    }
}

proc lineleave {id} {
    global hoverid hovertimer canv

    if {[info exists hoverid] && $id == $hoverid} {
	$canv delete hover
	if {[info exists hovertimer]} {
	    after cancel $hovertimer
	    unset hovertimer
	}
	unset hoverid
    }
}

proc linehover {} {
    global hoverx hovery hoverid hovertimer
    global canv linespc lthickness
    global commitinfo mainfont

    set text [lindex $commitinfo($hoverid) 0]
    set ymax [lindex [$canv cget -scrollregion] 3]
    if {$ymax == {}} return
    set yfrac [lindex [$canv yview] 0]
    set x [expr {$hoverx + 2 * $linespc}]
    set y [expr {$hovery + $yfrac * $ymax - $linespc / 2}]
    set x0 [expr {$x - 2 * $lthickness}]
    set y0 [expr {$y - 2 * $lthickness}]
    set x1 [expr {$x + [font measure $mainfont $text] + 2 * $lthickness}]
    set y1 [expr {$y + $linespc + 2 * $lthickness}]
    set t [$canv create rectangle $x0 $y0 $x1 $y1 \
	       -fill \#ffff80 -outline black -width 1 -tags hover]
    $canv raise $t
    set t [$canv create text $x $y -anchor nw -text $text -tags hover]
    $canv raise $t
}

proc lineclick {x y id} {
    global ctext commitinfo children cflist canv

    unmarkmatches
    $canv delete hover
    # fill the details pane with info about this line
    $ctext conf -state normal
    $ctext delete 0.0 end
    $ctext insert end "Parent:\n "
    catch {destroy $ctext.$id}
    button $ctext.$id -text "Go:" -command "selbyid $id" \
	-padx 4 -pady 0
    $ctext window create end -window $ctext.$id -align center
    set info $commitinfo($id)
    $ctext insert end "\t[lindex $info 0]\n"
    $ctext insert end "\tAuthor:\t[lindex $info 1]\n"
    $ctext insert end "\tDate:\t[lindex $info 2]\n"
    $ctext insert end "\tID:\t$id\n"
    if {[info exists children($id)]} {
	$ctext insert end "\nChildren:"
	foreach child $children($id) {
	    $ctext insert end "\n "
	    catch {destroy $ctext.$child}
	    button $ctext.$child -text "Go:" -command "selbyid $child" \
		-padx 4 -pady 0
	    $ctext window create end -window $ctext.$child -align center
	    set info $commitinfo($child)
	    $ctext insert end "\t[lindex $info 0]"
	}
    }
    $ctext conf -state disabled

    $cflist delete 0 end
}

proc selbyid {id} {
    global idline
    if {[info exists idline($id)]} {
	selectline $idline($id) 1
    }
}

proc mstime {} {
    global startmstime
    if {![info exists startmstime]} {
	set startmstime [clock clicks -milliseconds]
    }
    return [format "%.3f" [expr {([clock click -milliseconds] - $startmstime) / 1000.0}]]
}

proc rowmenu {x y id} {
    global rowctxmenu idline selectedline rowmenuid

    if {![info exists selectedline] || $idline($id) eq $selectedline} {
	set state disabled
    } else {
	set state normal
    }
    $rowctxmenu entryconfigure 0 -state $state
    $rowctxmenu entryconfigure 1 -state $state
    $rowctxmenu entryconfigure 2 -state $state
    set rowmenuid $id
    tk_popup $rowctxmenu $x $y
}

proc diffvssel {dirn} {
    global rowmenuid selectedline lineid
    global ctext cflist
    global commitinfo

    if {![info exists selectedline]} return
    if {$dirn} {
	set oldid $lineid($selectedline)
	set newid $rowmenuid
    } else {
	set oldid $rowmenuid
	set newid $lineid($selectedline)
    }
    $ctext conf -state normal
    $ctext delete 0.0 end
    $ctext mark set fmark.0 0.0
    $ctext mark gravity fmark.0 left
    $cflist delete 0 end
    $cflist insert end "Top"
    $ctext insert end "From $oldid\n     "
    $ctext insert end [lindex $commitinfo($oldid) 0]
    $ctext insert end "\n\nTo   $newid\n     "
    $ctext insert end [lindex $commitinfo($newid) 0]
    $ctext insert end "\n"
    $ctext conf -state disabled
    $ctext tag delete Comments
    $ctext tag remove found 1.0 end
    startdiff [list $newid $oldid]
}

proc mkpatch {} {
    global rowmenuid currentid commitinfo patchtop patchnum

    if {![info exists currentid]} return
    set oldid $currentid
    set oldhead [lindex $commitinfo($oldid) 0]
    set newid $rowmenuid
    set newhead [lindex $commitinfo($newid) 0]
    set top .patch
    set patchtop $top
    catch {destroy $top}
    toplevel $top
    label $top.title -text "Generate patch"
    grid $top.title - -pady 10
    label $top.from -text "From:"
    entry $top.fromsha1 -width 40 -relief flat
    $top.fromsha1 insert 0 $oldid
    $top.fromsha1 conf -state readonly
    grid $top.from $top.fromsha1 -sticky w
    entry $top.fromhead -width 60 -relief flat
    $top.fromhead insert 0 $oldhead
    $top.fromhead conf -state readonly
    grid x $top.fromhead -sticky w
    label $top.to -text "To:"
    entry $top.tosha1 -width 40 -relief flat
    $top.tosha1 insert 0 $newid
    $top.tosha1 conf -state readonly
    grid $top.to $top.tosha1 -sticky w
    entry $top.tohead -width 60 -relief flat
    $top.tohead insert 0 $newhead
    $top.tohead conf -state readonly
    grid x $top.tohead -sticky w
    button $top.rev -text "Reverse" -command mkpatchrev -padx 5
    grid $top.rev x -pady 10
    label $top.flab -text "Output file:"
    entry $top.fname -width 60
    $top.fname insert 0 [file normalize "patch$patchnum.patch"]
    incr patchnum
    grid $top.flab $top.fname -sticky w
    frame $top.buts
    button $top.buts.gen -text "Generate" -command mkpatchgo
    button $top.buts.can -text "Cancel" -command mkpatchcan
    grid $top.buts.gen $top.buts.can
    grid columnconfigure $top.buts 0 -weight 1 -uniform a
    grid columnconfigure $top.buts 1 -weight 1 -uniform a
    grid $top.buts - -pady 10 -sticky ew
    focus $top.fname
}

proc mkpatchrev {} {
    global patchtop

    set oldid [$patchtop.fromsha1 get]
    set oldhead [$patchtop.fromhead get]
    set newid [$patchtop.tosha1 get]
    set newhead [$patchtop.tohead get]
    foreach e [list fromsha1 fromhead tosha1 tohead] \
	    v [list $newid $newhead $oldid $oldhead] {
	$patchtop.$e conf -state normal
	$patchtop.$e delete 0 end
	$patchtop.$e insert 0 $v
	$patchtop.$e conf -state readonly
    }
}

proc mkpatchgo {} {
    global patchtop

    set oldid [$patchtop.fromsha1 get]
    set newid [$patchtop.tosha1 get]
    set fname [$patchtop.fname get]
    if {[catch {exec git-diff-tree -p $oldid $newid >$fname &} err]} {
	error_popup "Error creating patch: $err"
    }
    catch {destroy $patchtop}
    unset patchtop
}

proc mkpatchcan {} {
    global patchtop

    catch {destroy $patchtop}
    unset patchtop
}

proc mktag {} {
    global rowmenuid mktagtop commitinfo

    set top .maketag
    set mktagtop $top
    catch {destroy $top}
    toplevel $top
    label $top.title -text "Create tag"
    grid $top.title - -pady 10
    label $top.id -text "ID:"
    entry $top.sha1 -width 40 -relief flat
    $top.sha1 insert 0 $rowmenuid
    $top.sha1 conf -state readonly
    grid $top.id $top.sha1 -sticky w
    entry $top.head -width 60 -relief flat
    $top.head insert 0 [lindex $commitinfo($rowmenuid) 0]
    $top.head conf -state readonly
    grid x $top.head -sticky w
    label $top.tlab -text "Tag name:"
    entry $top.tag -width 60
    grid $top.tlab $top.tag -sticky w
    frame $top.buts
    button $top.buts.gen -text "Create" -command mktaggo
    button $top.buts.can -text "Cancel" -command mktagcan
    grid $top.buts.gen $top.buts.can
    grid columnconfigure $top.buts 0 -weight 1 -uniform a
    grid columnconfigure $top.buts 1 -weight 1 -uniform a
    grid $top.buts - -pady 10 -sticky ew
    focus $top.tag
}

proc domktag {} {
    global mktagtop env tagids idtags
    global idpos idline linehtag canv selectedline

    set id [$mktagtop.sha1 get]
    set tag [$mktagtop.tag get]
    if {$tag == {}} {
	error_popup "No tag name specified"
	return
    }
    if {[info exists tagids($tag)]} {
	error_popup "Tag \"$tag\" already exists"
	return
    }
    if {[catch {
	set dir [gitdir]
	set fname [file join $dir "refs/tags" $tag]
	set f [open $fname w]
	puts $f $id
	close $f
    } err]} {
	error_popup "Error creating tag: $err"
	return
    }

    set tagids($tag) $id
    lappend idtags($id) $tag
    $canv delete tag.$id
    set xt [eval drawtags $id $idpos($id)]
    $canv coords $linehtag($idline($id)) $xt [lindex $idpos($id) 2]
    if {[info exists selectedline] && $selectedline == $idline($id)} {
	selectline $selectedline 0
    }
}

proc mktagcan {} {
    global mktagtop

    catch {destroy $mktagtop}
    unset mktagtop
}

proc mktaggo {} {
    domktag
    mktagcan
}

proc writecommit {} {
    global rowmenuid wrcomtop commitinfo wrcomcmd

    set top .writecommit
    set wrcomtop $top
    catch {destroy $top}
    toplevel $top
    label $top.title -text "Write commit to file"
    grid $top.title - -pady 10
    label $top.id -text "ID:"
    entry $top.sha1 -width 40 -relief flat
    $top.sha1 insert 0 $rowmenuid
    $top.sha1 conf -state readonly
    grid $top.id $top.sha1 -sticky w
    entry $top.head -width 60 -relief flat
    $top.head insert 0 [lindex $commitinfo($rowmenuid) 0]
    $top.head conf -state readonly
    grid x $top.head -sticky w
    label $top.clab -text "Command:"
    entry $top.cmd -width 60 -textvariable wrcomcmd
    grid $top.clab $top.cmd -sticky w -pady 10
    label $top.flab -text "Output file:"
    entry $top.fname -width 60
    $top.fname insert 0 [file normalize "commit-[string range $rowmenuid 0 6]"]
    grid $top.flab $top.fname -sticky w
    frame $top.buts
    button $top.buts.gen -text "Write" -command wrcomgo
    button $top.buts.can -text "Cancel" -command wrcomcan
    grid $top.buts.gen $top.buts.can
    grid columnconfigure $top.buts 0 -weight 1 -uniform a
    grid columnconfigure $top.buts 1 -weight 1 -uniform a
    grid $top.buts - -pady 10 -sticky ew
    focus $top.fname
}

proc wrcomgo {} {
    global wrcomtop

    set id [$wrcomtop.sha1 get]
    set cmd "echo $id | [$wrcomtop.cmd get]"
    set fname [$wrcomtop.fname get]
    if {[catch {exec sh -c $cmd >$fname &} err]} {
	error_popup "Error writing commit: $err"
    }
    catch {destroy $wrcomtop}
    unset wrcomtop
}

proc wrcomcan {} {
    global wrcomtop

    catch {destroy $wrcomtop}
    unset wrcomtop
}

proc doquit {} {
    global stopped
    set stopped 100
    destroy .
}

# defaults...
set datemode 0
set boldnames 0
set diffopts "-U 5 -p"
set wrcomcmd "git-diff-tree --stdin -p --pretty"

set mainfont {Helvetica 9}
set textfont {Courier 9}
set findmergefiles 0
set gaudydiff 0
set maxgraphpct 50

set colors {green red blue magenta darkgrey brown orange}

catch {source ~/.gitk}

set namefont $mainfont
if {$boldnames} {
    lappend namefont bold
}

set revtreeargs {}
foreach arg $argv {
    switch -regexp -- $arg {
	"^$" { }
	"^-b" { set boldnames 1 }
	"^-d" { set datemode 1 }
	default {
	    lappend revtreeargs $arg
	}
    }
}

set history {}
set historyindex 0

set stopped 0
set redisplaying 0
set stuffsaved 0
set patchnum 0
setcoords
makewindow
readrefs
getcommits $revtreeargs
