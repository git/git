#!/bin/sh

NWD=contrib/workdir/git-new-workdir

inst_prefix=$(
	IFS=:
	for p in $PATH
	do
		probed=${p%/git-active/bin}
		if test "$probed" != "$p"
		then
			echo "$probed"
			exit
		fi
	done
	echo $HOME
)

force= with_dash= M= install= nodoc= notest= bootstrap= branches= jobs=
scratch=
while	case "$1" in
	--pedantic | --locale=* | --loose) M="$M $1" ;;
	--force) force=$1 ;;
	--dash) with_dash=y ;;
	--noinstall) install=noinstall ;;
	--nodoc) nodoc=y ;;
	--notest) notest=y ;;
	--test=*) test="$1" ;;
	--scratch) scratch=y ;;
	--bootstrap) bootstrap=y ;;
	--base=*) BUILDBASE=${1#*=} ;;
	--branches=*) branches=${1#*=} ;;
	-j*) jobs=$1 ;;
	-*) echo >&2 "Unknown option: $1"; exit 1 ;;
	*) break ;;
	esac
do
	shift
done

for TRASH in /dev/shm /tmp ""
do
	if test -n "$TRASH" && test -d "$TRASH" && test -w "$TRASH"
	then
		TRASH="--root=$TRASH/testpen"
		break
	fi
done

sh -c 'asciidoc --version >/dev/null 2>&1' || nodoc=y
if sh -c 'prove --version >/dev/null 2>&1' &&
   sh -c 'prove --exec : >/dev/null 2>&1'
then
	DEFAULT_TEST_TARGET=prove GIT_PROVE_OPTS="$jobs"
	export DEFAULT_TEST_TARGET GIT_PROVE_OPTS
fi
GIT_TEST_OPTS="$TRASH${GIT_TEST_OPTS+" $GIT_TEST_OPTS"}"
export GIT_TEST_OPTS

test -f /bin/dash || with_dash=
if test -z "$BUILDBASE"
then
	if test -d "$inst_prefix/buildfarm"
	then
		BUILDBASE="$inst_prefix/buildfarm"
	elif test -d "../buildfarm"
	then
		BUILDBASE=../buildfarm
	else
		echo >&2 "Buildbase unknown"
		exit 1
	fi
fi
test -n "$branches" || branches='next master maint jch pu'
test -n "$jobs" || jobs=-j2

for branch in $branches
do
	echo "** $branch **"
	revision=$(git show-ref -s --verify "refs/heads/$branch") || {
		echo "** No $branch"
		continue
	}

	if test ! -d "$BUILDBASE/$branch"
	then
		if test -z "$bootstrap"
		then
			echo "** No $BUILDBASE/$branch"
			continue
		fi
		"$NWD" . "$BUILDBASE/$branch" $branch &&
		ln -s "$(pwd)/Meta" "$BUILDBASE/$branch/Meta" || {
			echo "** Failed to bootstrap $BUILDBASE/$branch"
			continue
		}
	fi

	private=$(git rev-parse -q --verify private-$branch 2>/dev/null)
	case $? in 0|1) ;; *) exit $? ;; esac

	if	test -f "$inst_prefix/git-$branch/bin/git" &&
		installed=$($inst_prefix/git-$branch/bin/git version) &&
		if version=$(expr "$installed" : '.*\.g\([0-9a-f]*\)$')
		then
			:
		elif version=v$(expr "$installed" : \
				'git version \(.*\)\.rc[0-9]*$')
		then
			version="$version"-$(expr "$installed" : \
				'git version .*\.\(rc[0-9]*\)$')
		else
			version=v$(expr "$installed" : 'git version \(.*\)')
		fi &&
		version=$(git rev-parse --verify "$version^0" 2>/dev/null) &&
		test "z$version" = "z$revision"
	then
		echo "* up-to-date version \"$installed\" is already installed from $branch"
		test -n "$force" || continue
	fi

	(
		skip_test=$notest
		case ",$version,$revision," in
		*,,*)
			;;
		*)
			if git diff --quiet --exit-code $version $revision
			then
				skip_test=1
			fi
			;;
		esac
		case "$branch, $branches " in
		jch,*' next '*)
			if git diff --quiet --exit-code jch next
			then
				skip_test=1
			fi
			;;
		esac
		case "$skip_test" in
		?*)	dotest= ;;
		'')	dotest=test ;;
		esac

		cd "$BUILDBASE/$branch"
		git reset --hard  &&
		case "$(git symbolic-ref HEAD)" in
		"refs/heads/$branch")
			: ;;
		*)
			git checkout "$branch" &&
			git reset --hard || exit
		esac &&

		case "$scratch" in
		'')
			;;
		y)
			Meta/Make clean
			;;
		esac &&

		case "$private" in
		'')
			;;
		?*)
			git merge --squash --no-commit "$private" || {
				echo >&2 "** Cannot apply private edition changes"
				git reset --hard
			}
			;;
		esac &&

		save=$(git rev-parse HEAD) &&

		Meta/Make $M ${test+"$test"} $jobs -- ${with_dash:+SHELL_PATH=/bin/dash} $dotest &&

		{
			test -n "$nodoc" ||
			if test "$save" = "$(git rev-parse HEAD)"
			then
				Meta/Make $M $jobs -- doc &&
				Meta/Make $M -- install-man install-html
			else
				echo >&2 "Head moved--not installing docs"
			fi
		} &&

		{
			test z$install = znoinstall ||
			if test "$save" = "$(git rev-parse HEAD)"
			then
				Meta/Make $M -- install
			else
				echo >&2 "Head moved--not installing"
			fi
		} || exit $?

		git reset --hard
	) </dev/null || exit $?

done
